function RWTraffic(airport, situation, r) {
  this._r = r;
  this._airport = airport;
  this._situation = situation;
  this._airports = {};
  this._inRequest = {};
}

RWTraffic.prototype.inbound = function(distance, cb) {
  var icao = this._airport.icao();
  if (this._airports[icao] && this._airports[icao].inbound
      && this._airports[icao].inbound.lastUpdate >= new Date().getTime() - 15 * 1000) {
    cb(this._airports[icao].inbound.aircraft, this._airports[icao].inbound.lastUpdate);
    return;
  } else if (this._inRequest[icao])
    return;
  this._inRequest[icao] = true;
  var self = this;
  $.post('/sandbox/sim/feeds/proxy.php', {
    url: 'http://flightaware.com/live/airport/' + icao
  }, function(data) {
    var jsonInbound = data.match(/json_inbound = ({.+});/);
    var arrivals = JSON.parse(jsonInbound[1]);
    var aircraftList = {};
    for (var i in arrivals.features) {
      var aircraft = arrivals.features[i];
      if (aircraft.properties.projected === 0) {
        var inboundAircraft = new Aircraft(aircraft.properties.ident);
        inboundAircraft.setType(aircraft.properties.type);
        inboundAircraft.setCategory('J');
        inboundAircraft.setFlightRules('I');
        inboundAircraft.setArrival(aircraft.properties.destination);
        inboundAircraft.setLat(aircraft.geometry.coordinates[1]);
        inboundAircraft.setLon(aircraft.geometry.coordinates[0]);
        inboundAircraft.setAltitude(aircraft.properties.altitude * 100);
        inboundAircraft.setHeading((aircraft.properties.direction + 180 - self._r.magVar()) % 360);
        inboundAircraft.setSpeed(inboundAircraft.airspeed(aircraft.properties.groundspeed));
        inboundAircraft.setLastSimulated(self._situation.elapsed());
        inboundAircraft.performance().loadFromCategory(inboundAircraft.category());
        if (inboundAircraft.position().distanceTo(self._airport.position()) * 0.539957 < distance)
          aircraftList[inboundAircraft.callsign()] = inboundAircraft;
      }
    }
    if (self._airports[icao] === undefined)
      self._airports[icao] = {};
    self._airports[icao].inbound = {
      lastUpdate: new Date().getTime(),
      aircraft: aircraftList
    };
    //console.log('new update');
    self._inRequest[icao] = false;
    cb(aircraftList, self._airports[icao].inbound.lastUpdate);
  }, 'html');
};function Flow() {
  this._urlRoot = 'http://flightaware.com';
  this._paths = [];
  this._positionReports = [];
  this._aircraftPaths = [];
}

Flow.ERROR = {
  NO_DATA: 1,
  END_PATH: 2
};

Flow.prototype.average = function(position) {
  var forceReports = {
    altitude: [],
    heading: [],
    speed: []
  };
  var minDistance = {
    altitude: 3,
    heading: 3,
    speed: 3
  };
  for (var i in this._positionReports) {
    var report = this._positionReports[i];
    var distance = report.position.distanceTo(position) * 0.539957;
    if (distance <= 3) {
      report.distance = distance;
      if (!isNaN(report.altitude)) {
        forceReports.altitude.push(report);
        if (distance < minDistance)
          minDistance.altitude = distance;
      }
      if (!isNaN(report.heading)) {
        forceReports.heading.push(report);
        if (distance < minDistance)
          minDistance.heading = distance;
      }
      if (!isNaN(report.speed)) {
        forceReports.speed.push(report);
        if (distance < minDistance)
          minDistance.speed = distance;
      }
    }
  }
  var averageAltitude = -1,
      averageHeading = -1,
      averageSpeed = -1;
  if (forceReports.altitude.length > 0) {
    var altitudeSum = 0;
    var totalAltitudeWeight = 0;
    for (var a in forceReports.altitude) {
      var report = forceReports.altitude[a];
      var weight = Math.pow(minDistance.altitude / report.distance, 0.5);
      altitudeSum += report.altitude * weight;
      totalAltitudeWeight += weight;
    }
    averageAltitude = altitudeSum / totalAltitudeWeight;
  }
  if (forceReports.heading.length > 0) {
    var headingX = 0,
        headingY = 0;
    for (var h in forceReports.heading) {
      var report = forceReports.heading[h];
      var weight = Math.pow(minDistance.heading / report.distance, 0.5);
      var headingInRad = (((90 - report.heading) + 360) % 360) * Math.PI / 180;
      headingX += Math.cos(headingInRad) * weight;
      headingY += Math.sin(headingInRad) * weight;
    }
    averageHeading = ((90 - Math.atan2(headingY, headingX) * 180 / Math.PI) + 360) % 360;
  }
  if (forceReports.speed.length > 0) {
    var speedSum = 0;
    var totalSpeedWeight = 0;
    for (var s in forceReports.speed) {
      var report = forceReports.speed[s];
      var weight = Math.pow(minDistance.speed / report.distance, 0.5);
      speedSum += report.speed * weight;
      totalSpeedWeight += weight;
    }
    averageSpeed = speedSum / totalSpeedWeight;
  }
  return {
    altitude: averageAltitude,
    heading: (averageHeading - scope.renderer().magVar()) + 360 % 360,
    speed: averageSpeed
  };
};

Flow.prototype.project = function(position, minutes) {
  var minDistance = 3,
      forceReports = [];
      
  for (var i in this._positionReports) {
    var report = this._positionReports[i];
    var distance = report.position.distanceTo(position) * 0.539957;
    if (distance <= 3) {
      report.distance = distance;
      forceReports.push(report);
      if (distance < minDistance)
        minDistance = distance;
    }
  }

  var sumX = 0,
      sumY = 0,
      sumZ = 0,
      totalWeight = 0,
      endProjections = 0,
      projectionThreshold = Math.floor(forceReports.length * 0.33);

  for (var j in forceReports) {
    var forceReport = forceReports[j],
        projection = forceReport.aircraftPath[forceReport.index + minutes];
    if (projection) {
      var lat = projection.position._lat * Math.PI / 180,
          lon = projection.position._lon * Math.PI / 180,
          x = Math.cos(lat) * Math.cos(lon),
          y = Math.cos(lat) * Math.sin(lon),
          z = Math.sin(lat),
          weight = Math.pow(minDistance / forceReport.distance, 0.5);
      sumX += x * weight;
      sumY += y * weight;
      sumZ += z * weight;
      totalWeight += weight;
    } else {
      endProjections++;
      if (endProjections >= projection)
        throw Flow.ERROR.END_PATH;
    }
  }

  var avgX = sumX / totalWeight,
      avgY = sumY / totalWeight,
      avgZ = sumZ / totalWeight,
      pLon = Math.atan2(avgY, avgX),
      pHyp = Math.sqrt(Math.pow(avgX, 2) + Math.pow(avgY, 2)),
      pLat = Math.atan2(avgZ, pHyp);

  if (isNaN(pLat) || isNaN(pLon))
    throw Flow.ERROR.NO_DATA;

  return new LatLon(pLat * 180 / Math.PI, pLon * 180 / Math.PI);
};

Flow.prototype.countInRange = function(position, range) {
  var count = 0;
  for (var i in this._positionReports) {
    var distance = this._positionReports[i].position.distanceTo(position) * 0.539957;
    if (distance <= range)
      count++;
  }
  return count;
};

Flow.prototype.loadRecent = function(airport, limit, cb) {
  var flow = this;
  for (var o = 0; o < 20; o += 20) {
    $.get('proxy', {
      url: this._urlRoot + '/live/airport/KBOS/arrivals?;offset=' + o
    }, function(data) {
      var flights = data.match(/\/live\/flight\/\w+/g);
      for (var i = 1; i < flights.length; i++) {
        (function(i) {
          $.get('proxy', {
            url: flow._urlRoot + flights[i]
          }, function(data) {
            var path = data.match(/data-target='(.+?)' style/);
            var link = flow._urlRoot + path[1] + '/tracklog';
            $.get('proxy', {
              url: link
            }, function(data) {
              //console.log(data);
              var path = [];

              var rows = data.match(/<tr class="smallrow[12]{1}">[\s\S]+?<\/tr>/g);
              //.+?<td align="center">.+?<\/td>.+?<td align="center">.+?&deg;<\/td>.+?<td align="left">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?&nbsp;
              //console.log(stuff);


              var aircraftPath = [];

              for (var i in rows) {
                var row = rows[i];
                //console.log(row);
                var position = row.match(/<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)&deg;<\/td>[\s\S]+?<td align="left">(.+?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)&nbsp;/);
                //console.log(position);
                var time = position[1];
                var lat = parseFloat(position[2]);
                var lon = parseFloat(position[3]);
                var course = parseInt(position[4]);
                var direction = position[5];
                var groundspeed = parseInt(position[6]);
                var groundspeedMPH = parseInt(position[7]);
                var altitude = parseInt(position[8].replace(',', ''));

                aircraftPath[i] = {
                  position: new LatLon(lat, lon),
                  heading: course,
                  speed: groundspeed,
                  altitude: altitude,
                  aircraftPath: aircraftPath,
                  index: parseInt(i, 10)
                };
                flow._positionReports.push(aircraftPath[i]);
                console.log('added');
              }
              flow._aircraftPaths.push(aircraftPath);


              











              var position = data.match(/"center">(.+?)</g);
              var numPositionReports = position.length / 4;
              for (var i = 0; i < numPositionReports; i++) {
                var latMatch = position[i * 4 + 1].match(/>(.+?)</);
                var lonMatch = position[i * 4 + 2].match(/>(.+?)</);
                path[i] = [parseFloat(latMatch[1]), parseFloat(lonMatch[1])];
              }
              flow._paths.push(path);
              //cb(path);
            }, 'html');
          }, 'html');
        })(i);
      }
    }, 'html');
  }
};

Flow.prototype.loadRecent2 = function(airport, limit, cb) {
  var flow = this;
  $.get('proxy', {
    url: this._urlRoot + '/live/flight/SKV7384'
  }, function(data) {
    var pathString = data.match(/trackstring = ({.+});/);
    var pathObject = JSON.parse(pathString[1]);
    var path = pathObject.features[2].geometry.coordinates;
    for (var i in path) {
      var temp = path[i][0];
      path[i][0] = path[i][1];
      path[i][1] = temp;
    }
    flow._paths['SKV73841'] = path;
    cb(path);
  }, 'html');
};

Flow.prototype.renderPath = function(path, r) {
  // r.context().fillStyle = 'rgb(255, 255, 0';
  // for (var i in path) {
  //   var pos = r.gtoc(path[i][0], path[i][1]);
  //   r.context().fillRect(pos.x - 2, pos.y - 2, 4, 4);
  // }
  r.context().lineWidth = 1.5;
  r.context().strokeStyle = 'rgba(255, 255, 0, .1)';
  r.context().beginPath();
  var start = r.gtoc(path[0][0], path[0][1]);
  r.context().moveTo(start.x, start.y);
  for (var i = 1; i < path.length; i++) {
    var next = r.gtoc(path[i][0], path[i][1]);
    r.context().lineTo(next.x, next.y);
  }
  r.context().stroke();
};

Flow.prototype.render = function(r) {
  for (var i in this._paths)
    this.renderPath(this._paths[i], r);
};/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Latitude/longitude spherical geodesy formulae & scripts (c) Chris Veness 2002-2012            */
/*   - www.movable-type.co.uk/scripts/latlong.html                                                */
/*                                                                                                */
/*  Sample usage:                                                                                 */
/*    var p1 = new LatLon(51.5136, -0.0983);                                                      */
/*    var p2 = new LatLon(51.4778, -0.0015);                                                      */
/*    var dist = p1.distanceTo(p2);          // in km                                             */
/*    var brng = p1.bearingTo(p2);           // in degrees clockwise from north                   */
/*    ... etc                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Note that minimal error checking is performed in this example code!                           */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/**
 * @requires Geo
 */
 
 
/**
 * Creates a point on the earth's surface at the supplied latitude / longitude
 *
 * @constructor
 * @param {Number} lat: latitude in numeric degrees
 * @param {Number} lon: longitude in numeric degrees
 * @param {Number} [rad=6371]: radius of earth if different value is required from standard 6,371km
 */
function LatLon(lat, lon, rad) {
  if (typeof(rad) == 'undefined') rad = 6371;  // earth's mean radius in km
  // only accept numbers or valid numeric strings
  this._lat = typeof(lat)=='number' ? lat : typeof(lat)=='string' && lat.trim()!='' ? +lat : NaN;
  this._lon = typeof(lon)=='number' ? lon : typeof(lon)=='string' && lon.trim()!='' ? +lon : NaN;
  this._radius = typeof(rad)=='number' ? rad : typeof(rad)=='string' && trim(lon)!='' ? +rad : NaN;
}


/**
 * Returns the distance from this point to the supplied point, in km 
 * (using Haversine formula)
 *
 * from: Haversine formula - R. W. Sinnott, "Virtues of the Haversine",
 *       Sky and Telescope, vol 68, no 2, 1984
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @param   {Number} [precision=4]: no of significant digits to use for returned value
 * @returns {Number} Distance in km between this point and destination point
 */
LatLon.prototype.distanceTo = function(point, precision) {
  // default 4 sig figs reflects typical 0.3% accuracy of spherical model
  if (typeof precision == 'undefined') precision = 4;
  
  var R = this._radius;
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  var lat2 = point._lat.toRad(), lon2 = point._lon.toRad();
  var dLat = lat2 - lat1;
  var dLon = lon2 - lon1;

  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1) * Math.cos(lat2) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  var d = R * c;
  return d.toPrecisionFixed(precision);
}


/**
 * Returns the (initial) bearing from this point to the supplied point, in degrees
 *   see http://williams.best.vwh.net/avform.htm#Crs
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Initial bearing in degrees from North
 */
LatLon.prototype.bearingTo = function(point) {
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();

  var y = Math.sin(dLon) * Math.cos(lat2);
  var x = Math.cos(lat1)*Math.sin(lat2) -
          Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  var brng = Math.atan2(y, x);
  
  return (brng.toDeg()+360) % 360;
}


/**
 * Returns final bearing arriving at supplied destination point from this point; the final bearing 
 * will differ from the initial bearing by varying degrees according to distance and latitude
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Final bearing in degrees from North
 */
LatLon.prototype.finalBearingTo = function(point) {
  // get initial bearing from supplied point back to this point...
  var lat1 = point._lat.toRad(), lat2 = this._lat.toRad();
  var dLon = (this._lon-point._lon).toRad();

  var y = Math.sin(dLon) * Math.cos(lat2);
  var x = Math.cos(lat1)*Math.sin(lat2) -
          Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  var brng = Math.atan2(y, x);
          
  // ... & reverse it by adding 180°
  return (brng.toDeg()+180) % 360;
}


/**
 * Returns the midpoint between this point and the supplied point.
 *   see http://mathforum.org/library/drmath/view/51822.html for derivation
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {LatLon} Midpoint between this point and the supplied point
 */
LatLon.prototype.midpointTo = function(point) {
  lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();

  var Bx = Math.cos(lat2) * Math.cos(dLon);
  var By = Math.cos(lat2) * Math.sin(dLon);

  lat3 = Math.atan2(Math.sin(lat1)+Math.sin(lat2),
                    Math.sqrt( (Math.cos(lat1)+Bx)*(Math.cos(lat1)+Bx) + By*By) );
  lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/**
 * Returns the destination point from this point having travelled the given distance (in km) on the 
 * given initial bearing (bearing may vary before destination is reached)
 *
 *   see http://williams.best.vwh.net/avform.htm#LL
 *
 * @param   {Number} brng: Initial bearing in degrees
 * @param   {Number} dist: Distance in km
 * @returns {LatLon} Destination point
 */
LatLon.prototype.destinationPoint = function(brng, dist) {
  dist = typeof(dist)=='number' ? dist : typeof(dist)=='string' && dist.trim()!='' ? +dist : NaN;
  dist = dist/this._radius;  // convert dist to angular distance in radians
  brng = brng.toRad();  // 
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();

  var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) + 
                        Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
  var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1), 
                               Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
  lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

  return new LatLon(lat2.toDeg(), lon2.toDeg());
}


/**
 * Returns the point of intersection of two paths defined by point and bearing
 *
 *   see http://williams.best.vwh.net/avform.htm#Intersection
 *
 * @param   {LatLon} p1: First point
 * @param   {Number} brng1: Initial bearing from first point
 * @param   {LatLon} p2: Second point
 * @param   {Number} brng2: Initial bearing from second point
 * @returns {LatLon} Destination point (null if no unique intersection defined)
 */
LatLon.intersection = function(p1, brng1, p2, brng2) {
  brng1 = typeof brng1 == 'number' ? brng1 : typeof brng1 == 'string' && trim(brng1)!='' ? +brng1 : NaN;
  brng2 = typeof brng2 == 'number' ? brng2 : typeof brng2 == 'string' && trim(brng2)!='' ? +brng2 : NaN;
  lat1 = p1._lat.toRad(), lon1 = p1._lon.toRad();
  lat2 = p2._lat.toRad(), lon2 = p2._lon.toRad();
  brng13 = brng1.toRad(), brng23 = brng2.toRad();
  dLat = lat2-lat1, dLon = lon2-lon1;
  
  dist12 = 2*Math.asin( Math.sqrt( Math.sin(dLat/2)*Math.sin(dLat/2) + 
    Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2) ) );
  if (dist12 == 0) return null;
  
  // initial/final bearings between points
  brngA = Math.acos( ( Math.sin(lat2) - Math.sin(lat1)*Math.cos(dist12) ) / 
    ( Math.sin(dist12)*Math.cos(lat1) ) );
  if (isNaN(brngA)) brngA = 0;  // protect against rounding
  brngB = Math.acos( ( Math.sin(lat1) - Math.sin(lat2)*Math.cos(dist12) ) / 
    ( Math.sin(dist12)*Math.cos(lat2) ) );
  
  if (Math.sin(lon2-lon1) > 0) {
    brng12 = brngA;
    brng21 = 2*Math.PI - brngB;
  } else {
    brng12 = 2*Math.PI - brngA;
    brng21 = brngB;
  }
  
  alpha1 = (brng13 - brng12 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 2-1-3
  alpha2 = (brng21 - brng23 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 1-2-3
  
  if (Math.sin(alpha1)==0 && Math.sin(alpha2)==0) return null;  // infinite intersections
  if (Math.sin(alpha1)*Math.sin(alpha2) < 0) return null;       // ambiguous intersection
  
  //alpha1 = Math.abs(alpha1);
  //alpha2 = Math.abs(alpha2);
  // ... Ed Williams takes abs of alpha1/alpha2, but seems to break calculation?
  
  alpha3 = Math.acos( -Math.cos(alpha1)*Math.cos(alpha2) + 
                       Math.sin(alpha1)*Math.sin(alpha2)*Math.cos(dist12) );
  dist13 = Math.atan2( Math.sin(dist12)*Math.sin(alpha1)*Math.sin(alpha2), 
                       Math.cos(alpha2)+Math.cos(alpha1)*Math.cos(alpha3) )
  lat3 = Math.asin( Math.sin(lat1)*Math.cos(dist13) + 
                    Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng13) );
  dLon13 = Math.atan2( Math.sin(brng13)*Math.sin(dist13)*Math.cos(lat1), 
                       Math.cos(dist13)-Math.sin(lat1)*Math.sin(lat3) );
  lon3 = lon1+dLon13;
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/**
 * Returns the distance from this point to the supplied point, in km, travelling along a rhumb line
 *
 *   see http://williams.best.vwh.net/avform.htm#Rhumb
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Distance in km between this point and destination point
 */
LatLon.prototype.rhumbDistanceTo = function(point) {
  var R = this._radius;
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLat = (point._lat-this._lat).toRad();
  var dLon = Math.abs(point._lon-this._lon).toRad();
  
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  var q = (isFinite(dLat/dPhi)) ? dLat/dPhi : Math.cos(lat1);  // E-W line gives dPhi=0
  
  // if dLon over 180° take shorter rhumb across anti-meridian:
  if (Math.abs(dLon) > Math.PI) {
    dLon = dLon>0 ? -(2*Math.PI-dLon) : (2*Math.PI+dLon);
  }
  
  var dist = Math.sqrt(dLat*dLat + q*q*dLon*dLon) * R; 
  
  return dist.toPrecisionFixed(4);  // 4 sig figs reflects typical 0.3% accuracy of spherical model
}

/**
 * Returns the bearing from this point to the supplied point along a rhumb line, in degrees
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Bearing in degrees from North
 */
LatLon.prototype.rhumbBearingTo = function(point) {
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();
  
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  if (Math.abs(dLon) > Math.PI) dLon = dLon>0 ? -(2*Math.PI-dLon) : (2*Math.PI+dLon);
  var brng = Math.atan2(dLon, dPhi);
  
  return (brng.toDeg()+360) % 360;
}

/**
 * Returns the destination point from this point having travelled the given distance (in km) on the 
 * given bearing along a rhumb line
 *
 * @param   {Number} brng: Bearing in degrees from North
 * @param   {Number} dist: Distance in km
 * @returns {LatLon} Destination point
 */
LatLon.prototype.rhumbDestinationPoint = function(brng, dist) {
  var R = this._radius;
  var d = parseFloat(dist)/R;  // d = angular distance covered on earth’s surface
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  brng = brng.toRad();

  var dLat = d*Math.cos(brng);
  // nasty kludge to overcome ill-conditioned results around parallels of latitude:
  if (Math.abs(dLat) < 1e-10) dLat = 0; // dLat < 1 mm
  
  var lat2 = lat1 + dLat;
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  var q = (isFinite(dLat/dPhi)) ? dLat/dPhi : Math.cos(lat1);  // E-W line gives dPhi=0
  var dLon = d*Math.sin(brng)/q;
  
  // check for some daft bugger going past the pole, normalise latitude if so
  if (Math.abs(lat2) > Math.PI/2) lat2 = lat2>0 ? Math.PI-lat2 : -Math.PI-lat2;
  
  lon2 = (lon1+dLon+3*Math.PI)%(2*Math.PI) - Math.PI;
 
  return new LatLon(lat2.toDeg(), lon2.toDeg());
}

/**
 * Returns the loxodromic midpoint (along a rhumb line) between this point and the supplied point.
 *   see http://mathforum.org/kb/message.jspa?messageID=148837
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {LatLon} Midpoint between this point and the supplied point
 */
LatLon.prototype.rhumbMidpointTo = function(point) {
  lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  lat2 = point._lat.toRad(), lon2 = point._lon.toRad();
  
  if (Math.abs(lon2-lon1) > Math.PI) lon1 += 2*Math.PI; // crossing anti-meridian
  
  var lat3 = (lat1+lat2)/2;
  var f1 = Math.tan(Math.PI/4 + lat1/2);
  var f2 = Math.tan(Math.PI/4 + lat2/2);
  var f3 = Math.tan(Math.PI/4 + lat3/2);
  var lon3 = ( (lon2-lon1)*Math.log(f3) + lon1*Math.log(f2) - lon2*Math.log(f1) ) / Math.log(f2/f1);
  
  if (!isFinite(lon3)) lon3 = (lon1+lon2)/2; // parallel of latitude
  
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/**
 * Returns the latitude of this point; signed numeric degrees if no format, otherwise format & dp 
 * as per Geo.toLat()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {Number|String} Numeric degrees if no format specified, otherwise deg/min/sec
 */
LatLon.prototype.lat = function(format, dp) {
  if (typeof format == 'undefined') return this._lat;
  
  return Geo.toLat(this._lat, format, dp);
}

/**
 * Returns the longitude of this point; signed numeric degrees if no format, otherwise format & dp 
 * as per Geo.toLon()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {Number|String} Numeric degrees if no format specified, otherwise deg/min/sec
 */
LatLon.prototype.lon = function(format, dp) {
  if (typeof format == 'undefined') return this._lon;
  
  return Geo.toLon(this._lon, format, dp);
}

/**
 * Returns a string representation of this point; format and dp as per lat()/lon()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {String} Comma-separated latitude/longitude
 */
LatLon.prototype.toString = function(format, dp) {
  if (typeof format == 'undefined') format = 'dms';
  
  return Geo.toLat(this._lat, format, dp) + ', ' + Geo.toLon(this._lon, format, dp);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

// ---- extend Number object with methods for converting degrees/radians

/** Converts numeric degrees to radians */
if (typeof Number.prototype.toRad == 'undefined') {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  }
}

/** Converts radians to numeric (signed) degrees */
if (typeof Number.prototype.toDeg == 'undefined') {
  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  }
}

/** 
 * Formats the significant digits of a number, using only fixed-point notation (no exponential)
 * 
 * @param   {Number} precision: Number of significant digits to appear in the returned string
 * @returns {String} A string representation of number which contains precision significant digits
 */
if (typeof Number.prototype.toPrecisionFixed == 'undefined') {
  Number.prototype.toPrecisionFixed = function(precision) {
    
    // use standard toPrecision method
    var n = this.toPrecision(precision);
    
    // ... but replace +ve exponential format with trailing zeros
    n = n.replace(/(.+)e\+(.+)/, function(n, sig, exp) {
      sig = sig.replace(/\./, '');       // remove decimal from significand
      l = sig.length - 1;
      while (exp-- > l) sig = sig + '0'; // append zeros from exponent
      return sig;
    });
    
    // ... and replace -ve exponential format with leading zeros
    n = n.replace(/(.+)e-(.+)/, function(n, sig, exp) {
      sig = sig.replace(/\./, '');       // remove decimal from significand
      while (exp-- > 1) sig = '0' + sig; // prepend zeros from exponent
      return '0.' + sig;
    });
    
    return n;
  }
}

/** Trims whitespace from string (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */
if (typeof String.prototype.trim == 'undefined') {
  String.prototype.trim = function() {
    return String(this).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

if (typeof module !== 'undefined' && module.exports) {
  module.exports = LatLon;
}function BDFFont () { this.init.apply(this, arguments) };
BDFFont.prototype = {
  init : function (bdf) {
    var self = this;
    self.glyphs = {};
    self.properties = {};
    self.parse(bdf);
  },

  parse : function (bdf) {
    var self = this;
    var lines = bdf.split(/\n/);

    var glyph = null, properties = null;
    for (var i = 0, len = lines.length; i < len; i++) {
      var line = lines[i];

      if (glyph) {
        if (line != 'ENDCHAR') {
          if (!glyph['BITMAP']) {
            var d = line.split(' ');
            switch (d[0]) {
              case 'ENCODING':
                glyph['ENCODING'] = +d[1];
                break;
              case 'SWIDTH':
                glyph['SWIDTH'] = {
                  x: +d[1],
                  y: +d[2]
                };
                break;
              case 'DWIDTH':
                glyph['DWIDTH'] = {
                  x: +d[1],
                  y: +d[2]
                };
                break;
              case 'BBX':
                glyph['BBw']  = +d[1];
                glyph['BBh']  = +d[2];
                glyph['BBox'] = +d[3];
                glyph['BBoy'] = +d[4];
                break;
              case 'ATTRIBUTES':
                break;
              case 'BITMAP':
                glyph['BITMAP'] = [];
                break;
            }
          } else {
            glyph['BITMAP'].bits = line.length * 4;
            glyph['BITMAP'].push(parseInt(line, 16));
          }
        } else {
          self.glyphs[glyph['ENCODING']] = glyph;
          glyph = null;
        }
      } else if (properties) {
        if (line != 'ENDPROPERTIES') {
          var d = line.split(' ', 2);
          properties[ d[0] ] = (d[1][0] == '"') ? d[1].substring(1, d[1].length - 2): +d[1];
        } else {
          self.properties = properties;
          properties = null;
        }
      } else {
        var d = line.split(' ');
        switch (d[0]) {
          case 'COMMENT': break;
          case 'FONT':
            self['FONT'] = d[1];
            break;
          case 'SIZE':
            self['SIZE'] = {
              size : +d[1],
              xres : +d[2],
              yres : +d[3]
            };
            break;
          case 'FONTBOUNDINGBOX':
            self['FONTBOUNDINGBOX'] = {
              w : +d[1],
              h : +d[2],
              x : +d[3],
              y : +d[4]
            };
            break;
          case 'STARTPROPERTIES':
            properties = {};
            break;
          case 'CHARS':
            self['CHARS'] = +d[1];
            break;
          case 'STARTCHAR':
            glyph = {};
          case 'ENDCHAR':
            break;
        }
      }
    }
  },

  drawChar : function (ctx, c, bx, by, t) {
    var self = this;
    var g = self.glyphs[ c ] || self.glyphs[ self.properties['DEFAULT_CHAR'] ];
    if (t) {
      var f = function () {};
      f.prototype = g;
      g = new f();
      g = t(g);
    };
    var n = g['BBw'];
    var b = g['BITMAP'];
    var ox = bx + g['BBox'] - 1;
    var oy = by - g['BBoy'] - g['BBh'] + 1;
    for (var y = 0, len = b.length; y < len; y++) {
      var l = b[y];
      for (var i = b.bits, x = 0; i >= 0; i--, x++) {
        if (l >> i & 0x01 == 1) {
          ctx.fillRect(ox + x, oy + y, 1, 1);
        }
      }
    }
    return { x: bx + g['DWIDTH'].x, y : by + g['DWIDTH'].y };
  },

  drawText : function (ctx, text, x, y, t) {
    var self = this;
    for (var i = 0, len = text.length; i < len; i++) {
      var c = text[i].charCodeAt(0);
      var r = self.drawChar(ctx, c, x, y, t);
      x = r.x; y = r.y;
    }
    return { x: x, y: y };
  },

  drawEdgeText : function (ctx, text, x, y, t) {
    var self = this;
    self.drawText(ctx, text, x, y, function (g) {
      var bitmap =  new Array(g['BITMAP'].length + 2);
      bitmap.bits = g['BITMAP'].bits + 2;
      for (var i = -1, len = bitmap.length; i < len; i++) {
        bitmap[i+1] = g['BITMAP'][i]   | g['BITMAP'][i]   >> 1 | g['BITMAP'][i]   >> 2 |
                      g['BITMAP'][i+1] | g['BITMAP'][i+1] >> 1 | g['BITMAP'][i+1] >> 2 |
                      g['BITMAP'][i-1] | g['BITMAP'][i-1] >> 1 | g['BITMAP'][i-1] >> 2 ;
      }
      g['BITMAP'] = bitmap;
      g['BBox']  += -3;
      g['BBoy']  +=  1;
      return g;
    });
  }
};function WeatherOverlay() {
  this._overlays = [];
  this._weatherMarks = [];
  this._weatherGrid = [];
  this._contourGrid = [];
  this._weatherLoading = false;
}

WeatherOverlay.prototype.refresh = function(r) {
  var weatherOverlay = this;
  this.fetch(r, function(data) {
    weatherOverlay._overlays.push(data);
  });
};

WeatherOverlay.prototype.fetch = function(r, callback) {
  var baseURL = 'http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi';
  var requestData = {
    'service': 'WMS',
    'request': 'GetMap',
    'version': '1.1.1',
    'format': 'PNG',
    'width': r.scope().width,
    'height': r.scope().height,
    'SRS': 'EPSG:4326',
    'bbox': (r.minLon() + ',' + r.minLat() + ',' + r.maxLon() + ',' + r.maxLat()),
    'layers': 'nexrad-n0q-conus'
  };
  $.get(baseURL, requestData, function(data) {
    callback(data);
  }, 'jsonp');
};

WeatherOverlay.prototype.render = function(r) {
  if (this._overlays.length > 0) {
    r.context().save();
    r.context().globalAlpha = .5;
    for (var row in this._contourGrid) {
      for (var col in this._contourGrid[row]) {
        var wx = this._contourGrid[row][col];
        if (wx.precip > 0) {
          var pos = r.gtoc(wx.lat, wx.lon);
          r.context().beginPath();
          r.context().moveTo(pos.x - 10, pos.y - 10);
          r.context().lineTo(pos.x + 10, pos.y - 10);
          r.context().lineTo(pos.x + 10, pos.y + 10);
          r.context().lineTo(pos.x - 10, pos.y + 10);
          if (wx.precip < 4)
            r.context().fillStyle = 'rgb(25, 50, 50)';
            //r.context().strokeStyle = 'rgb(' + wx.red + ', ' + wx.green + ', ' + wx.blue + ')';
          else
            r.context().fillStyle = 'rgb(70, 70, 35)';
          r.context().fill();
          r.context().fillStyle = '#fff';
          r.context().font = 'bold 14 px Arial';
          r.context().textAlign = 'center';
          r.context().textBaseline = 'middle';


          
          // Dots
          r.context().lineWidth = 1;
          r.context().strokeStyle = 'rgb(100, 100, 100)';
          var theta = wx.lat * wx.lon;
          if (wx.precip % 3 == 2) {
            r.context().beginPath();
            r.context().moveTo(pos.x, pos.y);
            r.context().lineTo(pos.x + 2 * Math.cos(theta), pos.y + 2 * Math.sin(theta));
            r.context().stroke();
          } else if (wx.precip % 3 == 0) {
            r.context().beginPath();
            r.context().moveTo(pos.x - 20 / 3, pos.y - 20 / 3);
            r.context().lineTo(pos.x - 20 / 3 + 2 * Math.cos(theta), pos.y - 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x + 20 / 3, pos.y - 20 / 3);
            r.context().lineTo(pos.x + 20 / 3 + 2 * Math.cos(theta), pos.y - 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x + 20 / 3, pos.y + 20 / 3);
            r.context().lineTo(pos.x + 20 / 3 + 2 * Math.cos(theta), pos.y + 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x - 20 / 3, pos.y + 20 / 3);
            r.context().lineTo(pos.x - 20 / 3 + 2 * Math.cos(theta), pos.y + 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();
          }

          
          //r.context().fillText(wx.precip, pos.x, pos.y);
        }
      }
    }
    r.context().restore();
  } else if (!this._weatherLoading) {
    this._weatherLoading = true;
    var weatherOverlay = this;
    $.get('wx/wx.php', {
      'bbox': ((r.minLon() - r.lonRange() * .1) + ',' + (r.minLat() - r.latRange() * .1) + ',' + (r.maxLon() + r.lonRange() * .1) + ',' + (r.maxLat() + r.latRange() * .1))
    }, function() {
      var img = new Image;
      img.src = 'wx/wx.gif';
      img.onload = function() {
        var imgData = {
          data: weatherOverlay.imageToData(img)
        };
        var analyzed = 0, marked = 0, loop = 0;

        var bottomLeft = new LatLon(r.minLat() - r.latRange() * .1, r.minLon() - r.lonRange() * .1);
        var topRight = new LatLon(r.maxLat() + r.latRange() * .1, r.maxLon() + r.lonRange() * .1);

        var geoHeight = bottomLeft.distanceTo(new LatLon(topRight._lat, bottomLeft._lon)) * 0.539957;
        var latIncrement = (topRight._lat - bottomLeft._lat) / geoHeight / 1;
        for (var latStep = 0; latStep < topRight._lat - bottomLeft._lat; latStep += latIncrement) {
          var precipGridRow = [];
          var contourGridRow = [];
          var geoWidth = new LatLon(bottomLeft._lat + latStep, bottomLeft._lon).distanceTo(new LatLon(bottomLeft._lat + latStep, topRight._lon)) * 0.539957;
          var lonIncrement = (topRight._lon - bottomLeft._lon) / geoWidth / 1;
          for (var lonStep = 0; lonStep < topRight._lon - bottomLeft._lon; lonStep += lonIncrement) {
            var x = Math.floor(lonStep / (topRight._lon - bottomLeft._lon) * 2048);
            var y = img.height - Math.floor(latStep / (topRight._lat - bottomLeft._lat) * 2048);
            var xRow = 2048 * 4 * y;
            var base = xRow + x * 4;
            var alpha = imgData.data[base + 3];
            //if (alpha == '255') {
              // RGB Color Data
              var red = imgData.data[base];
              var green = imgData.data[base + 1];
              var blue = imgData.data[base + 2];
              var precipLevel = 0;
              if (red < blue && green < blue && Math.abs(red - green) < 50)
                precipLevel = 1;
              else if (red < green && red < blue && Math.abs(green - blue) < 100)
                precipLevel = 2;
              else if (red < green && green > blue && Math.abs(red - blue) < 50)
                precipLevel = 3;
              else if (green > blue && Math.abs(red - green) < 50)
                precipLevel = 4;
              else if (red > blue && green > 50 && Math.abs(green - blue) > 50)
                precipLevel = 5;
              else if (red > blue && red > green && Math.abs(green - blue) < 50)
                precipLevel = 6;

              weatherOverlay._weatherMarks.push(bottomLeft._lat + latStep);
              weatherOverlay._weatherMarks.push(bottomLeft._lon + lonStep);
              weatherOverlay._weatherMarks.push(precipLevel);
              weatherOverlay._weatherMarks.push(red);
              weatherOverlay._weatherMarks.push(green);
              weatherOverlay._weatherMarks.push(blue);

              precipGridRow.push({
                precip: precipLevel,
                lat: bottomLeft._lat + latStep,
                lon: bottomLeft._lon + lonStep,
                red: red,
                green: green,
                blue: blue
              });

              contourGridRow.push({
                precip: precipLevel,
                lat: bottomLeft._lat + latStep,
                lon: bottomLeft._lon + lonStep,
                red: red,
                green: green,
                blue: blue
              });
            //}
          }
          weatherOverlay._weatherGrid.push(precipGridRow);
          weatherOverlay._contourGrid.push(contourGridRow);
        }


        // for (var row = 0; row < weatherOverlay._weatherGrid.length; row++) {
        //   for (var col = 0; col < weatherOverlay._weatherGrid[row].length; col++) {
        //     var anchor = weatherOverlay._weatherGrid[row][col];
        //     var delta = 0;
        //     for (var nrow = row - 1; nrow <= row + 1; nrow++) {
        //       for (var ncol = col - 1; ncol <= col + 1; ncol++) {
        //         var neighbor;
        //         if (nrow >= 0 && nrow < weatherOverlay._weatherGrid.length
        //           && ncol >= 0 && ncol < weatherOverlay._weatherGrid[nrow].length)
        //           neighbor = weatherOverlay._weatherGrid[nrow][ncol];
        //         else
        //           neighbor = {precip: 0};
        //         delta += Math.abs(neighbor.precip - anchor.precip);
        //       }
        //     }
        //     weatherOverlay._contourGrid[row][col].precip = delta;
        //   }
        // }

        // for (var row = 0; row < weatherOverlay._weatherGrid.length; row++) {
        //   for (var col = 0; col < weatherOverlay._weatherGrid[row].length; col++) {
        //     var anchor = weatherOverlay._weatherGrid[row][col];
        //     var delta = 0;
        //     for (var nrow = row - 1; nrow <= row + 1; nrow++) {
        //       for (var ncol = col - 1; ncol <= col + 1; ncol++) {
        //         if (nrow == row || ncol == col) {
        //           var neighbor;
        //           if (nrow >= 0 && nrow < weatherOverlay._weatherGrid.length
        //             && ncol >= 0 && ncol < weatherOverlay._weatherGrid[nrow].length) {
        //             neighbor = weatherOverlay._weatherGrid[nrow][ncol];
        //             if (nrow == row) {

        //             } else {

        //             }
        //           }
        //           else
        //             neighbor = {precip: 0};
        //           delta += Math.abs(neighbor.precip - anchor.precip);
        //         }
        //       }
        //     }
        //     weatherOverlay._contourGrid[row][col].precip = delta;
        //   }
        // }

        weatherOverlay._overlays.push(img);
      };
    });
  }
};

WeatherOverlay.prototype.weatherDataToSystems = function(data, r) {
  var imgData = weatherOverlay.imageToData(img);
  var analyzed = 0, marked = 0, loop = 0;

  var bottomLeft = new LatLon(r.minLat() - r.latRange() * .1, r.minLon() - r.lonRange() * .1);
  var topRight = new LatLon(r.maxLat() + r.latRange() * .1, r.maxLon() + r.lonRange() * .1);

  var geoHeight = bottomLeft.distanceTo(new LatLon(topRight._lat, bottomLeft._lon)) * 0.539957;
  var latIncrement = (topRight._lat - bottomLeft._lat) / geoHeight;
  for (var latStep = 0; latStep < topRight._lat - bottomLeft._lat; latStep += latIncrement) {
    var geoWidth = new LatLon(bottomLeft._lat + latStep, bottomLeft._lon).distanceTo(new LatLon(bottomLeft._lat + latStep, topRight._lon)) * 0.539957;
    var lonIncrement = (topRight._lon - bottomLeft._lon) / geoWidth;
    for (var lonStep = 0; lonStep < topRight._lon - bottomLeft._lon; lonStep += lonIncrement) {
      var x = Math.floor(lonStep / (topRight._lon - bottomLeft._lon) * 2048);
      var y = img.height - Math.floor(latStep / (topRight._lat - bottomLeft._lat) * 2048);
      var xRow = 2048 * 4 * y;
      var base = xRow + x * 4;
      var alpha = imgData.data[base + 3];
      if (alpha == '255') {
        weatherOverlay._weatherMarks.push(bottomLeft._lat + latStep);
        weatherOverlay._weatherMarks.push(bottomLeft._lon + lonStep);
        // RGB Color Data
        weatherOverlay._weatherMarks.push(imgData.data[base]);
        weatherOverlay._weatherMarks.push(imgData.data[base + 1]);
        weatherOverlay._weatherMarks.push(imgData.data[base + 2]);
      }
    }
  }
  weatherOverlay._overlays.push(img);
};

WeatherOverlay.prototype.imageToData = function(img) {
  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var context = canvas.getContext('2d');
  context.drawImage(img, 0, 0, img.width, img.height);
  var imgData = context.getImageData(0, 0, img.width, img.height);
  return imgData.data;
};var LatLon;
if (typeof module !== 'undefined' && module.exports) {
  LatLon = require('../latlon.js');
}

function Airport(icao, iata, lat, lon, elevation, magVar) {
  this._icao = icao;
  this._iata = iata;
	this._lat = lat;
	this._lon = lon;
	this._elevation = elevation;
  this._magVar = magVar;
	this._runways = {};
  this._metar = null;
  this._syncing = false;
}

Airport.SYNC_INTERVAL = 5 * 60 * 1000;

Airport.prototype.enterSync = function() {
  if (!this._syncing) {
    this._syncing = true;
    this.sync();
    setInterval(function() {
      this.sync();
    }.bind(this), Airport.SYNC_INTERVAL);
  }
};

Airport.prototype.sync = function() {
  $.get('/api/metars/' + this.icao(), function(metar) {
    if (metar)
      this._metar = metar;
  }.bind(this));
};

Airport.prototype.numRunways = function() {
  return this._runways.length / 2;
};

Airport.prototype.addRunway = function(runway) {
	this._runways[runway.id()] = runway;
};

Airport.prototype.runway = function(id) {
	return this._runways[id];
};

Airport.prototype.runways = function() {
  return this._runways;
};

Airport.prototype.runwayPairs = function() {
  var runwayIDs = {},
      runwayPairs = [];
  for (var id in this._runways) {
    if (!runwayIDs[id] && /^(\d{1,2})(L|C|R){0,1}$/.test(id)) {
      var pair = this.runwayPair(id);
      runwayIDs[pair[0].id()] = true;
      runwayIDs[pair[1].id()] = true;
      runwayPairs.push(pair);
    }
  }
  return runwayPairs;
};

Airport.prototype.runwayPair = function(id) {
  var runwayParts = id.match(/^(\d{1,2})(L|C|R){0,1}$/),
      letter = runwayParts[2],
      number = parseInt(runwayParts[1], 10),
      opposingLetter = '',
      opposingNumber = (number + 18) % 36;
  if (opposingNumber === 0)
    opposingNumber = 36;
  if (opposingNumber < 10)
    opposingNumber = '0' + opposingNumber;
  switch (letter) {
    case 'L':
      opposingLetter = 'R';
      break;
    case 'R':
      opposingLetter = 'L';
      break;
    case 'C':
      opposingLetter = 'C';
      break;
    default:
      opposingLetter = '';
  }
  var opposingID = opposingNumber + opposingLetter;
  return [this.runway(id), this.runway(opposingID)];
};

Airport.prototype.position = function() {
  return new LatLon(this._lat, this._lon);
};

Airport.prototype.icao = function() {
  return this._icao;
};

Airport.prototype.iata = function() {
  return this._iata;
};

Airport.prototype.lat = function() {
  return this._lat;
};

Airport.prototype.lon = function() {
  return this._lon;
};

Airport.prototype.elevation = function() {
  return this._elevation;
};

Airport.prototype.magVar = function() {
  return this._magVar;
};

Airport.prototype.metar = function() {
  this.enterSync();
  return this._metar;
};

Airport.prototype.altimeter = function() {
  return this.metar() ? this.metar().altimeter : '--.--';
};

Airport.prototype.windText = function(r) {
  return this.metar() ? r.pad(this.metar().wind.direction, 3) + '' + r.pad(this.metar().wind.speed, 2) : '';
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Airport;
}var LatLon;
if (typeof module !== 'undefined' && module.exports) {
	LatLon = require('../latlon.js');
}

function Runway(id, lat, lon, elevation, length, width, course, ILSCapable) {
	this._id = id;
	this._lat = lat;
	this._lon = lon;
	this._elevation = elevation;
	this._length = length;
	this._width = width;
	this._course = course;
	this._ILSCapable = ILSCapable || false;
}

Runway.prototype.enableILS = function() {
	this._ILSCapable = true;
};

Runway.prototype.disableILS = function() {
	this._ILSCapable = false;
};

Runway.prototype.hasILS = function() {
	return this._ILSCapable;
};

Runway.prototype.id = function() {
	return this._id;
};

Runway.prototype.position = function() {
  return new LatLon(this._lat, this._lon);
};

Runway.prototype.lat = function() {
	return this._lat;
};

Runway.prototype.lon = function() {
	return this._lon;
};

Runway.prototype.elevation = function() {
	return this._elevation;
};

Runway.prototype.length = function() {
	return this._length;
};

Runway.prototype.width = function() {
	return this._width;
};

Runway.prototype.course = function() {
	return this._course;
};

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Runway;
}var FacilitiesAPI,
    Airport,
    Runway,
    NODE = false;

if (typeof module !== 'undefined' && module.exports) {
  FacilitiesAPI = require('./server/FacilitiesAPI.js');
  Airport = require('./facilities/airport.js');
  Runway = require('./facilities/runway.js');
  NODE = true;
}

function FacilityManager() {
  this._airports = {};
  this._primaryAirport = '';
}

FacilityManager.prototype.setPrimaryAirport = function(icao) {
  this._primaryAirport = icao;
};

FacilityManager.prototype.primaryAirport = function(cb, cbOnlyIfAvailable) {
  if (this._primaryAirport)
    return this.airport(this._primaryAirport, cb, cbOnlyIfAvailable);
  cb(null);
};

FacilityManager.prototype.airports = function() {
  return this._airports;
};

FacilityManager.prototype.airport = function(icao, cb, cbOnlyIfAvailable) {
  var airport = this._airports[icao];
  if (airport)
    return cb(airport);
  var airportCallback = function(airport) {
    if (airport) {
      this._airports[airport.icao] = new Airport(
        airport.icao,
        airport.iata,
        airport.lat,
        airport.lon,
        airport.elevation,
        airport.magVar
      );
      for (var r in airport.runways) {
        var runway = airport.runways[r];
        this._airports[airport.icao].addRunway(new Runway(
          runway.id,
          runway.lat,
          runway.lon,
          runway.elevation,
          runway.length,
          runway.width,
          runway.course,
          runway.ILSCapable
        ));
      }
      return cbOnlyIfAvailable || cb(this._airports[airport.icao]);
    }
    cb(null);
  }.bind(this);
  if (NODE)
    FacilitiesAPI.airport(icao, airportCallback);
  else
    $.get('/api/airports/' + icao, airportCallback);
};

if (NODE) {
  module.exports = FacilityManager;
}function Compass() {
	this._display = true;
	this._brite = 5;
	this._notchLength = 12;
}

Compass.prototype.setBrite = function(brite) {
	this._brite = brite;
};

Compass.prototype.render = function(r) {
	if (this._display) {
		r.context().strokeStyle = r.brite(this._brite);
		r.context().lineWidth = 1;
		var radius = Math.sqrt(Math.pow(r.scope().width / 2, 2) + Math.pow(r.scope().height / 2, 2));
		// Draw each notch on the scope
		for (var i = 0; i < 360; i += 5) {
			var from = (i - 95) / 180 * Math.PI;
			var to = (i - 90) / 180 * Math.PI;
			r.context().beginPath();
			r.context().arc(r.scope().width / 2, r.scope().height / 2, radius, from, to);
			r.context().lineTo(r.scope().width / 2, r.scope().height / 2);
			r.context().stroke();
		}
		// Erase the middle of the scope to show only the notches
		r.context().beginPath();
		r.context().rect(this._notchLength, this._notchLength, r.scope().width - this._notchLength * 2, r.scope().height - this._notchLength * 2);
		r.context().fillStyle = r.background();
		r.context().fill();
		// Draw each heading label on the scope
		for (var i = 0; i < 360; i += 10) {
			var radiusX = 1 / Math.abs(Math.cos(i / 180 * Math.PI)) * (r.scope().height / 2 - (this._notchLength + 15));
			var radiusY = 1 / Math.abs(Math.sin(i / 180 * Math.PI)) * (r.scope().width / 2 - (this._notchLength + 15));
			var radius = radiusX < radiusY ? radiusX : radiusY;
			var angle = (i - 90) / 180 * Math.PI;
			var x = r.scope().width / 2 + Math.cos(angle) * radius;
			var y = r.scope().height / 2 + Math.sin(angle) * radius;
			r.context().beginPath();
			r.context().font = '10px Oxygen Mono';
			r.context().textAlign = 'center';
			r.context().textBaseline = 'middle';
			r.context().fillStyle = r.brite(this._brite);
			r.context().fillText(r.pad(i, 3, true), x, y);
		}
	}
};function Controller(position, beaconCode, identifier, name, frequency, socket) {
  this._position = position;
  this._targetCode = beaconCode;
  this._identifier = identifier;
  this._name = name;
  this._frequency = frequency;
  this._socket = socket;
}

Controller.fromJSON = function(data) {
  return new Controller(data.position, data.targetCode, data.identifier, data.name, data.frequency, null);
};

Controller.prototype.toJSON = function() {
  return {
    position: this.getPosition(),
    targetCode: this.getTargetCode(),
    identifier: this.getIdentifier(),
    name: this.getName(),
    frequency: this.getFrequency()
  };
};

Controller.prototype.getSocket = function() {
  return this._socket;
};

Controller.prototype.getPosition = function() {
  return this._position;
};

Controller.prototype.getTargetCode = function() {
  return this._targetCode;
};

Controller.prototype.getIdentifier = function() {
  return this._identifier;
};

Controller.prototype.getName = function() {
  return this._name;
};

Controller.prototype.getFrequency = function() {
  return this._frequency;
};

Controller.prototype.setTargetCode = function(targetCode) {
  this._targetCode = targetCode;
};

Controller.prototype.setIdentifier = function(identifier) {
  this._identifier = identifier;
};

Controller.prototype.setName = function(name) {
  this._name = name;
};

Controller.prototype.setFrequency = function(frequency) {
  this._frequency = frequency;
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Controller;
}function ConflictDetectionEngine() {
  this._conflictStates = {};
  this._conflicts = {};
  this._audibleConflicts = 0;
  this._alarmSounding = false;
  this._alarm = new Audio('../atc2/conflictalert.wav');
  this._separationMinima = [
    {
      anchor: null,
      radius: null,
      minAltitude: null,
      maxAltitude: 17999,
      lateral: 3,
      vertical: 1000
    },
    {
      anchor: null,
      radius: null,
      minAltitude: 18000,
      maxAltitude: null,
      lateral: 5,
      vertical: 1000
    }
  ];
  this._conflictState = {
    NONE: 1,
    ACTIVE: 2,
    MUTED: 3
  }
}

ConflictDetectionEngine.prototype.conflicts = function() {
  var identifiers = [];
  for (var id in this._conflictStates)
    if (this._conflictStates[id] != this._conflictState.NONE)
      identifiers.push(id);
  return identifiers;
};

ConflictDetectionEngine.prototype.manageAlarm = function() {
  if (this._audibleConflicts > 0) {
    if (!this._alarmSounding) {
      this._alarmSounding = true;
      this._alarm.loop = true;
      this._alarm.play();
    }
  } else if (this._alarmSounding) {
    this._alarmSounding = false;
    this._alarm.pause();
  }
};

ConflictDetectionEngine.prototype.singleTargetInConflict = function(target) {
  if (this._conflicts[target.callsign()])
    return true;
  else return false;
};

ConflictDetectionEngine.prototype.detect = function(targets) {
  var callsigns = Object.keys(targets);
  var numTarget = callsigns.length;
  for (var i = 0; i < numTarget; i++) {
    for (var j = i + 1; j < numTarget; j++) {
      var localTarget = targets[callsigns[i]];
      var foreignTarget = targets[callsigns[j]];
      if (this.inConflict(localTarget, foreignTarget))
        this.addConflict(localTarget, foreignTarget);
      else
        this.removeConflict(localTarget, foreignTarget);
    }
  }
};

ConflictDetectionEngine.prototype.addConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (!this._conflictStates[identifier] || this._conflictStates[identifier] == this._conflictState.NONE) {
    this._conflictStates[identifier] = this._conflictState.ACTIVE;
    if (!this._conflicts[localTarget.callsign()])
      this._conflicts[localTarget.callsign()] = 0;
    this._conflicts[localTarget.callsign()]++;
    if (!this._conflicts[foreignTarget.callsign()])
      this._conflicts[foreignTarget.callsign()] = 0;
    this._conflicts[foreignTarget.callsign()]++;
    this._audibleConflicts++;
  }
};

ConflictDetectionEngine.prototype.removeConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.ACTIVE) {
    this._conflictStates[identifier] = this._conflictState.NONE;
    this._conflicts[localTarget.callsign()]--;
    this._conflicts[foreignTarget.callsign()]--;
    this._audibleConflicts--;
  } else if (this._conflictStates[identifier] == this._conflictState.MUTED) {
    this._conflictStates[identifier] = this._conflictState.NONE;
    this._conflicts[localTarget.callsign()]--;
    this._conflicts[foreignTarget.callsign()]--;
  }
};

ConflictDetectionEngine.prototype.muteTarget = function(localTarget, targets) {
  if (this._audibleConflicts > 0)
    for (var i in targets)
      this.muteConflict(localTarget, targets[i]);
};

ConflictDetectionEngine.prototype.muteConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.ACTIVE) {
    this._conflictStates[identifier] = this._conflictState.MUTED;
    this._audibleConflicts--;
    this.manageAlarm();
  }
};

ConflictDetectionEngine.prototype.unmuteConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.MUTED) {
    this._conflictStates[identifier] = this._conflictState.ACTIVE;
    this._audibleConflicts++;
    this.manageAlarm();
  }
};

ConflictDetectionEngine.prototype.targetsToIdentifier = function(localTarget, foreignTarget) {
  var targets = [localTarget.callsign(), foreignTarget.callsign()];
  targets.sort();
  return targets.join('*');
};

ConflictDetectionEngine.prototype.classifyMinima = function(localTarget, foreignTarget) {
  var minima = {
    lateral: 0,
    vertical: 0
  };
  for (var i in this._separationMinima) {
    var m = this._separationMinima[i];
    if (
      (m.lateral > minima.lateral ||
        m.vertical > m.vertical) &&
      (!m.anchor ||
        m.anchor) &&
      (!m.minAltitude ||
        (localTarget.altitude() >= m.minAltitude ||
          foreignTarget.altitude() >= m.minAltitude)) &&
      (!m.maxAltitude ||
        (localTarget.altitude() <= m.maxAltitude ||
          foreignTarget.altitude() <= m.maxAltitude))
    ) {
      minima.lateral = Math.max(m.lateral, minima.lateral);
      minima.vertical = Math.max(m.vertical, minima.vertical);
    }
  }
  return minima;
};

ConflictDetectionEngine.prototype.inConflict = function(localTarget, foreignTarget) {
  var minima = this.classifyMinima(localTarget, foreignTarget);
    if (Math.abs(localTarget.altitude() - foreignTarget.altitude()) >= minima.vertical)
    return false;
  var localPosition = new LatLon(localTarget.lat(), localTarget.lon());
  var foreignTarget = new LatLon(foreignTarget.lat(), foreignTarget.lon());
   if (localPosition.distanceTo(foreignTarget) * 0.539957 >= minima.lateral)
    return false;
  return true;
};function CRDA(airport, masterRunwayID, slaveRunwayID) {
  this._airport = airport;
  this._master = airport.runway(masterRunwayID);
  this._slave = airport.runway(slaveRunwayID);

  if (!this._master || !this._slave)
    throw CRDA.ERROR.INVALID_RUNWAYS;

  this._enabled = true;
}

CRDA.ERROR = {
  INVALID_RUNWAYS: 1
};

CRDA.prototype.enable = function() {
  this._enabled = true;
};

CRDA.prototype.disable = function() {
  this._enabled = false;
};

CRDA.prototype.isEnabled = function() {
  return this._enabled;
};

CRDA.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

CRDA.prototype.ghostTargets = function(targetManager, r) {
  var targets = targetManager.getAllTargets();
  targets.forEach(function(target) {
    if (target.ghostState() !== Target.GHOST_STATES.INHIBITED)
      this.ghostTarget(target, r);
  }.bind(this));
};

CRDA.prototype.select = function(x, y, r) {
  var targets = scope.targetManager().getAllTargets();
  for (var i in targets) {
    var target = targets[i];
    if (this.shouldGhostTarget(target, r)) {
      var pos = this.ghostPosition(target, r);
      var coordinates = r.gtoc(pos._lat, pos._lon);
      var dx = coordinates.x - x;
      var dy = coordinates.y - y;
      var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
      if (distance < 15) {
        return target;
      }
    }
  }
  return null;
};

CRDA.prototype.ghostTarget = function(target, r) {
  if (this.shouldGhostTarget(target, r))
    this.renderGhost(target, this.ghostPosition(target, r), r);
};

CRDA.prototype.shouldGhostTarget = function(target, r) {
  return this._master && (target.ghostState() === Target.GHOST_STATES.FORCED || this.inMasterZone(target, r));
};

CRDA.prototype.ghostPosition = function(target, r) {
  var bearingOffset = 360 - this._master.course() + this._master.position().bearingTo(target.position());
  var distance = this._master.position().distanceTo(target.position());
  return this._slave.position().destinationPoint(this._slave.course() + bearingOffset, distance);
};

CRDA.prototype.renderGhost = function(target, position, r) {
  var acPos = r.gtoc(position._lat, position._lon);
  r.context().fillStyle = '#ff0';
  r.context().strokeStyle = '#ff0';
  // Render position
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'center';
  r.context().textBaseline = 'middle';
  r.context().fillText('0', acPos.x, acPos.y);
  // Draw the leader line
  r.context().beginPath();
  r.context().moveTo(acPos.x - 10, acPos.y);
  r.context().lineTo(acPos.x - 40, acPos.y);
  r.context().lineWidth = 1;
  r.context().stroke();
  // Draw the target altitude and speed data block
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'right';
  r.context().textBaseline = 'middle';
  var scopeSpeed = Math.floor(target.speed() / 10);
  var scopeAltitude = Math.floor(target.altitude() / 100);
  r.context().fillText(r.pad(scopeSpeed, 2), acPos.x - 45, acPos.y);
};

CRDA.prototype.setMaster = function(runway) {
  this._master = runway;
};

CRDA.prototype.setSlave = function(runway) {
  this._slave = runway;
};

CRDA.prototype.master = function() {
  return this._master;
};

CRDA.prototype.slave = function() {
  return this._slave;
};

CRDA.prototype.airport = function() {
  return this._airport;
};

CRDA.prototype.inMasterZone = function(target, r) {
  if (target.course() == -1)
    return false;
  var distanceInFeet = target.position().distanceTo(this._master.position()) * 3280.84;
  var radioAltitude = target.altitude() - this._master.elevation();
  var gsAltitude = Math.tan(3 * Math.PI / 180) * distanceInFeet;
  if (target.altitude() < gsAltitude + 1000 &&
      this.angleBetween(target.course(), this._master.course()) < 90 &&
      this.inMasterFunnel(target, r))
    return true;
  return false;
};

CRDA.prototype.angleBetween = function(primaryHeading, secondaryHeading) {
  var gap = Math.abs(primaryHeading - secondaryHeading);
  return Math.min(gap, 360 - gap);
};

CRDA.prototype.inMasterFunnel = function(target, r) {
  var bearingOffset = (360 - this._master.course() + this._master.position().bearingTo(target.position())) % 360;
  var distance = this._master.position().distanceTo(target.position()) * 0.539957;
  return 150 <= bearingOffset && bearingOffset <= 210 && distance <= 30;
};function CRDAManager() {
  this._CRDAs = [];
  this._CRDAIdentifiers = {};
  this._enabled = true;
}

CRDAManager.prototype.enable = function() {
  this._enabled = true;
};

CRDAManager.prototype.disable = function() {
  this._enabled = false;
};

CRDAManager.prototype.isEnabled = function() {
  return this._enabled;
};

CRDAManager.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

CRDAManager.prototype.toggleCRDA = function(num) {
  var crda = this._CRDAs[num - 1];
  if (crda)
    crda.toggle();
};

CRDAManager.prototype.select = function(e) {
  var offset = $(e.target).offset(),
      x = e.clientX - offset.left,
      y = e.clientY - offset.top,
      r = scope.renderer();
  if (this.isEnabled())
    for (var i in this._CRDAs) {
      var crda = this._CRDAs[i];
      if (crda.isEnabled()) {
        var target = crda.select(x, y, r);
        if (target)
          return target;
      }
    }
  return null;
};

CRDAManager.prototype.ghostTargets = function(targetManager, r) {
  for (var i in this._CRDAs) {
    var crda = this._CRDAs[i];
    if (crda.isEnabled())
      crda.ghostTargets(targetManager, r);
  }
};

CRDAManager.prototype.addRemoveCRDA = function(airport, masterRunwayID, slaveRunwayID) {
  var id = airport.icao() + masterRunwayID + slaveRunwayID;
  if (!this._CRDAIdentifiers[id]) {
    this._CRDAIdentifiers[id] = true;
    this._CRDAs.push(new CRDA(airport, masterRunwayID, slaveRunwayID));
  } else {
    for (var i in this._CRDAs) {
      var crda = this._CRDAs[i];
      if (crda.airport().icao() === airport.icao() &&
          crda.master().id() === masterRunwayID &&
          crda.slave().id() === slaveRunwayID) {
        delete this._CRDAIdentifiers[id];
        return this._CRDAs.splice(i, 1);
      }
    }
  }
};

CRDAManager.prototype.CRDAs = function() {
  return this._CRDAs;
};function Map(id, name, filename, r, callback) {
	this._id = id;
	this._name = name;
	this._path = [];
	this._brite = 5;
	this._enabled = true;

	if (typeof filename == 'string')
		this.loadFromFile(filename, r, callback);
}

Map.prototype.id = function() {
	return this._id;
};

Map.prototype.name = function() {
	return this._name;
};

Map.prototype.enabled = function() {
	return this._enabled;
};

Map.prototype.toggle = function() {
	this._enabled = !this._enabled;
};

Map.prototype.setBrite = function(brite) {
	this._brite = brite;
};

Map.prototype.loadFromFile = function(filename, r, callback) {
	var map = this;
	$.get(filename, function(data) {
		map.addMapPath(data.split('\n'), r);
		callback();
	});
};

Map.prototype.addMapPath = function(pathList, r) {
	// Loop through map file
	for (var line in pathList) {
		var lineData = pathList[line].trim().split(' ');
		if (lineData.length >= 4) {
			var subpath = [];
			// Loop through each coordinate in line
			subpath[0] = parseFloat(lineData[0]);
			if (!isNaN(subpath[0])) {
				for (var n = 1; n < 4; n++)
					subpath[n] = parseFloat(lineData[n]);
			} else {
				for (var i in lineData) {
					if (i < 4) {
						var lineDataParts = lineData[i].split('.');
						var p1 = parseInt(lineDataParts[0].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p2 = parseInt(lineDataParts[1].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p3 = parseInt(lineDataParts[2].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p4 = parseInt(lineDataParts[3].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						if (p1 < 0) {
							subpath[i] = -1 * (-1 * p1 + p2 / 60 + (parseFloat(p3 + '.' + p4)) / 3600);
						} else {
							subpath[i] = p1 + p2 / 60 + (parseFloat(p3 + '.' + p4)) / 3600;
						}
					}
				}
			}
			// Update the minimum and maximum coordinates
			r.setMinLat(Math.min(r.minLat(), subpath[0], subpath[2]));
			r.setMinLon(Math.min(r.minLon(), subpath[1], subpath[3]));
			r.setMaxLat(Math.max(r.maxLat(), subpath[0], subpath[2]));
			r.setMaxLon(Math.max(r.maxLon(), subpath[1], subpath[3]));
			// Add the line to the list of lines
			this._path[line] = subpath;
		}
	}
	// Calculate the midpoint of the rendered scope map	
	var scopeCorner = new LatLon(r.minLat(), r.minLon());
	var scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
	r.setMidLat(scopeMidpoint._lat);
	r.setMidLon(scopeMidpoint._lon);
};

Map.prototype.render = function(r) {
	if (this._enabled) {
		r.context().lineWidth = 1.5;
		r.context().strokeStyle = r.brite(this._brite);
		// Render each line
		for (var line in this._path) {
			var from = r.gtoc(this._path[line][0], this._path[line][1]);
			var to = r.gtoc(this._path[line][2], this._path[line][3]);
			// Draw a scaled line
			r.context().beginPath();
			r.context().moveTo(from.x, from.y);
			r.context().lineTo(to.x, to.y);
			r.context().stroke();
		}
	}
};function TextOverlay(scope) {
  this._scope = scope;
  this._previewMessage = '';
  this._preview = [''];
  this._formatError = false;
  this._previewLine = 6;
	this._clock = new Date();
  this._brite = 3;
	var textOverlay = this;
	setInterval(function() {
		textOverlay._clock = new Date();
	}, 1000);
}



TextOverlay.prototype.setPreviewAreaMessage = function(message) {
  this._previewMessage = message;
};

TextOverlay.prototype.clearPreviewAreaMessage = function() {
  this._previewMessage = '';
};

TextOverlay.prototype.lines = function() {
  return this._preview.length;
};

TextOverlay.prototype.formatError = function() {
  this._formatError = true;
};

TextOverlay.prototype.previewSegments = function() {
  return this._preview;
};

TextOverlay.prototype.targetSelect = function() {
  if (this._preview.length == 1) {
    var targets = this._scope._targetManager.getAllTargets(),
        target;
    for (var i in targets) {
      if (targets[i].callsign().lastIndexOf(this._preview[0]) + this._preview[0].length == targets[i].callsign().length) {
        if (target)
          return;
        else
          target = targets[i];
      }
    }
    if (target) {
      this._preview[0] = target.callsign();
      this.addPreviewChar(' ');
    }
  }
};

TextOverlay.prototype.processPreviewArea = function(aircraft, controller) {
  // if (this._preview.length == 3) {
  //   var aircraft = this._scope._trafficSimulator.getAircraftByCallsign(this._preview[0]);
  //   var command = this._preview[1];
  //   var parameter = this._preview[2];
  //   if (aircraft && !isNaN(parameter)) {
  //     switch (command) {
  //       case 'TL':
  //       case 'TR':
  //       case 'FH':
  //         if (0 <= parameter && parameter <= 360) {
  //           aircraft.assignHeading(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //       case 'CM':
  //       case 'DM':
  //         if (0 <= parameter && parameter <= 99999) {
  //           aircraft.assignAltitude(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //       case 'SPD':
  //       case 'SLOW':
  //         if (0 <= parameter && parameter <= 9999) {
  //           aircraft.assignSpeed(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //     }
  //   }
  // } else if (this._preview.length == 1) {
  //   var command = this._preview[0],
  //       coneCommand = /^\*P\d+$/,
  //       jRingCommand = /^\*J\d+$/;
  //   if (aircraft) {
  //     if (command == 'IC') {
  //       aircraft.setController(controller);
  //       this.clearPreview();
  //       return true;
  //     } else if (command == 'TC') {
  //       aircraft.setController(null);
  //       this.clearPreview();
  //       return true;
  //     } else if (coneCommand.test(command.substr(1))) {
  //       aircraft.enableCone(parseInt(command.substr(3)));
  //       this.clearPreview();
  //       return true;
  //     } else if (jRingCommand.test(command.substr(1))) {
  //       aircraft.enableJRing(parseInt(command.substr(3)));
  //       this.clearPreview();
  //       return true;
  //     }
  //   }
  // }
  // if (this._preview[0] == '')
  //   return false;
  // else {
  //   this._formatError = true;
  //   return true;
  // }
};

TextOverlay.prototype.clearPreview = function() {
  this._preview = [''];
  this._formatError = false;
  Keyboard.MODE = Keyboard.MODES.NONE;
};

TextOverlay.prototype.keepFirstLine = function() {
  this._preview = this._preview.slice(0, 1);
  this.addPreviewChar(' ');
};

TextOverlay.prototype.addPreviewChar = function(character) {
  if (character == ' ') {
    if (this._preview[this._preview.length - 1] != '')
      this._preview.push('');
  }
  else
    this._preview[this._preview.length - 1] += character;
  this._formatError = false;
};

TextOverlay.prototype.removePreviewChar = function() {
  if (this._preview[this._preview.length - 1].length == 0) {
    this._preview.splice(this._preview.length - 1);
    if (this._preview.length == 0)
      this.clearPreview();
  }
  else
    this._preview[this._preview.length - 1] =
      this._preview[this._preview.length - 1]
        .substr(0, this._preview[this._preview.length - 1].length - 1);
  this._formatError = false;
};

TextOverlay.prototype.brite = function(color) {
  if (color === 'red')
    return 'rgb(' + Math.round(255 * this._brite / 10) + ', 0, 0)';
  return 'rgb(0, ' + Math.round(255 * this._brite / 10) + ', 0)';
};

TextOverlay.prototype.line = function(r, top, line) {
  return r.scope().height * top + line * 20;
};

TextOverlay.prototype.renderPreviewArea = function(r) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = '#0c0';
  r.context().fillText(this._formatError ? 'FORMAT' : this._previewMessage, 75, this.line(r, .14, this._previewLine - 1));
  for (var i = 0; i < this._preview.length; i++)
    r.context().fillText(this._preview[i], 75, this.line(r, .14, this._previewLine + i));
};

TextOverlay.prototype.renderTime = function(r) {
	r.context().beginPath();
	r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
	r.context().textAlign = 'left';
	r.context().textBaseline = 'top';
	r.context().fillStyle = this.brite();
	var date = this._clock;
	var hours = '' + date.getUTCHours();
	var minutes = '' + date.getUTCMinutes();
	var seconds = '' + date.getUTCSeconds();
	var timeString = (hours.length == 1 ? '0' + hours : hours) +
    (minutes.length == 1 ? '0' + minutes : minutes) + '/' +
    (seconds.length == 1 ? '0' + seconds : seconds);
	r.context().fillText(timeString, 75, this.line(r, 0.14, 0));
  // scope.facilityManager().primaryAirport(function(airport) {
  //   if (airport)
  //     r.context().fillText(airport.altimeter(), 75 + r.context().measureText(timeString + ' ').width, this.line(r, 0.14, 0));
  // }.bind(this), true);
  r.context().fillStyle = this.brite('green');
	r.context().fillText('OK/OK/NA ', 75, this.line(r, 0.14, 1));
  r.context().fillStyle = this.brite();
  // scope.facilityManager().primaryAirport(function(airport) {
  //   if (airport)
  //     r.context().fillText(airport.iata(), 75 + r.context().measureText('OK/OK/NA ').width, this.line(r, 0.14, 1));
  // }.bind(this), true);
	r.context().fillText(r.range() + 'NM PTL: -.-', 75, this.line(r, 0.14, 2));
	r.context().fillText('N99 999 U N99 999 A', 75, this.line(r, 0.14, 3));
  var airports = scope.facilityManager().airports(),
      ICAOs = Object.keys(airports);
  ICAOs.forEach(function(icao, index) {
    var airport = airports[icao];
    r.context().fillText(airport.iata() + ' ' + airport.altimeter() + ' ' + airport.windText(r), 75, this.line(r, 0.14, 4 + index));
  }.bind(this));
  this._previewLine = 6 + ICAOs.length;
};

TextOverlay.prototype.renderControllers = function(r, controllers) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  var textLeft = r.scope().width - 200;
  controllers.forEach(function(controller, line) {
    r.context().fillText(controller.getIdentifier() + ' ' + controller.getName() , textLeft, this.line(r, 0.2, line));
  }.bind(this));
};

TextOverlay.prototype.renderLACAMCI = function(r) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  var textLeft = r.scope().width - 200;
  r.context().fillText('LA/CA/MCI', textLeft, this.line(r, 0.8, 0));
  scope.targetManager().conflicts().forEach(function(conflict, i) {
    r.context().fillText(conflict + ' CA', textLeft, this.line(r, 0.8, 1 + i));
  }.bind(this));
};

TextOverlay.prototype.renderTowerList = function(r, aircraft) {
	this._scope.facilityManager().primaryAirport(function(airport) {
    if (!airport)
      return;
    var aircraftList = aircraft.concat();
    var line = 0;
    aircraftList.sort(function(a, b) {
      return a.position().distanceTo(airport.position()) -
        b.position().distanceTo(airport.position());
    });
    r.context().beginPath();
    r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
    r.context().textAlign = 'left';
    r.context().textBaseline = 'top';
    r.context().fillStyle = this.brite();
    r.context().fillText(airport.iata() + ' TOWER', 75, this.line(r, 0.45, line++));
    if (aircraftList.length > 6)
      r.context().fillText('MORE: 6/' + aircraftList.length, 75, this.line(r, 0.45, line++));
    aircraftList.splice(6);
    for (var i = 0; i < aircraftList.length; i++) {
      var callsignString = aircraftList[i].callsign();
      for (var j = 0; j < 7 - aircraftList[i].callsign().length; j++)
        callsignString += ' ';
      r.context().fillText(callsignString + ' ' +
        aircraftList[i].type(), 75, this.line(r, 0.45, line + i));
    }
  }.bind(this), true);
};

TextOverlay.prototype.renderCRDAStatus = function(r, crdaManager) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  r.context().fillText('CRDA ' + (crdaManager.isEnabled() ? 'STATUS' : 'OFF'), 75, this.line(r, 0.8, 0));
  crdaManager.CRDAs().forEach(function(crda, index) {
    var line = index + 1,
        enabled = crdaManager.isEnabled() && crda.isEnabled() ? '*' : ' ';
    r.context().fillText(enabled + line + ' ' + crda.airport().iata() + ' ' +
      crda.master().id() + '/' + crda.slave().id(), 75, this.line(r, 0.8, line));
  }.bind(this));
};function PathManager() {
  this._paths = {};
  this._visiblePaths = [];
}

PathManager.ERROR = {
  PATH_NOT_FOUND: 1
};

PathManager.prototype.setPath = function(path) {
  this._paths[path.name()] = path;
};

PathManager.prototype.showPath = function(pathName) {
  if (pathName === 'ALL') {
    this._visiblePaths = Object.keys(this._paths);
    return;
  }
  for (var i in this._visiblePaths)
    if (this._visiblePaths[i] === pathName)
      return;
  if (this._paths[pathName])
    this._visiblePaths.push(pathName);
  else
    throw PathManager.ERROR.PATH_NOT_FOUND;
};

PathManager.prototype.hidePath = function(pathName) {
  if (pathName === 'ALL') {
    this._visiblePaths = [];
    return;
  }
  for (var i in this._visiblePaths)
    if (this._visiblePaths[i] === pathName) {
      this._visiblePaths.splice(i, 1);
      return;
    }
  throw PathManager.ERROR.PATH_NOT_FOUND;
};

PathManager.prototype.render = function(r) {
  for (var i in this._visiblePaths)
    new PathRenderer(this._paths[this._visiblePaths[i]]).render(r);
};function Path(name) {
  this._name = name;
  this._waypoints = [];
}

Path.prototype.addWaypoint = function(name, position) {
  this._waypoints.push({
    name: name,
    position: position
  });
};

Path.prototype.setName = function(name) {
  this._name = name;
};

Path.prototype.name = function() {
  return this._name;
};

Path.prototype.waypoints = function() {
  return this._waypoints;
};function Radar() {
  this._position;
}

Radar.prototype.setPosition = function(position) {
  this._position = position;
};

Radar.prototype.position = function() {
  return this._position;
};

Radar.prototype.sweep = function(feed, targetManager, renderFn) {
  var blips = [];//feed.blips();
  // socket.emit('radar.sweep', function(blips) {
  //   blips.forEach(function(blip) {
  //     this.sync(blip, targetManager);
  //   }.bind(this));
  //   targetManager.getAllTargets().forEach(function(target) {
  //     //this.revSync(target, feed, targetManager);
  //   }.bind(this));
  //   if (renderFn)
  //     renderFn();
  // }.bind(this));

  

  // var radials = [],
  //     currentRadial = 0;
  // for (var i = 0; i < 36; i++)
  //   radials[i] = [];
  // feed.blips().forEach(function(blip) {
  //   var radial = Math.floor(this.position().bearingTo(blip.position()) / 10);
  //     radials[radial].push(blip);
  // }.bind(this));
  // var syncNextRadial = function() {
  //   radials[currentRadial].forEach(function(blip) {
  //     this.sync(blip, targetManager);
  //     if (renderFn)
  //       renderFn();
  //   }.bind(this));
  //   currentRadial++;
  //   if (currentRadial < 36)
  //     setTimeout(syncNextRadial, 0);
  // }.bind(this);
  // syncNextRadial();
};

Radar.prototype.sync = function(blip, targetManager) {
  var target = targetManager.getTargetByCallsign(blip.callsign);
  if (target)
    target.updateFromBlip(blip);
  else {
    target = new Target();
    target.updateFromBlip(blip);
    targetManager.addTarget(target);
  }
};

Radar.prototype.revSync = function(target, feed, targetManager) {
  var blip = feed.getBlipByCallsign(target.callsign());
  if (!blip)
    targetManager.noRadarReturn(target.callsign());
};function Target(callsign) {
  this._callsign = callsign;

  this._mode;
  this._type;
  this._position;
  this._arrival;
  this._altitude;
  this._speed;
  this._squawk;
  this._controller = null;
  this._history = [];
  this._coneSize;
  this._jRingSize;

  this._isExpanded = false;
  this._isSelected = false;
  this._isInConflict = false;
  this._isDisplayingCone = false;
  this._isDisplayingJRing = false;
  this._isCoasting = false;
  this._isAwaitingPurge = false;
  this._ghostState = Target.GHOST_STATES.ENABLED;

  this._otherController = null;
  this._controlStates = {
    NORMAL: 1,
    OWNED: 2,
    INBOUND_HANDOFF: 3,
    HANDOFF: 4,
    POST_HANDOFF: 5
  };
  this._controlState = this._controlStates.NORMAL;
  this._handoffTimeout;

  this._radarReturnTimeout;

  this._modes = {
    OFF: 1,
    STANDBY: 2,
    ALTITUDE: 3,
    IDENT: 4
  };

  this._conflicts = {};
  this._conflictState = Target.CONFLICT_STATES.NONE;
}

Target.GHOST_STATES = {
  ENABLED: 1,
  FORCED: 2,
  INHIBITED: 3
};

Target.CONFLICT_STATES = {
  NONE: 1,
  CONFLICTING: 2,
  SUPPRESSED: 3,
  INHIBITED: 4
};

Target.prototype.toggleConflictAlerts = function() {
  this._conflictState = this._conflictState === Target.CONFLICT_STATES.INHIBITED ?
    Target.CONFLICT_STATES.NONE : Target.CONFLICT_STATES.INHIBITED;
};

Target.prototype.setTargetsInConflict = function(targets) {
  if (this._conflictState !== Target.CONFLICT_STATES.INHIBITED) {
    var conflicts = {};
    this._conflictState = Target.CONFLICT_STATES.NONE;
    targets.forEach(function(target) {
      var callsign = target.callsign();
      if (this._conflicts[callsign]) {
        conflicts[callsign] = this._conflicts[callsign];
        if (!conflicts[callsign]['isSuppressed'])
          this._conflictState = Target.CONFLICT_STATES.CONFLICTING;
        else if (this._conflictState !== Target.CONFLICT_STATES.CONFLICTING)
          this._conflictState = Target.CONFLICT_STATES.SUPPRESSED;
      } else {
        this._conflictState = Target.CONFLICT_STATES.CONFLICTING;
        conflicts[callsign] = {
          target: target,
          isSuppressed: false
        };
      }
    }.bind(this));
    this._conflicts = conflicts;
  } else
    this._conflicts = {};
  return this._conflictState;
};

Target.prototype.conflicts = function() {
  return this._conflicts;
};

Target.prototype.conflictState = function() {
  return this._conflictState;
};

Target.prototype.clearPostHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this.isOwned() ? this._controlStates.OWNED : this._controlStates.NORMAL;
  this.contract();
};

Target.prototype.handoff = function(toController) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = toController;
  this._controlState = this._controlStates.HANDOFF;
  this._handoffTimeout = setTimeout(function() {
    this._otherController = null;
    this._controlState = this._controlStates.OWNED;
  }.bind(this), 10 * 1000);
};

Target.prototype.acceptHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.OWNED;
  this.setController(scope.controller());
};

Target.prototype.handoffAccepted = function(byControler) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this.expand();
  this._controller = byControler;
  this._otherController = null;
  this._controlState = this._controlStates.POST_HANDOFF;
  if (scope.sounds())
    new Audio('/sounds/HandoffAccepted.wav').play();
  this._handoffTimeout = setTimeout(function() {
    this._controlState = this._controlStates.NORMAL;
    this.contract();
  }.bind(this), 10 * 1000);
};

Target.prototype.refuseHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.NORMAL;
  this.contract();
};

Target.prototype.handoffRefused = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.OWNED;
  if (scope.sounds())
    new Audio('/sounds/Error.wav').play();
};

Target.prototype.inboundHandoff = function(fromController) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = fromController;
  this._controlState = this._controlStates.INBOUND_HANDOFF;
  this.expand();
  if (scope.sounds())
    new Audio('/sounds/HandoffRequest.wav').play();
  this._handoffTimeout = setTimeout(function() {
    this._otherController = null;
    this._controlState = this._controlStates.NORMAL;
    this.contract();
  }.bind(this), 10 * 1000);
};

Target.prototype.assignHeading = function(heading) {
  if (0 <= heading && heading <= 360) {
    socket.emit('TS.heading', {
      callsign: this.callsign(),
      heading: heading
    });
    return true;
  }
  return false;
};

Target.prototype.assignAltitude = function(altitude) {
  if (0 <= altitude && altitude <= 99999) {
    socket.emit('TS.altitude', {
      callsign: this.callsign(),
      altitude: altitude
    });
    return true;
  }
  return false;
};

Target.prototype.assignSpeed = function(speed) {
  if (0 <= speed && speed <= 9999) {
    socket.emit('TS.speed', {
      callsign: this.callsign(),
      speed: speed
    });
    return true;
  }
  return false;
};

Target.prototype.otherController = function() {
  return this._otherController;
};

Target.prototype.updateFromBlip = function(blip) {
  this.update(blip.callsign, blip.mode, blip.type, blip.arrival, blip.position, blip.altitude, blip.speed, blip.squawk, blip.controller);
  if (this._radarReturnTimeout)
    clearTimeout(this._radarReturnTimeout);
  this._radarReturnTimeout = setTimeout(function() {
    this.noRadarReturn();
  }.bind(this), 6 * 1000);
};

Target.prototype.update = function(callsign, mode, type, arrival, position, altitude, speed, squawk, controller) {
  this.setCallsign(callsign);
  this.setMode(mode);
  this.setType(type);
  this.setArrival(arrival);
  this.setPosition(position);
  this.setAltitude(altitude);
  this.setSpeed(speed);
  this.setSquawk(squawk);

  var currentController = this.controller();
  if (!currentController || currentController.getIdentifier() !== controller)
    this.setController(scope.getControllerByIdentifier(controller));

  this.radarReturn();
};

Target.prototype.setCallsign = function(callsign) {
  this._callsign = callsign;
};

Target.prototype.setMode = function(mode) {
  this._mode = mode;
};

Target.prototype.setType = function(type) {
  this._type = type;
};

Target.prototype.setArrival = function(arrival) {
  this._arrival = arrival;
};

Target.prototype.setPosition = function(position) {
  position = new LatLon(position._lat, position._lon);
  this.addHistory(position);
  this._position = position;
};

Target.prototype.setAltitude = function(altitude) {
  this._altitude = altitude;
};

Target.prototype.setSpeed = function(speed) {
  this._speed = speed;
};

Target.prototype.setSquawk = function(squawk) {
  this._squawk = squawk;
};

Target.prototype.setController = function(controller) {
  this._controller = controller;
  if (this._controlState !== this._controlStates.POST_HANDOFF) {
    if (this.isOwned())
      this.expand();
    else
      this.contract();
  }
};

Target.prototype.addHistory = function(position) {
  this._history.unshift(position);
  if (this._history.length > 6)
    this._history.length = 6;
};

Target.prototype.callsign = function() {
  return this._callsign;
};

Target.prototype.mode = function() {
  return this._mode;
};

Target.prototype.type = function() {
  return this._type;
};

Target.prototype.arrival = function() {
  return this._arrival;
};

Target.prototype.position = function() {
  return this._position;
};

Target.prototype.altitude = function() {
  return this._altitude;
};

Target.prototype.speed = function() {
  return this._speed;
};

Target.prototype.squawk = function() {
  return this._squawk;
};

Target.prototype.controller = function() {
  return this._controller;
};

Target.prototype.history = function() {
  return this._history.slice(1);
};

Target.prototype.course = function() {
  return this.history().length ? this.history()[0].bearingTo(this.position()) : -1;
};

Target.prototype.enableCone = function(size) {
  this.disableJRing();
  this._coneSize = size;
  this._isDisplayingCone = true;
};

Target.prototype.disableCone = function() {
  this._isDisplayingCone = false;
};

Target.prototype.isDisplayingCone = function() {
  return this._isDisplayingCone;
};

Target.prototype.enableJRing = function(size) {
  this.disableCone();
  this._jRingSize = size;
  this._isDisplayingJRing = true;
};

Target.prototype.disableJRing = function() {
  this._isDisplayingJRing = false;
};

Target.prototype.isDisplayingJRing = function() {
  return this._isDisplayingJRing;
};

Target.prototype.expand = function() {
  this._isExpanded = true;
};

Target.prototype.contract = function() {
  this._isExpanded = false;
};

Target.prototype.isExpanded = function() {
  return this._isExpanded;
};

Target.prototype.demoteGhosting = function() {
  switch (this._ghostState) {
    case Target.GHOST_STATES.ENABLED:
      this._ghostState = Target.GHOST_STATES.INHIBITED;
      break;
    case Target.GHOST_STATES.FORCED:
      this._ghostState = Target.GHOST_STATES.ENABLED;
      break;
  }
};

Target.prototype.promoteGhosting = function() {
  switch (this._ghostState) {
    case Target.GHOST_STATES.INHIBITED:
      this._ghostState = Target.GHOST_STATES.ENABLED;
      break;
    case Target.GHOST_STATES.ENABLED:
      this._ghostState = Target.GHOST_STATES.FORCED;
      break;
  }
};

Target.prototype.ghostState = function() {
  return this._ghostState;
};

Target.prototype.select = function() {
  this._isSelected = true;
  if (!this.isExpanded()) {
    this.expand();
    setTimeout(function() {
      if (!this.isOwned())
        this.contract();
    }.bind(this), 3000);
  }
  if (this._controlState === this._controlStates.POST_HANDOFF)
    this.clearPostHandoff();
  if (this._conflictState === Target.CONFLICT_STATES.CONFLICTING) {
    this._conflictState = Target.CONFLICT_STATES.SUPPRESSED;
    for (var i in this._conflicts) {
      this._conflicts[i].isSuppressed = true;
      this._conflicts[i].target.conflicts()[this.callsign()].isSuppressed = true;
    }
  }
};

Target.prototype.deselect = function() {
  this._isSelected = false;
};

Target.prototype.isSelected = function() {
  return this._isSelected;
};

Target.prototype.inConflict = function() {
  this._isInConflict = true;
};

Target.prototype.notInConflict = function() {
  this._isInConflict = false;
};

Target.prototype.isInConflict = function() {
  return this._isInConflict;
};

Target.prototype.coast = function() {
  this._isCoasting = true;
};

Target.prototype.uncoast = function() {
  this._isCoasting = false;
};

Target.prototype.isCoasting = function() {
  return this._isCoasting;
};

Target.prototype.radarReturn = function() {
  this.uncoast();
  this.cancelPurge();
};

Target.prototype.noRadarReturn = function() {
  if (this.controller() && !this.isCoasting()) {
    this.coast();
    var purgeTrack = setTimeout(function() {
      scope.targetManager().purgeTarget(this);
    }.bind(this), 30000);
  }
  if (!this.controller())
    return scope.targetManager().purgeTarget(this);
  if (this.isCoasting())
    this.coastPosition();
  this._radarReturnTimeout = setTimeout(function() {
    this.noRadarReturn();
  }.bind(this), 5 * 1000);
};

Target.prototype.coastPosition = function() {
  var history = this.history();
  if (history.length > 0) {
    var previousDistance = history[0].distanceTo(this.position());
    var newEstimatedPosition = this.position().destinationPoint(this.course(), previousDistance);
    this.setPosition(newEstimatedPosition);
  }
};

Target.prototype.awaitPurge = function() {
  this._isAwaitingPurge = true;
};

Target.prototype.cancelPurge = function() {
  this._isAwaitingPurge = false;
};

Target.prototype.isAwaitingPurge = function() {
  return this._isAwaitingPurge;
};

Target.prototype.isOwned = function() {
  return this.isControlled() && this.controller() === scope.controller();
};

Target.prototype.isControlled = function() {
  return this.controller() !== null;
};

Target.prototype.isUndergoingHandoff = function() {
  return this._controlState === this._controlStates.HANDOFF;
};

Target.prototype.isUndergoingInboundHandoff = function() {
  return this._controlState === this._controlStates.INBOUND_HANDOFF;
};function TargetManager() {
  this._targets = [];
  this._airlines = {};
  this._callsigns = {};

  this._conflicts = [];

  this._alarmSounding = false;
  this._alarm = new Audio('/sounds/ConflictAlert.wav');

  this._targetPurger = setInterval(this.purgeTargets.bind(this), 5 * 1000);
}

TargetManager.SEPARATION_MINIMA = [
  {
    anchor: null,
    radius: null,
    minAltitude: null,
    maxAltitude: 17999,
    lateral: 3,
    vertical: 1000
  },
  {
    anchor: null,
    radius: null,
    minAltitude: 18000,
    maxAltitude: null,
    lateral: 5,
    vertical: 1000
  }
];

TargetManager.prototype.select = function(x, y, r) {
  var targets = this.getAllTargets(),
      selectedTarget = null,
      i = 0;
  for (i; i < targets.length; i++) {
    targets[i].deselect();
    var coordinates = r.gtoc(targets[i].position()._lat, targets[i].position()._lon);
    var dx = coordinates.x - x;
    var dy = coordinates.y - y;
    var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    if (distance < 15) {
      selectedTarget = targets[i];
      selectedTarget.select();
      //this._cde.muteAircraft(selectedTarget, targets);
      break;
    }
  }
  for (i = i + 1; i < targets.length; i++)
    targets[i].deselect();
  return selectedTarget;
};

TargetManager.prototype.getAllTargets = function() {
  return this._targets;
};

TargetManager.prototype.getAllOwnedTargets = function() {
  return this.getAllTargets().filter(function(target) {
    return target.controller() !== null && target.controller() === scope.controller();
  });
};

TargetManager.prototype.getTargetsByController = function(controller) {
  var targetsByController = [];
  this._targets.forEach(function(target) {
    if (target.controller() === controller)
      targetsByController.push(target);
  });
  return targetsByController;
};

TargetManager.prototype.getTargetsByAirline = function(airline) {
  var targetsByAirline = [];
  this._targets.forEach(function(target) {
    if (target.callsign().substr(0, 3) === airline)
      targetsByAirline.push(target);
  });
  return targetsByAirline;
};

TargetManager.prototype.getOwnedTargetsByAirline = function(airline) {
  return this.getTargetsByAirline(airline).filter(function(target) {
    return target.controller() !== null && target.controller() === scope.controller();
  });
};

TargetManager.prototype.massHandoff = function(fromController, toController) {
  this.getTargetsByController(fromController).forEach(function(target) {
    target.setController(toController);
  });
};

TargetManager.prototype.getTargetByCallsign = function(callsign) {
  for (var i = 0; i < this._targets.length; i++) {
    if (this._targets[i].callsign() === callsign)
      return this._targets[i];
  }
  return null;
};

TargetManager.prototype.manageAlarm = function(alarmShouldSound) {
  if (alarmShouldSound && scope.sounds()) {
    if (!this._alarmSounding) {
      this._alarmSounding = true;
      this._alarm.loop = true;
      this._alarm.play();
    }
  } else if (this._alarmSounding) {
    this._alarmSounding = false;
    this._alarm.pause();
  }
};

TargetManager.prototype.classifyMinima = function(localTarget, foreignTarget) {
  var minima = {
    lateral: 0,
    vertical: 0
  };
  for (var i in TargetManager.SEPARATION_MINIMA) {
    var m = TargetManager.SEPARATION_MINIMA[i];
    if (
      (m.lateral > minima.lateral ||
        m.vertical > m.vertical) &&
      (!m.anchor ||
        m.anchor) &&
      (!m.minAltitude ||
        (localTarget.altitude() >= m.minAltitude ||
          foreignTarget.altitude() >= m.minAltitude)) &&
      (!m.maxAltitude ||
        (localTarget.altitude() <= m.maxAltitude ||
          foreignTarget.altitude() <= m.maxAltitude))
    ) {
      minima.lateral = Math.max(m.lateral, minima.lateral);
      minima.vertical = Math.max(m.vertical, minima.vertical);
    }
  }
  return minima;
};

TargetManager.prototype.isInConflict = function(localTarget, foreignTarget) {
  var minima = this.classifyMinima(localTarget, foreignTarget);
  if (Math.abs(localTarget.altitude() - foreignTarget.altitude()) >= minima.vertical)
    return false;
  if (localTarget.position().distanceTo(foreignTarget.position()) * 0.539957 >= minima.lateral)
    return false;
  return true;
};

TargetManager.prototype.detectConflicts = function() {
  var targets = this.getAllTargets(),
      conflicts = Array(targets.length),
      alarmShouldSound = false;
  this._conflicts = [];
  for (var i = 0; i < targets.length; i++) {
    var localTarget = targets[i];
    if (localTarget.conflictState() !== Target.CONFLICT_STATES.INHIBITED) {
      for (var j = i + 1; j < targets.length; j++) {
        var foreignTarget = targets[j];
        if (foreignTarget.conflictState() !== Target.CONFLICT_STATES.INHIBITED) {
          if (this.isInConflict(localTarget, foreignTarget)) {
            if (localTarget.callsign() < foreignTarget.callsign())
              this._conflicts.push(localTarget.callsign() + '*' + foreignTarget.callsign());
            else
              this._conflicts.push(foreignTarget.callsign() + '*' + localTarget.callsign());
            if (conflicts[i])
              conflicts[i].push(foreignTarget);
            else
              conflicts[i] = [foreignTarget];
            if (conflicts[j])
              conflicts[j].push(localTarget);
            else
              conflicts[j] = [localTarget];
          }
        }
      }
    }
  }
  this._conflicts.sort();
  targets.forEach(function(target, index) {
    if (!conflicts[index])
      conflicts[index] = [];
    if (target.setTargetsInConflict(conflicts[index]) ===
        Target.CONFLICT_STATES.CONFLICTING)
      alarmShouldSound = true;
  });
  this.manageAlarm(alarmShouldSound);
};

TargetManager.prototype.conflicts = function() {
  return this._conflicts;
};

TargetManager.prototype.purgeTarget = function(target) {
  for (var i = 0; i < this._targets.length; i++) {
    var t = this._targets[i];
    if (t === target) {
      this._targets.splice(i, 1);
      return;
    }
  }
};

TargetManager.prototype.purgeTargets = function() {
  var purged = false;
  for (var i = 0; i < this._targets.length; i++) {
    var target = this._targets[i];
    if (target.isAwaitingPurge()) {
      purged = true;
      this._targets.splice(i, 1);
      i--;
    }
  }
  if (purged)
    this.updateCallsigns();
};

TargetManager.prototype.noRadarReturn = function(callsign) {
  for (var i = 0; i < this._targets.length; i++) {
    var target = this._targets[i];
    if (target.callsign() === callsign) {
      target.noRadarReturn();
      if (target.isAwaitingPurge())
        this._targets.splice(i, 1);
      return;
    }
  }
};

TargetManager.prototype.addTarget = function(target) {
  this._targets.push(target);
  this.updateCallsigns();
};

TargetManager.prototype.reset = function() {
  this._targets = [];
  this.updateCallsigns();
};

TargetManager.prototype.updateCallsigns = _.throttle(function() {
  var airlines = {};
  this._targets.forEach(function(target) {
    airlines[target.callsign().substr(0, 3)] = true;
  });
  $.get('https://localhost:8080/api/callsigns', {
    airlines: Object.keys(airlines)
  }, function(callsigns) {
    var airlines = {};
    for (var i in callsigns)
      airlines[callsigns[i].toUpperCase()] = i.toUpperCase();
    this._airlines = airlines;
    this._callsigns = callsigns;
  }.bind(this));
}, 1000, {
  leading: false
});

TargetManager.prototype.callsigns = function() {
  return Object.keys(this._airlines);
};

TargetManager.prototype.getAirlineByCallsign = function(callsign) {
  return this._airlines[callsign];
};

TargetManager.prototype.getCallsignByAirline = function(airline) {
  return this._callsigns[airline];
};

TargetManager.prototype.render = function(r) {
  var elapsedRenderer = r.elapsed(),
      targets = this.getAllTargets(),
      targetsInRange = [];
  this.detectConflicts();
  for (var a in targets)
    if (r.inBounds(targets[a].position()._lat, targets[a].position()._lon))
      targetsInRange.push(new TargetRenderer(targets[a]));
  for (var b in targetsInRange)
    targetsInRange[b].renderHistory(r);
  for (var c in targetsInRange)
    targetsInRange[c].renderExtras(r);
  for (var d in targetsInRange)
    targetsInRange[d].renderTarget(r);
  for (var e in targetsInRange)
    targetsInRange[e].renderPosition(r, elapsedRenderer);
  for (var f in targetsInRange)
    targetsInRange[f].renderDataBlock(r, elapsedRenderer);
};function Scope(socket) {
	this._socket = socket;
	this._maps = {};
	this._airports = {};
	// this._trafficSimulator = new TrafficSimulator;
	this._targetManager = new TargetManager();
	this._facilityManager = new FacilityManager();
	//this._mapManager = new MapManager(this);
	this._controller = null;
  this._controllers = [];
	//this._feed = new Feed;
	this._radar = new Radar();

	//this._situation = new Situation;
	this._renderer = new Renderer();
	this._compass = new Compass();
	this._textOverlay = new TextOverlay(this);
	this._flow = new Flow();
	this._pathManager = new PathManager();

	this._radarManager = null;
	this._isOn = false;

  this._CRDAManager = new CRDAManager();
  this._sounds = true;

	this._measureDistanceStartPosition = null;
	this._renderPoints = [];
	//this._renderPaths = [];
	this._renderPointsBlinker = new Date().getTime();
	//this._weatherOverlay = new WeatherOverlay;

	/*var self = this;
	setTimeout(function() {
		self._weatherOverlay.refresh(self._renderer);
	}, 5000);*/
}

// Situation.prototype.detectAndRenderConflicts = function() {
// 	if (this._conflictsEnabled) {
// 		this._cde.detect(this._aircraft);
// 		for (var i in this._aircraft)
// 			this._aircraft[i].setConflicting(this._cde.singleAircraftInConflict(this._aircraft[i]));
// 		this._cde.manageAlarm();
// 	}
// };

Scope.prototype.radar = function() {
  return this._radar;
};

Scope.prototype.setControllers = function(controllers) {
  controllers.sort(function(a, b) {
    if (a.getIdentifier() < b.getIdentifier())
      return -1;
    else
      return 1;
  }.bind(this));
  if (this._controller) {
    this._controllers = [this._controller];
    controllers.forEach(function(controller) {
      if (controller.getIdentifier() !== this._controller.getIdentifier())
        this._controllers.push(controller);
    }.bind(this));
  } else
    this._controllers = controllers;
};

Scope.prototype.getControllerByIdentifier = function(identifier) {
  for (var i in this._controllers)
    if (this._controllers[i].getIdentifier() === identifier)
      return this._controllers[i];
  return null;
};

Scope.prototype.controllers = function() {
  return this._controllers;
};

Scope.prototype.setControllerPosition = function(position, cb) {
  if (!this._controller) {
    this._socket.emit('ATC.addController', {
      position: position
    }, function(data) {
      this.setController(new Controller(data.position, data.targetCode, data.identifier, data.name, '199.98', null));
      if (cb)
        cb();
    }.bind(this));
  } else {
    this._socket.emit('ATC.deleteController', function() {
      this._targetManager.massHandoff(this._controller, null);
      this.setController(null);
      this.setControllerPosition(position, cb);
    }.bind(this));
  }
};

Scope.prototype.sounds = function() {
  return this._sounds;
};

Scope.prototype.setController = function(controller) {
	this._controller = controller;
};

Scope.prototype.controller = function() {
  return this._controller;
};

Scope.prototype.facilityManager = function() {
	return this._facilityManager;
};

Scope.prototype.CRDAManager = function() {
	return this._CRDAManager;
};

Scope.prototype.turnOn = function() {
	if (!this._isOn) {
		this._isOn = true;

		var batchRender = _.throttle(this.render.bind(this), 200);
		socket.on('blip', function(blip) {
			this._radar.sync(blip, this._targetManager);
			batchRender();
    }.bind(this));

		// this._radarManager = setInterval(function() {
		// 	this._radar.sweep(this._trafficSimulator, this._targetManager, this.render.bind(this));
		// }.bind(this), 5000);
		// this._radar.sweep(this._trafficSimulator, this._targetManager, this.render.bind(this));
	}
};

Scope.prototype.turnOff = function() {
	if (this._isOn) {
		this._isOn = false;
		clearInterval(this._radarManager);
		this._targetManager.reset();
	}
};

Scope.prototype.targetManager = function() {
	return this._targetManager;
};

Scope.prototype.pathManager = function() {
	return this._pathManager;
};

Scope.prototype.select = function(e) {
	var offset = $(e.target).offset(),
			x = e.clientX - offset.left,
			y = e.clientY - offset.top;
	return this._targetManager.select(x, y, this._renderer);
};

Scope.prototype.selectPosition = function(e) {
	var offset = $(e.target).offset(),
			x = e.clientX - offset.left,
			y = e.clientY - offset.top,
			target = this._targetManager.select(x, y, this._renderer);
	if (target)
		return target.position();
	else {
		var position = this._renderer.ctop(x, y);
		return position;
	}
};

Scope.prototype.measureHeadingAndDistance = function(e) {
	if (this._measureDistanceStartPosition) {
		var endPosition = this.selectPosition(e),
				heading = Math.round(this._measureDistanceStartPosition.bearingTo(endPosition) - this._renderer.magVar()) % 360,
				distance = this._measureDistanceStartPosition.distanceTo(endPosition) * 0.539957;
		this._measureDistanceStartPosition = null;
		return {
			heading: this._renderer.pad(heading, 3, true),
			distance: distance.toFixed(2)
		};
	} else {
		this._measureDistanceStartPosition = this.selectPosition(e);
		return null;
	}
};

Scope.prototype.addRenderPoint = function(position) {
	this._renderPoints.push(position);
};

Scope.prototype.clearRenderPoints = function() {
	this._renderPoints = [];
};

Scope.prototype.addRenderPath = function(path) {
	this._renderPaths.push(path);
};

Scope.prototype.clearRenderPaths = function() {
	this._renderPaths = [];
};

Scope.prototype.bind = function(scope) {
	this._renderer.bind(scope);
};

Scope.prototype.addAirport = function(airport) {
  this._airports[airport.icao()] = airport;
};

Scope.prototype.airport = function(icao) {
  return this._airports[icao];
};

Scope.prototype.addMap = function(id, name, map, callback) {
	this._maps[id] = new Map(id, name, map, this._renderer, callback);
};

Scope.prototype.enableSmartMap = function() {
	this._maps['SMART'] = new SmartMap('SMART', '', this);
};

Scope.prototype.setSituation = function(situation) {
	//this._situation = typeof situation == 'string' ? new Situation(situation) : situation;
};

Scope.prototype.maps = function() {
	return this._maps;
};

Scope.prototype.map = function(id) {
	return this._maps[id];
};

Scope.prototype.situation = function() {
	//return this._situation;
};

Scope.prototype.renderer = function() {
	return this._renderer;
};

Scope.prototype.compass = function() {
	return this._compass;
};

Scope.prototype.textOverlay = function() {
	return this._textOverlay;
};

Scope.prototype.fit = function() {
	this._renderer.scope().width = $(window).width() - ($('.situation-controls').is(':visible') ? 250 : 0);
	this._renderer.scope().height = $(window).height() - ($('.scope-settings').is(':visible') ? 54 : 0);
};

Scope.prototype.renderBackground = function() {
	this._renderer.context().fillStyle = this._renderer.background();
	this._renderer.context().strokeStyle = this._renderer.brite(this._compass._brite);
	this._renderer.context().lineWidth = 1;
	this._renderer.context().fillRect(0, 0, this._renderer.scope().width, this._renderer.scope().height);
	this._renderer.context().strokeRect(0, 0, this._renderer.scope().width, this._renderer.scope().height);
};

Scope.prototype.renderRangeRings = function() {
	this._renderer.context().moveTo();
};

Scope.prototype.renderOverlays = function() {
	this._textOverlay.renderTime(this._renderer, this._airports);
	this._textOverlay.renderTowerList(this._renderer, this.targetManager().getAllTargets());
	this._textOverlay.renderLACAMCI(this._renderer);
	this._textOverlay.renderCRDAStatus(this._renderer, this.CRDAManager());
	this._textOverlay.renderPreviewArea(this._renderer);
  this._textOverlay.renderControllers(this._renderer, this._controllers);
};

Scope.prototype.renderRenderPoints = function() {
	if (this._renderPoints.length) {
		var color = (new Date().getTime() - this._renderPointsBlinker) % 1000 < 667 ? '#0c0' : '#060';
		for (var i in this._renderPoints) {
			var pos = this._renderer.gtoc(this._renderPoints[i]._lat, this._renderPoints[i]._lon);
			this._renderer.context().beginPath();
			this._renderer.context().moveTo(pos.x - 3, pos.y - 3);
			this._renderer.context().lineTo(pos.x + 3, pos.y - 3);
			this._renderer.context().lineTo(pos.x + 3, pos.y + 3);
			this._renderer.context().lineTo(pos.x - 3, pos.y + 3);
			this._renderer.context().fillStyle = color;
			this._renderer.context().fill();
		}
	}
};

Scope.prototype.render = function() {
	this.fit();
	this.renderBackground();
	this._compass.render(this._renderer);
	for (var i in this._maps)
		this._maps[i].render(this._renderer);
	this._flow.render(this._renderer);
	this._pathManager.render(this._renderer);
	//this._weatherOverlay.render(this._renderer);
	//this._situation.render(this._renderer);
	//this.detectAndRenderConflicts();
	this.renderRenderPoints();
  this.renderOverlays();
  if (this._CRDAManager.isEnabled())
    this._CRDAManager.ghostTargets(this._targetManager, this._renderer);
	this._targetManager.render(this._renderer);
};
function SmartMap(id, name, scope) {
  this._id = id;
  this._name = name;
  this._scope = scope;
  this._brite = 5;
  this._enabled = false;
  this._primaryAirport = null;
  this._paths = [];
  this._pathsByType = {
    RUNWAY: [],
    LOCALIZER: [],
    COASTLINE: [],
    FIX: [],
    NAVAID: []
  };
  this._yields = {
    RUNWAY: [],
    LOCALIZER: [],
    NAVAID: [],
    FIX: [],
    COASTLINE: [
      'RUNWAY',
      'LOCALIZER'
    ]
  };
  this.configure();
}

SmartMap.prototype.id = function() {
  return this._id;
};

SmartMap.prototype.name = function() {
  return this._name;
};

SmartMap.prototype.enabled = function() {
  return this._enabled;
};

SmartMap.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

SmartMap.prototype.setBrite = function(brite) {
  this._brite = brite;
};

SmartMap.prototype.configure = function() {
  this._scope.facilityManager().primaryAirport(function(airport) {
    this._scope.renderer().setMagVar(airport.magVar());
    this._primaryAirport = airport;
    this.generatePrimaryAirport();
    this.generateCoastline();
    //this.generateFixes();
    this.generateNavaids();
    this._enabled = true;
  }.bind(this));
};

SmartMap.prototype.generatePrimaryAirport = function() {
  this.generateRunwayPairs(this._primaryAirport);
  this.generateLocalizers(this._primaryAirport);
};

SmartMap.prototype.generateRunwayPairs = function(airport) {
  var runwayPairs = airport.runwayPairs();
  for (var i in runwayPairs)
    this.generateRunwayPair(runwayPairs[i]);
};

SmartMap.prototype.generateRunwayPair = function(runwayPair) {
  this.layer([runwayPair[0].position(), runwayPair[1].position()], 'RUNWAY');
};

SmartMap.prototype.generateLocalizers = function(airport) {
  var runways = airport.runways();
  for (var i in runways) {
    var runway = runways[i];
    if (runway.hasILS())
      this.generateLocalizer(runway);
  }
};

SmartMap.prototype.generateLocalizer = function(runway) {
  var position = runway.position(),
      course = (runway.course() + 180) % 360;
  for (var i = 1; i < 25; i +=2) {
    var start = position.destinationPoint(course, i * 1.852),
        end = position.destinationPoint(course, (i + 1) * 1.852);
    this.layer([start, end], 'LOCALIZER');
  }
  for (var d = 5; d <= 15; d += 5) {
    var tickBase = position.destinationPoint(course, d * 1.852),
        tickStart = tickBase.destinationPoint(course - 90, 0.6 * 1.852),
        tickEnd = tickBase.destinationPoint(course + 90, 0.6 * 1.852);
    this.layer([tickStart, tickEnd], 'LOCALIZER');
  }
};

SmartMap.prototype.generateCoastline = function() {
  $.get('/api/coastline', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(paths) {
    for (var i in paths) {
      var path = paths[i];
      this.layer([new LatLon(path[0], path[1]), new LatLon(path[2], path[3])], 'COASTLINE');
    }
  }.bind(this));
};

SmartMap.prototype.generateFixes = function() {
  $.get('/api/fixes', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(fixes) {
    for (var i in fixes) {
      var fix = fixes[i],
          fixPos = new LatLon(fix.lat, fix.lon);
      this.layer([fixPos, fixPos.destinationPoint(Math.random() * 360, 1)], 'FIX');
    }
  }.bind(this));
};

SmartMap.prototype.generateNavaids = function() {
  $.get('/api/navaids', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(navaids) {
    for (var i in navaids) {
      var navaid = navaids[i],
          navaidPos = new LatLon(navaid.lat, navaid.lon);

      var pts = [];
      for (var p = 0; p < 12; p++)
        pts.push(navaidPos.destinationPoint(p * 30, 0.7));
      pts.push(pts[0]);
      this.layer(pts, 'NAVAID');
    }
  }.bind(this));
};

SmartMap.prototype.layer = function(path, type) {
  var r = this._scope.renderer(),
      yields = this._yields[type];
  for (var i in yields) {
    var yieldPaths = this._pathsByType[yields[i]];
    for (var j in yieldPaths) {
      var yieldPath = yieldPaths[j];
      for (var p in yieldPath) {
        var yieldPoint = yieldPath[p];
        for (var n in path) {
          var point = path[n];
          if (point.distanceTo(yieldPoint) * 0.539957 < 0.5)
            return;
        }
      }
    }
  }
  this._pathsByType[type].push(path);
  this._paths.push(path);
  r.setMinLat(Math.min(r.minLat(), path[0]._lat, path[1]._lat));
  r.setMinLon(Math.min(r.minLon(), path[0]._lon, path[1]._lon));
  r.setMaxLat(Math.max(r.maxLat(), path[0]._lat, path[1]._lat));
  r.setMaxLon(Math.max(r.maxLon(), path[0]._lon, path[1]._lon));
  var scopeCorner = new LatLon(r.minLat(), r.minLon()),
      scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
  r.setMidLat(scopeMidpoint._lat);
  r.setMidLon(scopeMidpoint._lon);
};

SmartMap.prototype.render = function(r) {
  if (this._enabled) {
    r.context().lineWidth = 1.5;
    r.context().strokeStyle = r.brite(this._brite);
    for (var i in this._paths) {
      var path = this._paths[i],
          startPoint = r.gtoc(path[0]._lat, path[0]._lon);
      r.context().beginPath();
      r.context().moveTo(startPoint.x, startPoint.y);
      for (var j = 1; j < path.length; j ++) {
        var nextPoint = r.gtoc(path[j]._lat, path[j]._lon);
        r.context().lineTo(nextPoint.x, nextPoint.y);
      }
      r.context().stroke();
    }
  }
};

// SmartMap.prototype.generateRunwayPair = function(runwayPair) {
//   this.addLine(this._scope.renderer(), 'runways', [runwayPair[0].position()._lat, runwayPair[0].position()._lon, runwayPair[1].position()._lat, runwayPair[1].position()._lon]);
//   for (var i = 0; i < 2; i++) {
//     if (runwayPair[i].hasILS()) {
//       var runwayPosition = runwayPair[i].position(),
//         backcourse = runwayPair[1 - i].position().bearingTo(runwayPosition);
//       this.generateLocalizer(runwayPosition, backcourse);
//     }
//   }
// };

// SmartMap.prototype.generateLocalizer = function(position, course) {
//   for (var i = 1; i < 25; i +=2) {
//     var start = position.destinationPoint(course, i * 1.852),
//         end = position.destinationPoint(course, (i + 1) * 1.852);
//     this._path.runways.push([start._lat, start._lon, end._lat, end._lon]);
//   }
//   for (var d = 5; d <= 15; d += 5) {
//     var tickBase = position.destinationPoint(course, d * 1.852),
//         tickStart = tickBase.destinationPoint(course - 90, 0.6 * 1.852),
//         tickEnd = tickBase.destinationPoint(course + 90, 0.6 * 1.852);
//     this.addLine(this._scope.renderer(), 'runways', [tickStart._lat, tickStart._lon, tickEnd._lat, tickEnd._lon]);
//   }
// };

// SmartMap.prototype.addLine = function(r, category, line) {
//   r.setMinLat(Math.min(r.minLat(), line[0], line[2]));
//   r.setMinLon(Math.min(r.minLon(), line[1], line[3]));
//   r.setMaxLat(Math.max(r.maxLat(), line[0], line[2]));
//   r.setMaxLon(Math.max(r.maxLon(), line[1], line[3]));
//   this._path[category].push(line);
// };

// SmartMap.prototype.update = function() {
//   if (!this._loadedPrimaryAirport) {
//     this._loadedPrimaryAirport = true;
//     this._scope.facilityManager().primaryAirport(function(airport) {
//       if (airport) {
//         var r = this._scope.renderer(),
//             runwayPairs = airport.runwayPairs();
//         r.setMagVar(airport.magVar());
//         for (var i in runwayPairs) {
//           var pair = runwayPairs[i];
//           this.generateRunwayPair(pair);
//         }
//         var scopeCorner = new LatLon(r.minLat(), r.minLon()),
//             scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
//         r.setMidLat(scopeMidpoint._lat);
// //         r.setMidLon(scopeMidpoint._lon);

//         $.get('/api/coastline', {
//           lat: airport.lat(),
//           lon: airport.lon(),
//           radius: 30
//         }, function(lines) {
//           if (lines.length) {
//             for (var i in lines) {
//               var line = lines[i];
//               var canDraw = true;
//               for (var p in this._path.runways) {
//                 var avoidLine = this._path.runways[p];
//                 for (var s = 0; s < 2; s++) {
//                   var point = new LatLon(avoidLine[2 * s], avoidLine[2 * s + 1]);
//                   if (point.distanceTo(new LatLon(line[0], line[1])) * 0.539957 < 0.5 || point.distanceTo(new LatLon(line[2], line[3])) * 0.539957 < 0.5) {
//                     canDraw = false;
//                     break;
//                   }
//                 }
//               }
//               if (canDraw) {
//                 this.addLine(r, 'coastline', line);
//               }
//             }
//             var scopeCorner = new LatLon(r.minLat(), r.minLon()),
//                 scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
//             r.setMidLat(scopeMidpoint._lat);
//             r.setMidLon(scopeMidpoint._lon);
//           }
//         }.bind(this));
//       }
//     }.bind(this));
// //   }
// // };

// // SmartMap.prototype.render = function(r) {
// //   if (this._enabled) {
// //     this.update();
// //     r.context().lineWidth = 1.5;

// //     r.context().strokeStyle = 'rgb(100, 100, 100)';
// //     // Render each line
// //     for (var line in this._path.coastline) {
// //       var from = r.gtoc(this._path.coastline[line][0], this._path.coastline[line][1]);
// //       var to = r.gtoc(this._path.coastline[line][2], this._path.coastline[line][3]);
// //       // Draw a scaled line
// //       r.context().beginPath();
// //       r.context().moveTo(from.x, from.y);
// //       r.context().lineTo(to.x, to.y);
// //       r.context().stroke();
// //     }

// //     r.context().strokeStyle = 'rgb(100, 100, 100)';
// //     // Render each line
// //     for (var line in this._path.runways) {
// //       var from = r.gtoc(this._path.runways[line][0], this._path.runways[line][1]);
// //       var to = r.gtoc(this._path.runways[line][2], this._path.runways[line][3]);
// //       // Draw a scaled line
// //       r.context().beginPath();
// //       r.context().moveTo(from.x, from.y);
// //       r.context().lineTo(to.x, to.y);
// //       r.context().stroke();
// //     }
// //   }
// // };
function Renderer() {
	this._created = new Date().getTime();
	this._targetHistory = true;
	this._last = this._created;
	this._scope;
	this._context;
	this._background = '#000';
	this._magVar = 0;
	this._minLat = 90;
	this._minLon = 180;
	this._midLat = 0;
	this._midLon = 0;
	this._maxLat = -90;
	this._maxLon = -180;
	this._globalScale = 1.0;
	this._radarCenter = {};
	this._translation = {
		lastMousePosition: {
			x: 0,
			y: 0,
		},
		offset: {
			x: 0,
			y: 0
		}
	};
	this._presets = [];
	this._mouseDown = false;
}

Renderer.prototype.bind = function(scope) {
	this._scope = $(scope)[0];
	this._context = this._scope.getContext('2d');
};

Renderer.prototype.scope = function() {
	return this._scope;
};

Renderer.prototype.context = function() {
	return this._context;
};

Renderer.prototype.inBounds = function(lat, lon) {
	var pos = this.gtoc(lat, lon);
	return pos.x >= 0 && pos.y >= 0 && pos.x <= this._scope.width && pos.y <= this._scope.height;
};

Renderer.prototype.elapsed = function() {
	return new Date().getTime() - this._created;
};

Renderer.prototype.enableTargetHistory = function() {
	this._targetHistory = true;
};

Renderer.prototype.disableTargetHistory = function() {
	this._targetHistory = false;
};

Renderer.prototype.targetHistory = function() {
	return this._targetHistory;
};

Renderer.prototype.setMinLat = function(minLat) {
	this._minLat = minLat;
};

Renderer.prototype.setMinLon = function(minLon) {
	this._minLon = minLon;
};

Renderer.prototype.setMidLat = function(midLat) {
	this._midLat = midLat;
};

Renderer.prototype.setMidLon = function(midLon) {
	this._midLon = midLon;
};

Renderer.prototype.setMaxLat = function(maxLat) {
	this._maxLat = maxLat;
};

Renderer.prototype.setMaxLon = function(maxLon) {
	this._maxLon = maxLon;
};

Renderer.prototype.minLat = function() {
	return this._minLat;
};

Renderer.prototype.minLon = function() {
	return this._minLon;
};

Renderer.prototype.midLat = function() {
	return this._midLat;
};

Renderer.prototype.midLon = function() {
	return this._midLon;
};

Renderer.prototype.maxLat = function() {
	return this._maxLat;
};

Renderer.prototype.maxLon = function() {
	return this._maxLon;
};

Renderer.prototype.scope = function() {
	return this._scope;
};

Renderer.prototype.context = function() {
	return this._context;
};

Renderer.prototype.background = function() {
	return this._background;
};

Renderer.prototype.radarCenter = function() {
	var lat, lon;
	if (this._radarCenter.lat) {
		lat = this._radarCenter.lat;
		lon = this._radarCenter.lon;
	} else {
		lat = this._midLat;
		lon = this._midLon;
	}
	return this.gtoc(lat, lon);
};

Renderer.prototype.radarCenterPosition = function() {
	var lat, lon;
	if (this._radarCenter.lat) {
		lat = this._radarCenter.lat;
		lon = this._radarCenter.lon;
	} else {
		lat = this._midLat;
		lon = this._midLon;
	}
	return new LatLon(lat, lon);
};

Renderer.prototype.setRadarCenter = function(position) {
	this._radarCenter = {
		lat: position._lat,
		lon: position._lon
	};
};

Renderer.prototype.magVar = function() {
	return this._magVar;
};

Renderer.prototype.setMagVar = function(magVar) {
	this._magVar = magVar;
};

Renderer.prototype.globalScale = function() {
	return this._globalScale;
};

Renderer.prototype.setGlobalScale = function(globalScale) {
	this._globalScale = globalScale;
};

Renderer.prototype.lastMousePosition = function() {
	return this._translation.lastMousePosition;
};

Renderer.prototype.setLastMousePosition = function(lastMousePosition) {
	this._translation.lastMousePosition = lastMousePosition;
};

Renderer.prototype.translationOffset = function() {
	return this._translation.offset;
};

Renderer.prototype.setTranslationOffset = function(translationOffset) {
	this._translation.offset = translationOffset;
};

Renderer.prototype.mouseDown = function() {
	return this._mouseDown;
};

Renderer.prototype.setMouseDown = function(mouseDown) {
	if (mouseDown && !this._mouseDown)
		this._dragging = false;
	this._mouseDown = mouseDown;
};

Renderer.prototype.dragging = function() {
	this._dragging = true;
};

Renderer.prototype.wasDragging = function() {
	return this._dragging;
};

Renderer.prototype.latRange = function() {
	return this._maxLat - this._minLat;
};

Renderer.prototype.lonRange = function() {
	return this._maxLon - this._minLon;
};

Renderer.prototype.scaledLatRange = function(lat) {
	return this.latRange() * (1 / Math.cos(lat / 180 * Math.PI));
};

Renderer.prototype.multiplier = function(lat) {
	return this._scope.height / this.scaledLatRange(lat);
};

Renderer.prototype.scaleX = function(lat, lon) {
	return this.gtoc(lat, lon).x;
};

Renderer.prototype.scaleY = function(lat, lon) {
	return this.gtoc(lat, lon).y;
};

Renderer.prototype.brite = function(brite) {
	return '#' + brite * 111;
};

Renderer.prototype.rotate = function(x, y, cx, cy, theta) {
	var rx = x - cx;
	var ry = y - cy;
	theta *= -1;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry));
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry));

	var mx = fx + cx;
	var my = fy + cy;

	return {
		x: mx,
		y: my
	};
};

Renderer.staticRotate = function(x, y, cx, cy, theta) {
	var rx = x - cx;
	var ry = y - cy;
	theta *= -1;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry));
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry));

	var mx = fx + cx;
	var my = fy + cy;

	return {
		x: mx,
		y: my
	};
};

Renderer.prototype.gtoc = function(lat, lon) {
	var multiplier = this.multiplier(lat);
	var tx = (multiplier * (lon - this._minLon)) + this._scope.width / 2 - (this.lonRange() * multiplier) / 2;
	var ty = this._scope.height - (multiplier * (1 / Math.cos(lat / 180 * Math.PI)) * (lat - this._minLat));

	var rx = tx - this._scope.width / 2;
	var ry = this._scope.height / 2 - ty;
	var theta = this._magVar / 180 * Math.PI;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry)) * this._globalScale + this._translation.offset.x * this._globalScale;
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry)) * this._globalScale + this._translation.offset.y * this._globalScale;

	var mx = fx + this._scope.width / 2;
	var my = this._scope.height / 2 - fy;

	return {
		x: mx,
		y: my
	};
};

Renderer.prototype.ctop = function(x, y) {
	var fy = this._scope.height / 2 - y;
	var fx = x - this._scope.width / 2;
	
	var bry = (fy - this._translation.offset.y * this._globalScale) / this._globalScale;
	var brx = (fx - this._translation.offset.x * this._globalScale) / this._globalScale;

	var theta = this._magVar / 180 * Math.PI;
	var ry = (Math.cos(theta) * bry - Math.sin(theta) * brx) /
		(Math.pow(Math.sin(theta), 2) + Math.pow(Math.cos(theta), 2));
	var rx = (bry - Math.cos(theta) * ry) / Math.sin(theta);

	var ty = this._scope.height / 2 - ry;
	var tx = rx + this._scope.width / 2;

	var lat = (this.latRange() * (this._scope.height - ty) + this._scope.height * this._minLat) / this._scope.height;
	var multiplier = this._scope.height * Math.cos(lat / 180 * Math.PI) / this.latRange();
	var lon = (2 * tx - this._scope.width + 2 * this._minLon * multiplier + this.lonRange() * multiplier) / (2 * multiplier);
	
	return new LatLon(lat, lon);
};

Renderer.prototype.distanceToPixels = function(position, course, distance) {
	var pos = this.gtoc(position._lat, position._lon),
			dest = position.destinationPoint(course, distance / 0.539957),
			nPos = this.gtoc(dest._lat, dest._lon);
	return Math.sqrt(Math.pow(nPos.x - pos.x, 2) + Math.pow(nPos.y - pos.y, 2));
};

Renderer.prototype.range = function() {
	var scale = this.distanceToPixels(new LatLon(this._midLat, this._midLon), 0, 1);
	return Math.round(this._scope.height / scale);
};

Renderer.prototype.setPreset = function(slot) {
	this._presets[slot] = {
		scale: this._globalScale,
		translation: {
			x: this._translation.offset.x,
			y: this._translation.offset.y
		}
	};
};

Renderer.prototype.selectPreset = function(slot) {
	var preset = this._presets[slot];
	if (preset) {
		this._globalScale = preset.scale;
		this._translation.offset = preset.translation;
	}
};

Renderer.prototype.scale = function(value) {
	return value / this._globalScale;
};

Renderer.prototype.adjustForMagVar = function() {
	this._context.translate(this._scope.width / 2, this._scope.height / 2);
	this._context.rotate(-this._magVar / 180 * Math.PI);
	this._context.translate(-this._scope.width / 2, -this._scope.height / 2);
};

Renderer.prototype.pad = function (string, length, heading) {
	s = string == 0 && heading ? 360 : string;
	var s = "00000" + s;
  	return s.substr(s.length - length);
};

Renderer.prototype.angleBetweenHeadings = function(primaryHeading, secondaryHeading) {
  var gap = Math.abs(primaryHeading - secondaryHeading);
  return Math.min(gap, 360 - gap);
};

Renderer.prototype.angleBetween = function(ax, ay, bx, by) {
	// y's are flipped because the positive direction in HTML canvas is down
	return Math.atan2((ay - by), (bx - ax));
};function TargetRenderer(target) {
  this._target = target;
}


/*****************/
/** CLASS LEVEL **/
/*****************/

TargetRenderer.DIRECTION = {
  N: 0.00 * Math.PI,
  NE: 0.25 * Math.PI,
  E: 0.50 * Math.PI,
  SE: 0.75 * Math.PI,
  S: 1.00 * Math.PI,
  SW: 1.25 * Math.PI,
  W: 1.50 * Math.PI,
  NW: 1.75 * Math.PI
};

TargetRenderer.setLeaderLength = function(length) {
  console.log(length);
  TargetRenderer.LEADER_LENGTH = Math.min(Math.max(parseInt(length, 10), 0), 7);
  console.log(TargetRenderer.LEADER_LENGTH);
};

TargetRenderer.setLeaderDirection = function(directionString) {
  if (directionString in TargetRenderer.DIRECTION)
    TargetRenderer.LEADER_DIRECTION = TargetRenderer.DIRECTION[directionString];
};

TargetRenderer.getLeaderDirectionString = function() {
  for (var key in TargetRenderer.DIRECTION)
    if (TargetRenderer.DIRECTION[key] === TargetRenderer.LEADER_DIRECTION)
      return key;
};

TargetRenderer.LEADER_LENGTH = 3;
TargetRenderer.LEADER_DIRECTION = TargetRenderer.DIRECTION.N;
TargetRenderer.LEADER_TIP_OFFSET = {
  length: TargetRenderer.LEADER_LENGTH,
  direction: TargetRenderer.LEADER_DIRECTION
};

TargetRenderer.getLeaderTipOffset = function() {
  return Renderer.staticRotate(0, TargetRenderer.LEADER_LENGTH * 15, 0, 0, TargetRenderer.LEADER_DIRECTION);
};

/********************/
/** INSTANCE LEVEL **/
/********************/

TargetRenderer.prototype.renderDataBlockColor = function(elapsed) {
  if (this._target._controlState === this._target._controlStates.INBOUND_HANDOFF ||
    this._target._controlState === this._target._controlStates.POST_HANDOFF)
    return elapsed % 1000 < 500 ? '#fff' : '#bbb';
  else if (this._target._controlState === this._target._controlStates.POST_HANDOFF)
    return elapsed % 1000 < 500 ? '#0c0' : '#080';
  else if (this._target.isOwned())
    return '#fff';
  else
    return '#0c0';
};

TargetRenderer.prototype.renderCone = function(r) {
  if (this._target.course() == -1)
    return;
  if (this._target.isDisplayingCone()) {
    var magCourse = this._target.course() - r.magVar(),
        len = r.distanceToPixels(this._target.position(), this._target.course(), this._target._coneSize),
        width = len / 12,
        pos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
        theta = -magCourse * Math.PI / 180,
        maxLeft = r.rotate(-width / 2, -len, 0, 0, theta),
        maxRight = r.rotate(width / 2, -len, 0, 0, theta),
        distanceLabel = r.rotate(0, -len / 2, 0, 0, theta);
    r.context().beginPath();
    r.context().font = 'bold 14px Oxygen Mono';
    r.context().textAlign = 'center';
    r.context().textBaseline = 'middle';
    r.context().fillStyle = '#369';
    r.context().fillText('' + this._target._coneSize, pos.x + distanceLabel.x, pos.y + distanceLabel.y);
    var tWidth = r.context().measureText('' + this._target._coneSize).width / 2,
        tHeight = 6,
        minX = Math.min(pos.x + maxLeft.x, pos.x + maxRight.x, pos.x),
        maxX = Math.max(pos.x + maxLeft.x, pos.x + maxRight.x, pos.x),
        minY = Math.min(pos.y + maxLeft.y, pos.y + maxRight.y, pos.y),
        maxY = Math.max(pos.y + maxLeft.y, pos.y + maxRight.y, pos.y);
    r.context().save();
    r.context().beginPath();
    r.context().moveTo(minX, minY);
    r.context().lineTo(pos.x + distanceLabel.x, minY);
    r.context().lineTo(pos.x + distanceLabel.x, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x - tWidth - 4, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x - tWidth - 4, pos.y + distanceLabel.y + tHeight + 4);
    r.context().lineTo(pos.x + distanceLabel.x + tWidth + 4, pos.y + distanceLabel.y + tHeight + 4);
    r.context().lineTo(pos.x + distanceLabel.x + tWidth + 4, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x, minY);
    r.context().lineTo(maxX, minY);
    r.context().lineTo(maxX, maxY);
    r.context().lineTo(minX, maxY);
    r.context().lineTo(minX, minY);
    r.context().clip();
    r.context().strokeStyle = '#369';
    r.context().lineWidth = 1;
    r.context().beginPath();
    r.context().moveTo(pos.x, pos.y);
    r.context().lineTo(pos.x + maxLeft.x, pos.y + maxLeft.y);
    r.context().lineTo(pos.x + maxRight.x, pos.y + maxRight.y);
    r.context().lineTo(pos.x, pos.y);
    r.context().stroke();
    r.context().restore();
  }
};

TargetRenderer.prototype.renderJRing = function(r) {
  if (this._target.isDisplayingJRing()) {
    var pos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
        radius = r.distanceToPixels(this._target.position(), this._target.course(), this._target._jRingSize);
    r.context().strokeStyle = '#369';
    r.context().lineWidth = 1;
    r.context().beginPath();
    r.context().arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    r.context().stroke();
    r.context().beginPath();
    r.context().font = 'bold 14px Oxygen Mono';
    r.context().textAlign = 'center';
    r.context().textBaseline = 'bottom';
    r.context().fillStyle = '#369';
    r.context().fillText('' + this._target._jRingSize, pos.x, pos.y + radius);
  }
};

TargetRenderer.prototype.renderExtras = function(r) {
  this.renderJRing(r);
  this.renderCone(r);

  // if (this._target.callsign() === 'ICE98') {
  //   var ACTIVE_LEGS = [
  //     {
  //       startPosition: new LatLon(42.53728102399617, -69.99036947154653),
  //       endPosition: new LatLon(42.44679377265025, -70.47755508601381)
  //     },
  //     {
  //       startPosition: new LatLon(42.44679377265025, -70.47755508601381),
  //       endPosition: new LatLon(42.52755728169469, -70.61846177278272)
  //     },
  //     {
  //       startPosition: new LatLon(42.52755728169469, -70.61846177278272),
  //       endPosition: new LatLon(42.72859260197211, -70.48297467454829)
  //     }
  //   ];

  //   r.context().strokeStyle = 'orange';
  //   r.context().lineWidth = 2;
  //   for (var i in ACTIVE_LEGS) {
  //     var start = r.gtoc(ACTIVE_LEGS[i].startPosition._lat, ACTIVE_LEGS[i].startPosition._lon);
  //     var end = r.gtoc(ACTIVE_LEGS[i].endPosition._lat, ACTIVE_LEGS[i].endPosition._lon);
  //     r.context().beginPath();
  //     r.context().moveTo(start.x, start.y);
  //     r.context().lineTo(end.x, end.y);
  //     r.context().stroke();
  //   }
  // }
};

TargetRenderer.prototype.renderHistory = function(r) {
  if (r.targetHistory()) {
    r.context().fillStyle = '#26c';
    for (var i in this._target.history()) {
      var historyPos = r.gtoc(this._target.history()[i]._lat, this._target.history()[i]._lon);
      r.context().beginPath();
      r.context().arc(historyPos.x, historyPos.y, 2.5 - Math.floor((i - 1) / 4), 0, 2 * Math.PI);
      r.context().globalAlpha = 0.5 - (i - 1) / 10;
      r.context().fill();
    }
    r.context().globalAlpha = 1;
  }
};

TargetRenderer.prototype.renderTarget = function(r) {
  if (this._target.isCoasting())
    return;
  // Determine size of beacon based on distance from radar site
  var radarDistance = r.radarCenterPosition().distanceTo(this._target.position()) * 0.539957,
      beaconWidth = (Math.min(Math.max(radarDistance, 5), 40) - 5) / 35 * 2.5 + 0.5,
      acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      radarCenter = r.radarCenter(),
      theta = r.angleBetween(acPos.x, acPos.y, radarCenter.x, radarCenter.y) + Math.PI / 2,
      unit = r.distanceToPixels(this._target.position(), 0, 0.01),
      width = r.distanceToPixels(this._target.position(), 0, 0.25),
      bHeight = Math.max(beaconWidth * width, 4.5),
      bWidth = Math.max(width, 3);
  // Draw the beacon line
  var lineL = r.rotate(-bHeight * 2, 0, 0, 0, theta);
  var lineR = r.rotate(bHeight * 2, 0, 0, 0, theta);
  r.context().beginPath();
  r.context().moveTo(acPos.x + lineL.x, acPos.y + lineL.y);
  r.context().lineTo(acPos.x + lineR.x, acPos.y + lineR.y);
  r.context().strokeStyle = '#1e582f';
  r.context().lineWidth = Math.max(1.5, unit);
  r.context().stroke();
  // Draw the beacon target
  var boxBL = r.rotate(-bHeight, 0, 0, 0, theta);
  var boxTL = r.rotate(-bHeight, bWidth, 0, 0, theta);
  var boxTR = r.rotate(bHeight, bWidth, 0, 0, theta);
  var boxBR = r.rotate(bHeight, 0, 0, 0, theta);
  r.context().beginPath();
  r.context().moveTo(acPos.x + boxBL.x, acPos.y + boxBL.y);
  r.context().lineTo(acPos.x + boxTL.x, acPos.y + boxTL.y);
  r.context().lineTo(acPos.x + boxTR.x, acPos.y + boxTR.y);
  r.context().lineTo(acPos.x + boxBR.x, acPos.y + boxBR.y);
  r.context().fillStyle = '#2d82ed';
  r.context().fill();
};

TargetRenderer.prototype.renderPosition = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      targetCode = this._target.isControlled() ? this._target.controller().getTargetCode() : '*';
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'center';
  r.context().textBaseline = 'middle';
  r.context().strokeStyle = '#000';
  r.context().lineWidth = 2;
  r.context().strokeText(targetCode, acPos.x, acPos.y);
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  r.context().fillText(targetCode, acPos.x, acPos.y);
};

TargetRenderer.prototype.renderPartialDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the target altitude and speed
  r.context().beginPath();
  r.context().imageSmoothingEnabled= false;
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var scopeSpeed = Math.floor(this._target.speed() / 10);
  var scopeAltitude = Math.floor(this._target.altitude() / 100);
  r.context().fillText(r.pad(scopeAltitude, 3) + '  ' + r.pad(scopeSpeed, 2), acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - leaderTipOffset.y);
  r.context().imageSmoothingEnabled = true;
};

TargetRenderer.prototype.renderFullDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the target callsign
  r.context().beginPath();
  r.context().imageSmoothingEnabled= false;
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var callsignText = this._target.callsign();
  if (this._target.conflictState() === Target.CONFLICT_STATES.INHIBITED)
    callsignText += ' ' + String.fromCharCode(parseInt('25B3', 16));
  r.context().fillText(callsignText, acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - leaderTipOffset.y);
  r.context().imageSmoothingEnabled = true;
  // Draw the target aircraft, altitude, and speed data block
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var scopeSpeed = Math.floor(this._target.speed() / 10),
      scopeAltitude = Math.floor(this._target.altitude() / 100),
      scopeText,
      otherController = this._target.otherController(),
      spacing = otherController ? otherController.getIdentifier() : '  ';
  if (this._target.isCoasting())
    scopeText = 'CST' + spacing + (elapsed % 4000 < 2000 ? r.pad(scopeSpeed, 2) : this._target.type());
  else
    scopeText = elapsed % 4000 < 2000 ? r.pad(scopeAltitude, 3) + spacing + r.pad(scopeSpeed, 2) : this._target.arrival() + spacing + this._target.type();
  r.context().fillText(scopeText, acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - (leaderTipOffset.y - 17));
};

TargetRenderer.prototype.renderConflictAlert = function(r) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  if (this._target.conflictState() === Target.CONFLICT_STATES.CONFLICTING ||
      this._target.conflictState() === Target.CONFLICT_STATES.SUPPRESSED) {
    r.context().beginPath();
    r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
    r.context().textAlign = 'left';
    r.context().textBaseline = 'middle';
    r.context().fillStyle = '#f00';
    r.context().fillText('CA', acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - (leaderTipOffset.y + 17));
  }
};

TargetRenderer.prototype.renderDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the leader line
  r.context().beginPath();
  r.context().moveTo(acPos.x, acPos.y + -10);
  r.context().lineTo(acPos.x + leaderTipOffset.x, acPos.y - 10 - leaderTipOffset.y);
  r.context().lineWidth = 1;
  r.context().strokeStyle = this.renderDataBlockColor(elapsed);
  r.context().stroke();
  if (this._target.isExpanded())
    this.renderFullDataBlock(r, elapsed);
  else
    this.renderPartialDataBlock(r, elapsed);
  this.renderConflictAlert(r);
};function PathRenderer(path) {
  this._path = path;
}

PathRenderer.prototype.render = function(r) {
  var waypoints = this._path.waypoints(),
      pos;

  r.context().fillStyle = '#0c0';
  r.context().strokeStyle = '#0c0';
  r.context().lineJoin = 'round';
  r.context().textBaseline = 'center';
  r.context().textAlign = 'center';
  r.context().font = 10 + 'px Oxygen Mono';

  pos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().strokeStyle = '#030';
  r.context().lineWidth = 4;
  r.context().beginPath();
  r.context().moveTo(pos.x, pos.y);
  for (var i = 1; i < waypoints.length; i++) {
    pos = r.gtoc(waypoints[i].position._lat, waypoints[i].position._lon);
    r.context().lineTo(pos.x, pos.y);
  }
  r.context().stroke();

  pos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().strokeStyle = '#0c0';
  r.context().lineWidth = 4;
  r.context().beginPath();
  r.context().setLineDash([25, 1000]);
  r.context().lineDashOffset = -r.elapsed() % 1025;
  r.context().moveTo(pos.x, pos.y);
  for (var j = 1; j < waypoints.length; j++) {
    pos = r.gtoc(waypoints[j].position._lat, waypoints[j].position._lon);
    r.context().lineTo(pos.x, pos.y);
  }
  r.context().stroke();
  r.context().setLineDash([]);

  var startPos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().beginPath();
  r.context().arc(startPos.x, startPos.y, 4, 0, 2 * Math.PI);
  r.context().fill();

  if (waypoints.length > 1) {
    var endPos = r.gtoc(waypoints[waypoints.length - 1].position._lat,
          waypoints[waypoints.length - 1].position._lon),
        afterStartPos = r.gtoc(waypoints[1].position._lat, waypoints[1].position._lon),
        beforeEndPos = r.gtoc(waypoints[waypoints.length - 2].position._lat,
          waypoints[waypoints.length - 2].position._lon),
        startOrientation = startPos.y < afterStartPos.y ? 1 : -1,
        endOrientation = endPos.y < beforeEndPos.y ? 1 : -1;

    r.context().fillText(this._path.name(), startPos.x, startPos.y - 12 * startOrientation);

    r.context().beginPath();
    r.context().arc(endPos.x, endPos.y, 4, 0, 2 * Math.PI);
    r.context().fill();
  } else {
    r.context().fillText(this._path.name(), startPos.x, startPos.y - 12);
  }
};var Keyboard = Keyboard || {};

Keyboard.COMBO_KEYS = {
  NONE: 0,
  ALT: 1 << 0,
  CTRL: 1 << 1,
  SHIFT: 1 << 2,
  CMD: 1 << 3
};

Keyboard.combo = function(e) {
  var combo = Keyboard.COMBO_KEYS.NONE;
  if (e.altKey)
    combo |= Keyboard.COMBO_KEYS.ALT;
  if (e.ctrlKey)
    combo |= Keyboard.COMBO_KEYS.CTRL;
  if (e.shiftKey)
    combo |= Keyboard.COMBO_KEYS.SHIFT;
  if (e.metaKey)
    combo |= Keyboard.COMBO_KEYS.CMD;
  return combo;
};

Keyboard.KEYS = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESCAPE: 27,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT_ARROW: 37,
  UP_ARROW: 38,
  RIGHT_ARROW: 39,
  DOWN_ARROW: 40,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  LEFT_WINDOW_KEY: 91,
  RIGHT_WINDOW_KEY: 92,
  SELECT_KEY: 93,
  NUMPAD_0: 96,
  NUMPAD_1: 97,
  NUMPAD_2: 98,
  NUMPAD_3: 99,
  NUMPAD_4: 100,
  NUMPAD_5: 101,
  NUMPAD_6: 102,
  NUMPAD_7: 103,
  NUMPAD_8: 104,
  NUMPAD_9: 105,
  MULTIPLY: 106,
  ADD: 107,
  SUBTRACT: 109,
  DECIMAL_POINT: 110,
  DIVIDE: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUM_LOCK: 144,
  SCROLL_LOCK: 145,
  SEMICOLON: 186,
  EQUAL_SIGN: 187,
  COMMA: 188,
  DASH: 189,
  PERIOD: 190,
  FORWARD_SLASH: 191,
  GRAVE_ACCENT: 192,
  OPEN_BRACKET: 219,
  BACK_SLASH: 220,
  CLOSE_BRACKET: 221,
  SINGLE_QUOTE: 222
};

Keyboard.KEYS.MULTIFUNC = Keyboard.KEYS.F7;

Keyboard.MODES = {
  NONE: 1,
  MULTIFUNC: 2
};

Keyboard.MODE = Keyboard.MODES.NONE;

Keyboard[Keyboard.KEYS.ESCAPE] = {};
Keyboard[Keyboard.KEYS.ESCAPE][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
};

Keyboard[Keyboard.KEYS.F3] = {};
Keyboard[Keyboard.KEYS.F3][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('IC');
};

Keyboard[Keyboard.KEYS.F4] = {};
Keyboard[Keyboard.KEYS.F4][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('TC');
};

Keyboard[Keyboard.KEYS.MULTIFUNC] = {};
Keyboard[Keyboard.KEYS.MULTIFUNC][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('F');
  Keyboard.MODE = Keyboard.MODES.MULTIFUNC;
};

Keyboard[Keyboard.KEYS.F11] = {};
Keyboard[Keyboard.KEYS.F11][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('CA');
};

Keyboard[Keyboard.KEYS.S] = {};
Keyboard[Keyboard.KEYS.S][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.scope-settings').toggle();
};

Keyboard[Keyboard.KEYS.M] = {};
Keyboard[Keyboard.KEYS.M][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.situation-controls').toggle();
  if ($('.situation-controls').is(':visible')) {
    $(scope.renderer().scope()).css('margin-left', '250px');
    $('.scope-settings').css('margin-left', '250px');
  } else {
    $(scope.renderer().scope()).css('margin-left', '0');
    $('.scope-settings').css('margin-left', '0');
  }
};

Keyboard[Keyboard.KEYS.R] = {};
Keyboard[Keyboard.KEYS.R][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  //scope.situation().run();
};

Keyboard[Keyboard.KEYS.T] = {};
Keyboard[Keyboard.KEYS.T][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.incoming-messages').toggle();
};


Keyboard[Keyboard.KEYS.P] = {};
Keyboard[Keyboard.KEYS.P][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  //scope.situation().pause();
};

Keyboard[Keyboard.KEYS.ONE] = {};
Keyboard[Keyboard.KEYS.ONE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(1);
};
Keyboard[Keyboard.KEYS.ONE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(1);
};

Keyboard[Keyboard.KEYS.TWO] = {};
Keyboard[Keyboard.KEYS.TWO][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(2);
};
Keyboard[Keyboard.KEYS.TWO][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(2);
};

Keyboard[Keyboard.KEYS.THREE] = {};
Keyboard[Keyboard.KEYS.THREE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(3);
};
Keyboard[Keyboard.KEYS.THREE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(3);
};

Keyboard[Keyboard.KEYS.FOUR] = {};
Keyboard[Keyboard.KEYS.FOUR][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(4);
};
Keyboard[Keyboard.KEYS.FOUR][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(4);
};

Keyboard[Keyboard.KEYS.FIVE] = {};
Keyboard[Keyboard.KEYS.FIVE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(5);
};
Keyboard[Keyboard.KEYS.FIVE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(5);
};

Keyboard[Keyboard.KEYS.SIX] = {};
Keyboard[Keyboard.KEYS.SIX][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(6);
};
Keyboard[Keyboard.KEYS.SIX][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(6);
};

Keyboard[Keyboard.KEYS.SEVEN] = {};
Keyboard[Keyboard.KEYS.SEVEN][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(7);
};
Keyboard[Keyboard.KEYS.SEVEN][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(7);
};

Keyboard[Keyboard.KEYS.EIGHT] = {};
Keyboard[Keyboard.KEYS.EIGHT][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(8);
};
Keyboard[Keyboard.KEYS.EIGHT][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(8);
};

Keyboard[Keyboard.KEYS.NINE] = {};
Keyboard[Keyboard.KEYS.NINE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(9);
};
Keyboard[Keyboard.KEYS.NINE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(9);
};

Keyboard[Keyboard.KEYS.ZERO] = {};
Keyboard[Keyboard.KEYS.ZERO][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(0);
};
Keyboard[Keyboard.KEYS.ZERO][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(0);
};

Keyboard[Keyboard.KEYS.BACKSPACE] = {};
Keyboard[Keyboard.KEYS.BACKSPACE][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().removePreviewChar();
};

Keyboard[Keyboard.KEYS.ADD] = {};
Keyboard[Keyboard.KEYS.ADD][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().targetSelect();
};

Keyboard[Keyboard.KEYS.TAB] = {};
Keyboard[Keyboard.KEYS.TAB][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().targetSelect();
};

Keyboard[Keyboard.KEYS.ENTER] = {};
Keyboard[Keyboard.KEYS.ENTER][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().processPreviewArea(null, scope._controller);
};

Keyboard[Keyboard.KEYS.LEFT_ARROW] = {};
Keyboard[Keyboard.KEYS.LEFT_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('TL');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('L');
      break;
  }
};

Keyboard[Keyboard.KEYS.RIGHT_ARROW] = {};
Keyboard[Keyboard.KEYS.RIGHT_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('TR');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('R');
      break;
  }
};

Keyboard[Keyboard.KEYS.UP_ARROW] = {};
Keyboard[Keyboard.KEYS.UP_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('CM');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('C');
      break;
  }
};

Keyboard[Keyboard.KEYS.DOWN_ARROW] = {};
Keyboard[Keyboard.KEYS.DOWN_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('DM');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('C');
      break;
  }
};

Keyboard[Keyboard.KEYS.DECIMAL_POINT] = {};
Keyboard[Keyboard.KEYS.DECIMAL_POINT][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('SPD');
  scope.textOverlay().addPreviewChar(' ');
};

Keyboard[Keyboard.KEYS.EQUAL_SIGN] = {};
Keyboard[Keyboard.KEYS.EQUAL_SIGN][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('ILS');
  scope.textOverlay().addPreviewChar(' ');
};

Keyboard[Keyboard.KEYS.EQUAL_SIGN] = {};
Keyboard[Keyboard.KEYS.EQUAL_SIGN][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('ILS');
  scope.textOverlay().addPreviewChar(' ');
};var Command = Command || {};

Command.ERROR = {
  FORMAT: 0,
  TAKE_NO_ACTION: 1
};

Command.SEGMENT_TYPE = {
  PLACEHOLDER: 0,
  CALLSIGN: 0,
  HEADING: 0,
  ALTITUDE: 0,
  SPEED: 0,
  SECTOR: 0,
  RUNWAY: 0,
  PATH_NAME: 0,
  PATH_FIXES: 0
};

Command.SEGMENT = {
  ILS: 'ILS',
  VISUAL_APPROACH: 'VA',
  INITIATE_CONTROL: 'IC',
  TERMINATE_CONTROL: 'TC',
  FLY_HEADING: 'FH',
  MAINTAIN_ALTITUDE: 'MA',
  SPEED: 'SPD',
  DRAW_PATH: 'DRAWPATH',
  TYPE_PATH: 'TYPEPATH',
  SHOW_PATH: 'SHOWPATH',
  HIDE_PATH: 'HIDEPATH',
  RELOCATE_TARGET: 'RELOCATE',
  MEASURE_DISTANCE: '*',
  SHOW_COORDINATES: 'FD*',
  TOGGLE_CONFLICT_ALERTS: 'CAK',
  MANAGE_CRDA: 'FN',
  CLEAR_JRING: '*J',
  CLEAR_ALL_JRINGS: '**J',
  CLEAR_CONE: '*P',
  CLEAR_ALL_CONES: '**P'
};

Command.SEGMENT_RAW = {
  ILS: true,
  VA: true,
  IC: true,
  TC: true,
  FH: true,
  MA: true,
  SPD: true,
  TYPE_PATH: true,
  FIXPATH: true,
  '*': true,
  'FD*': true,
  CAK: true,
  FN: true,
  '*J': true,
  '**J': true,
  '*P': true,
  '**P': true,
  RELOCATE: 'true'
};

Command.ALIAS = {
  TL: Command.SEGMENT.FLY_HEADING,
  TR: Command.SEGMENT.FLY_HEADING,
  CM: Command.SEGMENT.MAINTAIN_ALTITUDE,
  DM: Command.SEGMENT.MAINTAIN_ALTITUDE,
  SLOW: Command.SEGMENT.SPEED,
  DP: Command.SEGMENT.DRAW_PATH,
  TP: Command.SEGMENT.TYPE_PATH,
  SP: Command.SEGMENT.SHOW_PATH,
  HP: Command.SEGMENT.HIDE_PATH,
  RELOC: Command.SEGMENT.RELOCATE_TARGET
};

Command.currentCommand = [];
Command.lastCommand = [];

Command.cleanupFunction = null;

Command.clickable = function(e) {
  if (e.type !== 'click')
    throw Command.ERROR.FORMAT;
};

Command.enterable = function(e) {
  if (e.type === 'click')
    throw Command.ERROR.FORMAT;
};

Command.registerCleanupFunction = function(fn, skipOnCurrent) {
  Command.cleanup(skipOnCurrent);
  Command.cleanupFunction = fn;
};

Command.cleanup = function(skipOnCurrent) {
  Command.clearCleanupTimeout();
  if (Command.cleanupFunction) {
    if (!skipOnCurrent || JSON.stringify(Command.currentCommand) !== JSON.stringify(Command.lastCommand))
      Command.cleanupFunction();
    Command.cleanupFunction = null;
    scope.render();
  }
};

Command.cleanupTimeout = null;

Command.clearCleanupTimeout = function() {
  if (Command.cleanupTimeout) {
    clearTimeout(Command.cleanupTimeout);
    Command.cleanupTimeout = null;
  }
};

Command.cleanupIn = function(milliseconds) {
  Command.clearCleanupTimeout();
  Command.cleanupTimeout = setTimeout(function() {
    Command.cleanup();
    Command.clearCleanupTimeout();
  }, milliseconds);
};

Command.run = function(e, args) {
  var fn = Command.manualProcess(e, args),
      command = [];
  if (!fn) {
    for (var i in args) {
      arg = args[i];
      if (!Command.SEGMENT_RAW[arg])
        arg = Command.ALIAS[arg] || Command.SEGMENT_TYPE.PLACEHOLDER;
      command.push(arg);
    }
    fn = Command;
    for (var j in command) {
      fn = fn[command[j]] || Command.manualProcess(e, args);
      if (!fn)
        scope.textOverlay().formatError();
    }
  }
  Command.currentCommand = command;
  try {
    fn(e, args);
    scope.textOverlay().clearPreview();
  } catch (err) {
    switch (err) {
      case Command.ERROR.FORMAT:
        scope.textOverlay().formatError();
        break;
    }
  }
  Command.lastCommand = command;
};

Command.manualProcess = function(e, args) {
  var command = args[0],
      emptySelect = /^$/,
      coneCommand = /^\*P(\d{1,2}(\.\d|))$/,
      jRingCommand = /^\*J(\d{1,2}(\.\d|))$/,
      addRemoveCRDACommand = /^FN([A-Z]{3,4})(\d{2}[A-Z]{0,1})\/(\d{2}[A-Z]{0,1})$/,
      toggleCRDACommand = /^FN(\d)$/;
  if (command.length === 2) {
    var controller = scope.getControllerByIdentifier(command);
    if (controller) {
      return function(e, args) {
        if (e.type === 'click') {
          var target = scope.select(e);
          if (target) {
            if (target.isUndergoingHandoff()) {
              scope.textOverlay().setPreviewAreaMessage('ILL TRK');
              Command.registerCleanupFunction(function() {
                scope.textOverlay().clearPreviewAreaMessage();
              });
            } else {
              socket.emit('ATC.requestHandoff', {
                controller: scope.controller().getIdentifier(),
                to: command,
                aircraft: target.callsign()
              }, function(success) {
                if (!success) {
                  scope.textOverlay().setPreviewAreaMessage('ILL TRK');
                  Command.registerCleanupFunction(function() {
                    scope.textOverlay().clearPreviewAreaMessage();
                  });
                } else
                  target.handoff(controller);
              });
            }
            return;
          }
        }
        throw Command.ERROR.FORMAT;
      };
    }
  }
  switch (true) {
    case emptySelect.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var target = scope.select(e);
          if (target && target.isUndergoingInboundHandoff()) {
            socket.emit('ATC.acceptHandoff', {
              controller: target.otherController().getIdentifier(),
              to: scope.controller().getIdentifier(),
              aircraft: target.callsign()
            }, function(success) {
              if (success) {
                target.acceptHandoff();
              } else {
                scope.textOverlay().setPreviewAreaMessage('ILL TRK');
                Command.registerCleanupFunction(function() {
                  scope.textOverlay().clearPreviewAreaMessage();
                });
              }
            });
          }
        }
      };
    case coneCommand.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var result = coneCommand.exec(command),
              dist = parseFloat(result[1]);
          if (dist < 1 || dist > 30)
            throw Command.ERROR.FORMAT;
          var aircraft = scope.select(e);
          if (aircraft) {
            aircraft.enableCone(dist);
          }
        }
      };
    case jRingCommand.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var result = jRingCommand.exec(command),
              dist = parseFloat(result[1]);
          if (dist < 1 || dist > 30)
            throw Command.ERROR.FORMAT;
          var aircraft = scope.select(e);
          if (aircraft) {
            aircraft.enableJRing(dist);
          }
        }
      };
    case addRemoveCRDACommand.test(command):
      return function(e, args) {
        Command.enterable(e);
        var result = addRemoveCRDACommand.exec(command),
            icao = result[1].length === 3 ? 'K' + result[1] : result[1],
            master = result[2],
            slave = result[3];
        scope.facilityManager().airport(icao, function(airport) {
          if (airport) {
            try {
              scope.CRDAManager().addRemoveCRDA(airport, master, slave);
              scope.textOverlay().clearPreview();
            } catch (err) {
              scope.textOverlay().setPreviewAreaMessage('ILL RWY');
              Command.registerCleanupFunction(function() {
                scope.textOverlay().clearPreviewAreaMessage();
              });
            }
          } else {
            scope.textOverlay().setPreviewAreaMessage('ILL APT');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
        throw Command.ERROR.TAKE_NO_ACTION;
      };
    case toggleCRDACommand.test(command):
      return function(e, args) {
        Command.enterable(e);
        var result = toggleCRDACommand.exec(command),
            num = parseInt(result[1], 10);
        scope.CRDAManager().toggleCRDA(num);
      };
  }
  return null;
};

Command[Command.SEGMENT_TYPE.PLACEHOLDER] = {};

Command[Command.SEGMENT.SHOW_COORDINATES] = function(e, args) {
  if (e.type === 'click') {
    var pos = scope.selectPosition(e);
    scope.addRenderPoint(pos);
    scope.textOverlay().setPreviewAreaMessage(pos._lat.toFixed(4) + ',' + pos._lon.toFixed(4));
    Command.registerCleanupFunction(function() {
      scope.textOverlay().clearPreviewAreaMessage();
      scope.clearRenderPoints();
    });
    Command.cleanupIn(15000);
    return;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_JRING] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.disableJRing();
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_ALL_JRINGS] = function(e, args) {
  Command.enterable(e);
  scope.targetManager().getAllTargets().forEach(function(target) {
    target.disableJRing();
  });
};

Command[Command.SEGMENT.CLEAR_CONE] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.disableCone();
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_ALL_CONES] = function(e, args) {
  Command.enterable(e);
  scope.targetManager().getAllTargets().forEach(function(target) {
    target.disableCone();
  });
};

Command[Command.SEGMENT.MANAGE_CRDA] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.promoteGhosting();
      return;
    }
    target = scope.CRDAManager().select(e);
    if (target) {
      target.demoteGhosting();
      return;
    }
    throw Command.ERROR.FORMAT;
  } else {
    scope.CRDAManager().toggle();
  }
};

Command[Command.SEGMENT.RELOCATE_TARGET] = (function() {
  var selectedTarget = null;
  return function(e, args) {
    if (e.type === 'click') {
      var target = scope.select(e);
      if (target) {
        selectedTarget = target;
        throw Command.ERROR.TAKE_NO_ACTION;
      } else if (selectedTarget) {
        var newPos = scope.selectPosition(e);
        console.log('emitting:');
        console.log('TS.relocate');
        console.log({
          callsign: selectedTarget.callsign(),
          lat: newPos._lat,
          lon: newPos._lon
        });
        socket.emit('TS.relocate', {
          callsign: selectedTarget.callsign(),
          lat: newPos._lat,
          lon: newPos._lon
        });
        return;
      }
    }
    throw Command.ERROR.FORMAT;
  };
})();

Command[Command.SEGMENT.MEASURE_DISTANCE] = function(e, args) {
  if (e.type === 'click') {
    var headingAndDistance = scope.measureHeadingAndDistance(e);
    if (headingAndDistance) {
      scope.addRenderPoint(scope.selectPosition(e));
      scope.textOverlay().clearPreview();
      scope.textOverlay().setPreviewAreaMessage(headingAndDistance.heading + '/' + headingAndDistance.distance);
      Command.registerCleanupFunction(function() {
        scope.textOverlay().clearPreviewAreaMessage();
        scope.clearRenderPoints();
      });
      Command.cleanupIn(15000);
    }
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.INITIATE_CONTROL] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      if (target.isUndergoingHandoff()) {
        scope.textOverlay().setPreviewAreaMessage('ILL TRK');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
      } else {
        socket.emit('ATC.initiateControl', {
          aircraft: target.callsign(),
          controller: scope.controller().getIdentifier()
        }, function(success) {
          if (!success) {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      }
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.TERMINATE_CONTROL] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      if (target.isUndergoingHandoff()) {
        scope.textOverlay().setPreviewAreaMessage('ILL TRK');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
      } else if (target.isUndergoingInboundHandoff()) {
        socket.emit('ATC.refuseHandoff', {
          controller: target.otherController().getIdentifier(),
          to: scope.controller().getIdentifier(),
          aircraft: target.callsign()
        }, function(success) {
          if (success) {
            target.refuseHandoff();
          } else {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      } else {
        socket.emit('ATC.terminateControl', {
          aircraft: target.callsign(),
          controller: scope.controller().getIdentifier()
        }, function(success) {
          if (!success) {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      }
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.TOGGLE_CONFLICT_ALERTS] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target)
      return target.toggleConflictAlerts();
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.ILS] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.ILS][Command.SEGMENT_TYPE.RUNWAY] = function(e, args) {
  var FORMAT_ERROR = false;
  scope.facilityManager().primaryAirport(function(airport) {
    if (airport) {
      var callsign = args[0],
          runwayID = args[2],
          target = scope.targetManager().getTargetByCallsign(callsign),
          runway = airport.runway(runwayID);
      if (target && runway) {
        socket.emit('TS.ILS', {
          callsign: callsign,
          icao: airport.icao(),
          runway: runwayID
        });
        scope.textOverlay().clearPreview();
        return;
      }
    }
    scope.textOverlay().formatError();
    FORMAT_ERROR = true;
  });
  if (FORMAT_ERROR)
    throw Command.ERROR.FORMAT;
  return;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.VISUAL_APPROACH] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.VISUAL_APPROACH][Command.SEGMENT_TYPE.RUNWAY] = function(e, args) {
  var FORMAT_ERROR = false;
  scope.facilityManager().primaryAirport(function(airport) {
    if (airport) {
      var callsign = args[0],
          runwayID = args[2],
          target = scope.targetManager().getTargetByCallsign(callsign),
          runway = airport.runway(runwayID);
      if (target && runway) {
        socket.emit('TS.visualApproach', {
          callsign: callsign,
          icao: airport.icao(),
          runway: runwayID
        });
        scope.textOverlay().clearPreview();
        return;
      }
    }
    scope.textOverlay().formatError();
    FORMAT_ERROR = true;
  });
  if (FORMAT_ERROR)
    throw Command.ERROR.FORMAT;
  return;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.FLY_HEADING] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.FLY_HEADING][Command.SEGMENT_TYPE.HEADING] = function(e, args) {
  var callsign = args[0],
      heading = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignHeading(heading)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.MAINTAIN_ALTITUDE] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.MAINTAIN_ALTITUDE][Command.SEGMENT_TYPE.SPEED] = function(e, args) {
  var callsign = args[0],
      altitude = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignAltitude(altitude)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.SPEED] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.SPEED][Command.SEGMENT_TYPE.SPEED] = function(e, args) {
  var callsign = args[0],
      speed = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignSpeed(speed)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.SHOW_PATH] = {};
Command[Command.SEGMENT.SHOW_PATH][Command.SEGMENT_TYPE.PATH_NAME] = function(e, args) {
  try {
    scope.pathManager().showPath(args[1].toUpperCase());
  } catch (err) {
    switch (err) {
      case PathManager.ERROR.PATH_NOT_FOUND:
        scope.textOverlay().setPreviewAreaMessage('ILL PTH');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
        throw Command.ERROR.TAKE_NO_ACTION;
    }
  }
};

Command[Command.SEGMENT.HIDE_PATH] = {};
Command[Command.SEGMENT.HIDE_PATH][Command.SEGMENT_TYPE.PATH_NAME] = function(e, args) {
  try {
    scope.pathManager().hidePath(args[1].toUpperCase());
  } catch (err) {
    switch (err) {
      case PathManager.ERROR.PATH_NOT_FOUND:
        scope.textOverlay().setPreviewAreaMessage('ILL PTH');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
        throw Command.ERROR.TAKE_NO_ACTION;
    }
  }
};

Command[Command.SEGMENT.DRAW_PATH] = {};
Command[Command.SEGMENT.DRAW_PATH][Command.SEGMENT_TYPE.PATH_NAME] = (function() {
  var path = null,
      cleanup = function() {
        path = null;
        scope.textOverlay().clearPreviewAreaMessage();
      };
  return function(e, args) {
    scope.textOverlay().clearPreviewAreaMessage();
    var pathName = args[1].toUpperCase();
    if (!pathName)
      throw Command.ERROR.FORMAT;
    if (!path)
      path = new Path(pathName);
    if (e.type === 'click') {
      Command.registerCleanupFunction(cleanup, true);
      var pos = scope.selectPosition(e),
          waypoints = path.waypoints(),
          last = waypoints[waypoints.length - 1],
          secondToLast = waypoints[waypoints.length - 2];
      if (last) {
        if (last.position.distanceTo(pos) * 0.539957 < 1) {
          scope.textOverlay().setPreviewAreaMessage('ILL DIST');
          throw Command.ERROR.TAKE_NO_ACTION;
        }
        if (secondToLast) {
          var lastBearing = secondToLast.position.bearingTo(last.position),
              newBearing = last.position.bearingTo(pos);
          if (scope.renderer().angleBetweenHeadings(lastBearing, newBearing) >= 90) {
            scope.textOverlay().setPreviewAreaMessage('ILL TURN');
            throw Command.ERROR.TAKE_NO_ACTION;
          }
        }
      }
      path.addWaypoint(null, pos);
      scope.pathManager().setPath(path);
      scope.pathManager().showPath(pathName);
      throw Command.ERROR.TAKE_NO_ACTION;
    }
    cleanup();
  };
})();

Command[Command.SEGMENT.TYPE_PATH] = {};
Command[Command.SEGMENT.TYPE_PATH][Command.SEGMENT_TYPE.PATH_NAME] = {};
Command[Command.SEGMENT.TYPE_PATH][Command.SEGMENT_TYPE.PATH_NAME][Command.SEGMENT_TYPE.PATH_FIXES] = function(e, args) {
  scope.textOverlay().clearPreviewAreaMessage();
  var pathName = args[1].toUpperCase(),
      waypoints = args[2].split('.'),
      numRequiredWaypoints = waypoints.length;
  if (pathName && numRequiredWaypoints) {
    scope.textOverlay().setPreviewAreaMessage('LOAD...');
    var numResolvedWaypoints = 0,
        waypointLocations = {},
        path = new Path(pathName),
        formRoute = function() {
          Command.registerCleanupFunction(function() {
            scope.clearRenderPaths();
            scope.textOverlay().clearPreviewAreaMessage();
          }, true);
          for (var i in waypoints) {
            var waypointName = waypoints[i],
                waypointLocation = waypointLocations[waypointName];
            if (waypointLocation)
              path.addWaypoint(waypointName, waypointLocation);
            else {
              scope.textOverlay().setPreviewAreaMessage('ILL RTE');
              return;
            }
          }
          scope.pathManager().setPath(path);
          scope.pathManager().showPath(pathName);
          scope.textOverlay().clearPreviewAreaMessage();
        },
        navaidHandler = function(navaid, data) {
          numResolvedWaypoints++;
          if (data.navaid)
            waypointLocations[navaid] = data.navaid;
          if (numResolvedWaypoints === numRequiredWaypoints)
            formRoute();
        },
        fixHandler = function(fix, data) {
          numResolvedWaypoints++;
          if (data.fix)
            waypointLocations[fix] = data.fix;
          if (numResolvedWaypoints === numRequiredWaypoints)
            formRoute();
        };
    for (var i in waypoints) {
      waypoints[i] = waypoints[i].toUpperCase();
      var waypoint = waypoints[i];
      if (waypoint.length === 3)
        $.get('/api/navaids/' + waypoint, navaidHandler.bind(this, waypoint));
      else if (waypoint.length === 5)
        $.get('/api/fixes/' + waypoint, fixHandler.bind(this, waypoint));
      else {
        numResolvedWaypoints++;
        if (numResolvedWaypoints === numRequiredWaypoints)
          formRoute();
      }
    }
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};function ConnectionDelegate(scope, socket) {
  this._scope = scope;
  this._socket = socket;

  this.bindServerListeners();
}

ConnectionDelegate.prototype.bindServerListeners = function() {

  this._socket.on('textMessage', function(data) {
    var $msg = $('<p>').text(data.from.toUpperCase() + '> ' + data.message);
    $('.incoming-messages').append($msg);
  });

  this._socket.on('controllers', function(controllers) {
    this._scope.setControllers(controllers.map(function(controller) {
      return Controller.fromJSON(controller);
    }));
  }.bind(this));

  this._socket.on('ownershipClaimed', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var controller = scope.getControllerByIdentifier(data.controller);
      target.setController(controller);
    }
  });

  this._socket.on('handoffRequested', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var controller = scope.getControllerByIdentifier(data.controller);
      target.inboundHandoff(controller);
    }
  });

  this._socket.on('handoffAccepted', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var to = scope.getControllerByIdentifier(data.to);
      target.handoffAccepted(to);
    }
  });

  this._socket.on('handoffRefused', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      target.handoffRefused();
    }
  });

};var scope = new Scope(socket);
var connectionDelegate = new ConnectionDelegate(scope, socket);
//var radio = new SpeechCommands();

// var config = { 'worker_path': '/vendor/worker.min.js' };
// AudioRecorder.init(config);

// AudioRecorder.record();
// setTimeout(function() {
//   AudioRecorder.stopRecording(function(clip) {
//     AudioRecorder.playClip(clip, 0, 0);

//     console.log(clip.speex);
//   });
// }, 5000);


$(document).ready(function() {
	initScope();
	initScopeZoom();
	initScopeResize();
	initScopeDrag();
	initKeyDetection();
	initSlewDetection();
  initSettings();

  $('.control-section h1').click(function() {
    var $parent = $(this).parent();
    if ($parent.hasClass('expanded')) {
      $parent.removeClass('expanded');
    } else {
      $('.control-section').removeClass('expanded');
      $parent.addClass('expanded');
    }
  });
  $('.control-section .button').click(function() {
    var txt = $(this).text().trim();
    if (txt === 'On' || txt === 'Off')
      $(this).text(txt === 'On' ? 'Off' : 'On');
  });
  $('.control-section').keydown(function(e) {
    e.stopPropagation();
  });
  $('.control-section').keypress(function(e) {
    e.stopPropagation();
  });
  $('.control-section input').mouseout(function(e) {
    $(this).blur();
  });
});

function initScope() {
	scope.bind('#scope');
  // scope.addMap('22L27', '', 'maps/a90.map', function() {
  //   scope.render();
  // });
  
	//scope.addMap('BOSMHT', '', 'maps/bosmht.map', function() {
		//scope.render();
		setInterval(function() {
			scope.render();
		}, 1000 / 30);
    //React.renderComponent(<MasterDCB />, document.getElementById('wahoo'));
	//});
  scope.facilityManager().setPrimaryAirport('KBOS');
  scope.facilityManager().primaryAirport(function(airport) {
    if (!airport)
      return;
    scope.enableSmartMap();
    scope.radar().setPosition(airport.position());
    scope.renderer().setRadarCenter(scope.radar().position());
    //scope.CRDAManager().addRemoveCRDA(airport, '27', '22L');
    scope.setControllerPosition('FINAL', function() {
      scope.turnOn();
    });
  });
}

function initScopeZoom() {
	$('#scope').bind('mousewheel wheel', function(e) {
		var scale = 1 + e.originalEvent.wheelDelta / 1000;
		scale = Math.min(Math.max(scale, .5), 2);
		scope.renderer().setGlobalScale(scope.renderer().globalScale() * scale);
		scope.render();
	});
}

function initScopeResize() {
	$(window).resize(function() {
		scope.render();
	});
}

function initScopeDrag() {
	$('#scope').bind('mousedown touchstart', function(e) {
		e = e.type == 'touchstart' ? e.touches[0] : e;
		scope.renderer().setMouseDown(true);
		scope.renderer().setLastMousePosition({
			x: e.clientX,
			y: e.clientY
		});
		return false;
	});
	$('#scope').bind('mouseup mouseover mouseout touchend touchcancel', function(e) {
    scope.renderer().setMouseDown(false);
  });
	$('#scope').bind('mousemove touchmove', function(e) {
    e = e.type === 'touchmove' ? e.touches[0] : e;
		if (scope.renderer().mouseDown()) {
      scope.renderer().dragging();
			scope.renderer().setTranslationOffset({
				x: scope.renderer().translationOffset().x + scope.renderer().scale(e.clientX - scope.renderer().lastMousePosition().x),
				y: scope.renderer().translationOffset().y + scope.renderer().scale(scope.renderer().lastMousePosition().y - e.clientY)
			});
			scope.renderer().setLastMousePosition({
				x: e.clientX,
				y: e.clientY
			});
			scope.render();
		}
		return false;
	});
}

function initSlewDetection() {
	$('#scope').click(function(e) {
    if (!scope.renderer().wasDragging())
      Command.run(e, scope.textOverlay().previewSegments());
	});
}

function initKeyDetection() {
  $(document).keypress(function(e) {
    scope.textOverlay().addPreviewChar(String.fromCharCode(e.which).toUpperCase());
    scope.render();
  });
	$(document).keydown(function(e) {
    if (e.which === Keyboard.KEYS.ENTER) {
      e.preventDefault();
      Command.run(e, scope.textOverlay().previewSegments());
    } else if (e.which === Keyboard.KEYS.SELECT_KEY) {
      e.preventDefault();
      //radio.transmit();
    } else {
      Command.cleanup();
      var keyCommands = Keyboard[e.which];
      if (keyCommands) {
        var command = keyCommands[Keyboard.combo(e)];
        if (command) {
          e.preventDefault();
          command(e);
          scope.render();
        }
      }
    }
	});
  $(document).keyup(function(e) {
    if (e.which === Keyboard.KEYS.SELECT_KEY) {
      e.preventDefault();
      //radio.release();
    }
  });
}

function initSettings() {
  $(document).ready(function() {
    $('#setting-compass-brightness').change(function(e) {
      scope.compass().setBrite($(this).val());
      scope.render();
    });
    $('#setting-map-brightness').change(function(e) {
      for (var i in scope.maps())
        scope.maps()[i].setBrite($(this).val());
      scope.render();
    });
  });
}function RWTraffic(airport, situation, r) {
  this._r = r;
  this._airport = airport;
  this._situation = situation;
  this._airports = {};
  this._inRequest = {};
}

RWTraffic.prototype.inbound = function(distance, cb) {
  var icao = this._airport.icao();
  if (this._airports[icao] && this._airports[icao].inbound
      && this._airports[icao].inbound.lastUpdate >= new Date().getTime() - 15 * 1000) {
    cb(this._airports[icao].inbound.aircraft, this._airports[icao].inbound.lastUpdate);
    return;
  } else if (this._inRequest[icao])
    return;
  this._inRequest[icao] = true;
  var self = this;
  $.post('/sandbox/sim/feeds/proxy.php', {
    url: 'http://flightaware.com/live/airport/' + icao
  }, function(data) {
    var jsonInbound = data.match(/json_inbound = ({.+});/);
    var arrivals = JSON.parse(jsonInbound[1]);
    var aircraftList = {};
    for (var i in arrivals.features) {
      var aircraft = arrivals.features[i];
      if (aircraft.properties.projected === 0) {
        var inboundAircraft = new Aircraft(aircraft.properties.ident);
        inboundAircraft.setType(aircraft.properties.type);
        inboundAircraft.setCategory('J');
        inboundAircraft.setFlightRules('I');
        inboundAircraft.setArrival(aircraft.properties.destination);
        inboundAircraft.setLat(aircraft.geometry.coordinates[1]);
        inboundAircraft.setLon(aircraft.geometry.coordinates[0]);
        inboundAircraft.setAltitude(aircraft.properties.altitude * 100);
        inboundAircraft.setHeading((aircraft.properties.direction + 180 - self._r.magVar()) % 360);
        inboundAircraft.setSpeed(inboundAircraft.airspeed(aircraft.properties.groundspeed));
        inboundAircraft.setLastSimulated(self._situation.elapsed());
        inboundAircraft.performance().loadFromCategory(inboundAircraft.category());
        if (inboundAircraft.position().distanceTo(self._airport.position()) * 0.539957 < distance)
          aircraftList[inboundAircraft.callsign()] = inboundAircraft;
      }
    }
    if (self._airports[icao] === undefined)
      self._airports[icao] = {};
    self._airports[icao].inbound = {
      lastUpdate: new Date().getTime(),
      aircraft: aircraftList
    };
    //console.log('new update');
    self._inRequest[icao] = false;
    cb(aircraftList, self._airports[icao].inbound.lastUpdate);
  }, 'html');
};function Flow() {
  this._urlRoot = 'http://flightaware.com';
  this._paths = [];
  this._positionReports = [];
  this._aircraftPaths = [];
}

Flow.ERROR = {
  NO_DATA: 1,
  END_PATH: 2
};

Flow.prototype.average = function(position) {
  var forceReports = {
    altitude: [],
    heading: [],
    speed: []
  };
  var minDistance = {
    altitude: 3,
    heading: 3,
    speed: 3
  };
  for (var i in this._positionReports) {
    var report = this._positionReports[i];
    var distance = report.position.distanceTo(position) * 0.539957;
    if (distance <= 3) {
      report.distance = distance;
      if (!isNaN(report.altitude)) {
        forceReports.altitude.push(report);
        if (distance < minDistance)
          minDistance.altitude = distance;
      }
      if (!isNaN(report.heading)) {
        forceReports.heading.push(report);
        if (distance < minDistance)
          minDistance.heading = distance;
      }
      if (!isNaN(report.speed)) {
        forceReports.speed.push(report);
        if (distance < minDistance)
          minDistance.speed = distance;
      }
    }
  }
  var averageAltitude = -1,
      averageHeading = -1,
      averageSpeed = -1;
  if (forceReports.altitude.length > 0) {
    var altitudeSum = 0;
    var totalAltitudeWeight = 0;
    for (var a in forceReports.altitude) {
      var report = forceReports.altitude[a];
      var weight = Math.pow(minDistance.altitude / report.distance, 0.5);
      altitudeSum += report.altitude * weight;
      totalAltitudeWeight += weight;
    }
    averageAltitude = altitudeSum / totalAltitudeWeight;
  }
  if (forceReports.heading.length > 0) {
    var headingX = 0,
        headingY = 0;
    for (var h in forceReports.heading) {
      var report = forceReports.heading[h];
      var weight = Math.pow(minDistance.heading / report.distance, 0.5);
      var headingInRad = (((90 - report.heading) + 360) % 360) * Math.PI / 180;
      headingX += Math.cos(headingInRad) * weight;
      headingY += Math.sin(headingInRad) * weight;
    }
    averageHeading = ((90 - Math.atan2(headingY, headingX) * 180 / Math.PI) + 360) % 360;
  }
  if (forceReports.speed.length > 0) {
    var speedSum = 0;
    var totalSpeedWeight = 0;
    for (var s in forceReports.speed) {
      var report = forceReports.speed[s];
      var weight = Math.pow(minDistance.speed / report.distance, 0.5);
      speedSum += report.speed * weight;
      totalSpeedWeight += weight;
    }
    averageSpeed = speedSum / totalSpeedWeight;
  }
  return {
    altitude: averageAltitude,
    heading: (averageHeading - scope.renderer().magVar()) + 360 % 360,
    speed: averageSpeed
  };
};

Flow.prototype.project = function(position, minutes) {
  var minDistance = 3,
      forceReports = [];
      
  for (var i in this._positionReports) {
    var report = this._positionReports[i];
    var distance = report.position.distanceTo(position) * 0.539957;
    if (distance <= 3) {
      report.distance = distance;
      forceReports.push(report);
      if (distance < minDistance)
        minDistance = distance;
    }
  }

  var sumX = 0,
      sumY = 0,
      sumZ = 0,
      totalWeight = 0,
      endProjections = 0,
      projectionThreshold = Math.floor(forceReports.length * 0.33);

  for (var j in forceReports) {
    var forceReport = forceReports[j],
        projection = forceReport.aircraftPath[forceReport.index + minutes];
    if (projection) {
      var lat = projection.position._lat * Math.PI / 180,
          lon = projection.position._lon * Math.PI / 180,
          x = Math.cos(lat) * Math.cos(lon),
          y = Math.cos(lat) * Math.sin(lon),
          z = Math.sin(lat),
          weight = Math.pow(minDistance / forceReport.distance, 0.5);
      sumX += x * weight;
      sumY += y * weight;
      sumZ += z * weight;
      totalWeight += weight;
    } else {
      endProjections++;
      if (endProjections >= projection)
        throw Flow.ERROR.END_PATH;
    }
  }

  var avgX = sumX / totalWeight,
      avgY = sumY / totalWeight,
      avgZ = sumZ / totalWeight,
      pLon = Math.atan2(avgY, avgX),
      pHyp = Math.sqrt(Math.pow(avgX, 2) + Math.pow(avgY, 2)),
      pLat = Math.atan2(avgZ, pHyp);

  if (isNaN(pLat) || isNaN(pLon))
    throw Flow.ERROR.NO_DATA;

  return new LatLon(pLat * 180 / Math.PI, pLon * 180 / Math.PI);
};

Flow.prototype.countInRange = function(position, range) {
  var count = 0;
  for (var i in this._positionReports) {
    var distance = this._positionReports[i].position.distanceTo(position) * 0.539957;
    if (distance <= range)
      count++;
  }
  return count;
};

Flow.prototype.loadRecent = function(airport, limit, cb) {
  var flow = this;
  for (var o = 0; o < 20; o += 20) {
    $.get('proxy', {
      url: this._urlRoot + '/live/airport/KBOS/arrivals?;offset=' + o
    }, function(data) {
      var flights = data.match(/\/live\/flight\/\w+/g);
      for (var i = 1; i < flights.length; i++) {
        (function(i) {
          $.get('proxy', {
            url: flow._urlRoot + flights[i]
          }, function(data) {
            var path = data.match(/data-target='(.+?)' style/);
            var link = flow._urlRoot + path[1] + '/tracklog';
            $.get('proxy', {
              url: link
            }, function(data) {
              //console.log(data);
              var path = [];

              var rows = data.match(/<tr class="smallrow[12]{1}">[\s\S]+?<\/tr>/g);
              //.+?<td align="center">.+?<\/td>.+?<td align="center">.+?&deg;<\/td>.+?<td align="left">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?<\/td>.+?<td align="right">.+?&nbsp;
              //console.log(stuff);


              var aircraftPath = [];

              for (var i in rows) {
                var row = rows[i];
                //console.log(row);
                var position = row.match(/<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)<\/td>[\s\S]+?<td align="center">(.+?)&deg;<\/td>[\s\S]+?<td align="left">(.+?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)<\/td>[\s\S]+?<td align="right">(.*?)&nbsp;/);
                //console.log(position);
                var time = position[1];
                var lat = parseFloat(position[2]);
                var lon = parseFloat(position[3]);
                var course = parseInt(position[4]);
                var direction = position[5];
                var groundspeed = parseInt(position[6]);
                var groundspeedMPH = parseInt(position[7]);
                var altitude = parseInt(position[8].replace(',', ''));

                aircraftPath[i] = {
                  position: new LatLon(lat, lon),
                  heading: course,
                  speed: groundspeed,
                  altitude: altitude,
                  aircraftPath: aircraftPath,
                  index: parseInt(i, 10)
                };
                flow._positionReports.push(aircraftPath[i]);
                console.log('added');
              }
              flow._aircraftPaths.push(aircraftPath);


              











              var position = data.match(/"center">(.+?)</g);
              var numPositionReports = position.length / 4;
              for (var i = 0; i < numPositionReports; i++) {
                var latMatch = position[i * 4 + 1].match(/>(.+?)</);
                var lonMatch = position[i * 4 + 2].match(/>(.+?)</);
                path[i] = [parseFloat(latMatch[1]), parseFloat(lonMatch[1])];
              }
              flow._paths.push(path);
              //cb(path);
            }, 'html');
          }, 'html');
        })(i);
      }
    }, 'html');
  }
};

Flow.prototype.loadRecent2 = function(airport, limit, cb) {
  var flow = this;
  $.get('proxy', {
    url: this._urlRoot + '/live/flight/SKV7384'
  }, function(data) {
    var pathString = data.match(/trackstring = ({.+});/);
    var pathObject = JSON.parse(pathString[1]);
    var path = pathObject.features[2].geometry.coordinates;
    for (var i in path) {
      var temp = path[i][0];
      path[i][0] = path[i][1];
      path[i][1] = temp;
    }
    flow._paths['SKV73841'] = path;
    cb(path);
  }, 'html');
};

Flow.prototype.renderPath = function(path, r) {
  // r.context().fillStyle = 'rgb(255, 255, 0';
  // for (var i in path) {
  //   var pos = r.gtoc(path[i][0], path[i][1]);
  //   r.context().fillRect(pos.x - 2, pos.y - 2, 4, 4);
  // }
  r.context().lineWidth = 1.5;
  r.context().strokeStyle = 'rgba(255, 255, 0, .1)';
  r.context().beginPath();
  var start = r.gtoc(path[0][0], path[0][1]);
  r.context().moveTo(start.x, start.y);
  for (var i = 1; i < path.length; i++) {
    var next = r.gtoc(path[i][0], path[i][1]);
    r.context().lineTo(next.x, next.y);
  }
  r.context().stroke();
};

Flow.prototype.render = function(r) {
  for (var i in this._paths)
    this.renderPath(this._paths[i], r);
};/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Latitude/longitude spherical geodesy formulae & scripts (c) Chris Veness 2002-2012            */
/*   - www.movable-type.co.uk/scripts/latlong.html                                                */
/*                                                                                                */
/*  Sample usage:                                                                                 */
/*    var p1 = new LatLon(51.5136, -0.0983);                                                      */
/*    var p2 = new LatLon(51.4778, -0.0015);                                                      */
/*    var dist = p1.distanceTo(p2);          // in km                                             */
/*    var brng = p1.bearingTo(p2);           // in degrees clockwise from north                   */
/*    ... etc                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Note that minimal error checking is performed in this example code!                           */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/**
 * @requires Geo
 */
 
 
/**
 * Creates a point on the earth's surface at the supplied latitude / longitude
 *
 * @constructor
 * @param {Number} lat: latitude in numeric degrees
 * @param {Number} lon: longitude in numeric degrees
 * @param {Number} [rad=6371]: radius of earth if different value is required from standard 6,371km
 */
function LatLon(lat, lon, rad) {
  if (typeof(rad) == 'undefined') rad = 6371;  // earth's mean radius in km
  // only accept numbers or valid numeric strings
  this._lat = typeof(lat)=='number' ? lat : typeof(lat)=='string' && lat.trim()!='' ? +lat : NaN;
  this._lon = typeof(lon)=='number' ? lon : typeof(lon)=='string' && lon.trim()!='' ? +lon : NaN;
  this._radius = typeof(rad)=='number' ? rad : typeof(rad)=='string' && trim(lon)!='' ? +rad : NaN;
}


/**
 * Returns the distance from this point to the supplied point, in km 
 * (using Haversine formula)
 *
 * from: Haversine formula - R. W. Sinnott, "Virtues of the Haversine",
 *       Sky and Telescope, vol 68, no 2, 1984
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @param   {Number} [precision=4]: no of significant digits to use for returned value
 * @returns {Number} Distance in km between this point and destination point
 */
LatLon.prototype.distanceTo = function(point, precision) {
  // default 4 sig figs reflects typical 0.3% accuracy of spherical model
  if (typeof precision == 'undefined') precision = 4;
  
  var R = this._radius;
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  var lat2 = point._lat.toRad(), lon2 = point._lon.toRad();
  var dLat = lat2 - lat1;
  var dLon = lon2 - lon1;

  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1) * Math.cos(lat2) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  var d = R * c;
  return d.toPrecisionFixed(precision);
}


/**
 * Returns the (initial) bearing from this point to the supplied point, in degrees
 *   see http://williams.best.vwh.net/avform.htm#Crs
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Initial bearing in degrees from North
 */
LatLon.prototype.bearingTo = function(point) {
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();

  var y = Math.sin(dLon) * Math.cos(lat2);
  var x = Math.cos(lat1)*Math.sin(lat2) -
          Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  var brng = Math.atan2(y, x);
  
  return (brng.toDeg()+360) % 360;
}


/**
 * Returns final bearing arriving at supplied destination point from this point; the final bearing 
 * will differ from the initial bearing by varying degrees according to distance and latitude
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Final bearing in degrees from North
 */
LatLon.prototype.finalBearingTo = function(point) {
  // get initial bearing from supplied point back to this point...
  var lat1 = point._lat.toRad(), lat2 = this._lat.toRad();
  var dLon = (this._lon-point._lon).toRad();

  var y = Math.sin(dLon) * Math.cos(lat2);
  var x = Math.cos(lat1)*Math.sin(lat2) -
          Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  var brng = Math.atan2(y, x);
          
  // ... & reverse it by adding 180°
  return (brng.toDeg()+180) % 360;
}


/**
 * Returns the midpoint between this point and the supplied point.
 *   see http://mathforum.org/library/drmath/view/51822.html for derivation
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {LatLon} Midpoint between this point and the supplied point
 */
LatLon.prototype.midpointTo = function(point) {
  lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();

  var Bx = Math.cos(lat2) * Math.cos(dLon);
  var By = Math.cos(lat2) * Math.sin(dLon);

  lat3 = Math.atan2(Math.sin(lat1)+Math.sin(lat2),
                    Math.sqrt( (Math.cos(lat1)+Bx)*(Math.cos(lat1)+Bx) + By*By) );
  lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/**
 * Returns the destination point from this point having travelled the given distance (in km) on the 
 * given initial bearing (bearing may vary before destination is reached)
 *
 *   see http://williams.best.vwh.net/avform.htm#LL
 *
 * @param   {Number} brng: Initial bearing in degrees
 * @param   {Number} dist: Distance in km
 * @returns {LatLon} Destination point
 */
LatLon.prototype.destinationPoint = function(brng, dist) {
  dist = typeof(dist)=='number' ? dist : typeof(dist)=='string' && dist.trim()!='' ? +dist : NaN;
  dist = dist/this._radius;  // convert dist to angular distance in radians
  brng = brng.toRad();  // 
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();

  var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) + 
                        Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
  var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1), 
                               Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
  lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

  return new LatLon(lat2.toDeg(), lon2.toDeg());
}


/**
 * Returns the point of intersection of two paths defined by point and bearing
 *
 *   see http://williams.best.vwh.net/avform.htm#Intersection
 *
 * @param   {LatLon} p1: First point
 * @param   {Number} brng1: Initial bearing from first point
 * @param   {LatLon} p2: Second point
 * @param   {Number} brng2: Initial bearing from second point
 * @returns {LatLon} Destination point (null if no unique intersection defined)
 */
LatLon.intersection = function(p1, brng1, p2, brng2) {
  brng1 = typeof brng1 == 'number' ? brng1 : typeof brng1 == 'string' && trim(brng1)!='' ? +brng1 : NaN;
  brng2 = typeof brng2 == 'number' ? brng2 : typeof brng2 == 'string' && trim(brng2)!='' ? +brng2 : NaN;
  lat1 = p1._lat.toRad(), lon1 = p1._lon.toRad();
  lat2 = p2._lat.toRad(), lon2 = p2._lon.toRad();
  brng13 = brng1.toRad(), brng23 = brng2.toRad();
  dLat = lat2-lat1, dLon = lon2-lon1;
  
  dist12 = 2*Math.asin( Math.sqrt( Math.sin(dLat/2)*Math.sin(dLat/2) + 
    Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2) ) );
  if (dist12 == 0) return null;
  
  // initial/final bearings between points
  brngA = Math.acos( ( Math.sin(lat2) - Math.sin(lat1)*Math.cos(dist12) ) / 
    ( Math.sin(dist12)*Math.cos(lat1) ) );
  if (isNaN(brngA)) brngA = 0;  // protect against rounding
  brngB = Math.acos( ( Math.sin(lat1) - Math.sin(lat2)*Math.cos(dist12) ) / 
    ( Math.sin(dist12)*Math.cos(lat2) ) );
  
  if (Math.sin(lon2-lon1) > 0) {
    brng12 = brngA;
    brng21 = 2*Math.PI - brngB;
  } else {
    brng12 = 2*Math.PI - brngA;
    brng21 = brngB;
  }
  
  alpha1 = (brng13 - brng12 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 2-1-3
  alpha2 = (brng21 - brng23 + Math.PI) % (2*Math.PI) - Math.PI;  // angle 1-2-3
  
  if (Math.sin(alpha1)==0 && Math.sin(alpha2)==0) return null;  // infinite intersections
  if (Math.sin(alpha1)*Math.sin(alpha2) < 0) return null;       // ambiguous intersection
  
  //alpha1 = Math.abs(alpha1);
  //alpha2 = Math.abs(alpha2);
  // ... Ed Williams takes abs of alpha1/alpha2, but seems to break calculation?
  
  alpha3 = Math.acos( -Math.cos(alpha1)*Math.cos(alpha2) + 
                       Math.sin(alpha1)*Math.sin(alpha2)*Math.cos(dist12) );
  dist13 = Math.atan2( Math.sin(dist12)*Math.sin(alpha1)*Math.sin(alpha2), 
                       Math.cos(alpha2)+Math.cos(alpha1)*Math.cos(alpha3) )
  lat3 = Math.asin( Math.sin(lat1)*Math.cos(dist13) + 
                    Math.cos(lat1)*Math.sin(dist13)*Math.cos(brng13) );
  dLon13 = Math.atan2( Math.sin(brng13)*Math.sin(dist13)*Math.cos(lat1), 
                       Math.cos(dist13)-Math.sin(lat1)*Math.sin(lat3) );
  lon3 = lon1+dLon13;
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/**
 * Returns the distance from this point to the supplied point, in km, travelling along a rhumb line
 *
 *   see http://williams.best.vwh.net/avform.htm#Rhumb
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Distance in km between this point and destination point
 */
LatLon.prototype.rhumbDistanceTo = function(point) {
  var R = this._radius;
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLat = (point._lat-this._lat).toRad();
  var dLon = Math.abs(point._lon-this._lon).toRad();
  
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  var q = (isFinite(dLat/dPhi)) ? dLat/dPhi : Math.cos(lat1);  // E-W line gives dPhi=0
  
  // if dLon over 180° take shorter rhumb across anti-meridian:
  if (Math.abs(dLon) > Math.PI) {
    dLon = dLon>0 ? -(2*Math.PI-dLon) : (2*Math.PI+dLon);
  }
  
  var dist = Math.sqrt(dLat*dLat + q*q*dLon*dLon) * R; 
  
  return dist.toPrecisionFixed(4);  // 4 sig figs reflects typical 0.3% accuracy of spherical model
}

/**
 * Returns the bearing from this point to the supplied point along a rhumb line, in degrees
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {Number} Bearing in degrees from North
 */
LatLon.prototype.rhumbBearingTo = function(point) {
  var lat1 = this._lat.toRad(), lat2 = point._lat.toRad();
  var dLon = (point._lon-this._lon).toRad();
  
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  if (Math.abs(dLon) > Math.PI) dLon = dLon>0 ? -(2*Math.PI-dLon) : (2*Math.PI+dLon);
  var brng = Math.atan2(dLon, dPhi);
  
  return (brng.toDeg()+360) % 360;
}

/**
 * Returns the destination point from this point having travelled the given distance (in km) on the 
 * given bearing along a rhumb line
 *
 * @param   {Number} brng: Bearing in degrees from North
 * @param   {Number} dist: Distance in km
 * @returns {LatLon} Destination point
 */
LatLon.prototype.rhumbDestinationPoint = function(brng, dist) {
  var R = this._radius;
  var d = parseFloat(dist)/R;  // d = angular distance covered on earth’s surface
  var lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  brng = brng.toRad();

  var dLat = d*Math.cos(brng);
  // nasty kludge to overcome ill-conditioned results around parallels of latitude:
  if (Math.abs(dLat) < 1e-10) dLat = 0; // dLat < 1 mm
  
  var lat2 = lat1 + dLat;
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4));
  var q = (isFinite(dLat/dPhi)) ? dLat/dPhi : Math.cos(lat1);  // E-W line gives dPhi=0
  var dLon = d*Math.sin(brng)/q;
  
  // check for some daft bugger going past the pole, normalise latitude if so
  if (Math.abs(lat2) > Math.PI/2) lat2 = lat2>0 ? Math.PI-lat2 : -Math.PI-lat2;
  
  lon2 = (lon1+dLon+3*Math.PI)%(2*Math.PI) - Math.PI;
 
  return new LatLon(lat2.toDeg(), lon2.toDeg());
}

/**
 * Returns the loxodromic midpoint (along a rhumb line) between this point and the supplied point.
 *   see http://mathforum.org/kb/message.jspa?messageID=148837
 *
 * @param   {LatLon} point: Latitude/longitude of destination point
 * @returns {LatLon} Midpoint between this point and the supplied point
 */
LatLon.prototype.rhumbMidpointTo = function(point) {
  lat1 = this._lat.toRad(), lon1 = this._lon.toRad();
  lat2 = point._lat.toRad(), lon2 = point._lon.toRad();
  
  if (Math.abs(lon2-lon1) > Math.PI) lon1 += 2*Math.PI; // crossing anti-meridian
  
  var lat3 = (lat1+lat2)/2;
  var f1 = Math.tan(Math.PI/4 + lat1/2);
  var f2 = Math.tan(Math.PI/4 + lat2/2);
  var f3 = Math.tan(Math.PI/4 + lat3/2);
  var lon3 = ( (lon2-lon1)*Math.log(f3) + lon1*Math.log(f2) - lon2*Math.log(f1) ) / Math.log(f2/f1);
  
  if (!isFinite(lon3)) lon3 = (lon1+lon2)/2; // parallel of latitude
  
  lon3 = (lon3+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º
  
  return new LatLon(lat3.toDeg(), lon3.toDeg());
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/**
 * Returns the latitude of this point; signed numeric degrees if no format, otherwise format & dp 
 * as per Geo.toLat()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {Number|String} Numeric degrees if no format specified, otherwise deg/min/sec
 */
LatLon.prototype.lat = function(format, dp) {
  if (typeof format == 'undefined') return this._lat;
  
  return Geo.toLat(this._lat, format, dp);
}

/**
 * Returns the longitude of this point; signed numeric degrees if no format, otherwise format & dp 
 * as per Geo.toLon()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {Number|String} Numeric degrees if no format specified, otherwise deg/min/sec
 */
LatLon.prototype.lon = function(format, dp) {
  if (typeof format == 'undefined') return this._lon;
  
  return Geo.toLon(this._lon, format, dp);
}

/**
 * Returns a string representation of this point; format and dp as per lat()/lon()
 *
 * @param   {String} [format]: Return value as 'd', 'dm', 'dms'
 * @param   {Number} [dp=0|2|4]: No of decimal places to display
 * @returns {String} Comma-separated latitude/longitude
 */
LatLon.prototype.toString = function(format, dp) {
  if (typeof format == 'undefined') format = 'dms';
  
  return Geo.toLat(this._lat, format, dp) + ', ' + Geo.toLon(this._lon, format, dp);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

// ---- extend Number object with methods for converting degrees/radians

/** Converts numeric degrees to radians */
if (typeof Number.prototype.toRad == 'undefined') {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  }
}

/** Converts radians to numeric (signed) degrees */
if (typeof Number.prototype.toDeg == 'undefined') {
  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  }
}

/** 
 * Formats the significant digits of a number, using only fixed-point notation (no exponential)
 * 
 * @param   {Number} precision: Number of significant digits to appear in the returned string
 * @returns {String} A string representation of number which contains precision significant digits
 */
if (typeof Number.prototype.toPrecisionFixed == 'undefined') {
  Number.prototype.toPrecisionFixed = function(precision) {
    
    // use standard toPrecision method
    var n = this.toPrecision(precision);
    
    // ... but replace +ve exponential format with trailing zeros
    n = n.replace(/(.+)e\+(.+)/, function(n, sig, exp) {
      sig = sig.replace(/\./, '');       // remove decimal from significand
      l = sig.length - 1;
      while (exp-- > l) sig = sig + '0'; // append zeros from exponent
      return sig;
    });
    
    // ... and replace -ve exponential format with leading zeros
    n = n.replace(/(.+)e-(.+)/, function(n, sig, exp) {
      sig = sig.replace(/\./, '');       // remove decimal from significand
      while (exp-- > 1) sig = '0' + sig; // prepend zeros from exponent
      return '0.' + sig;
    });
    
    return n;
  }
}

/** Trims whitespace from string (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */
if (typeof String.prototype.trim == 'undefined') {
  String.prototype.trim = function() {
    return String(this).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

if (typeof module !== 'undefined' && module.exports) {
  module.exports = LatLon;
}function BDFFont () { this.init.apply(this, arguments) };
BDFFont.prototype = {
  init : function (bdf) {
    var self = this;
    self.glyphs = {};
    self.properties = {};
    self.parse(bdf);
  },

  parse : function (bdf) {
    var self = this;
    var lines = bdf.split(/\n/);

    var glyph = null, properties = null;
    for (var i = 0, len = lines.length; i < len; i++) {
      var line = lines[i];

      if (glyph) {
        if (line != 'ENDCHAR') {
          if (!glyph['BITMAP']) {
            var d = line.split(' ');
            switch (d[0]) {
              case 'ENCODING':
                glyph['ENCODING'] = +d[1];
                break;
              case 'SWIDTH':
                glyph['SWIDTH'] = {
                  x: +d[1],
                  y: +d[2]
                };
                break;
              case 'DWIDTH':
                glyph['DWIDTH'] = {
                  x: +d[1],
                  y: +d[2]
                };
                break;
              case 'BBX':
                glyph['BBw']  = +d[1];
                glyph['BBh']  = +d[2];
                glyph['BBox'] = +d[3];
                glyph['BBoy'] = +d[4];
                break;
              case 'ATTRIBUTES':
                break;
              case 'BITMAP':
                glyph['BITMAP'] = [];
                break;
            }
          } else {
            glyph['BITMAP'].bits = line.length * 4;
            glyph['BITMAP'].push(parseInt(line, 16));
          }
        } else {
          self.glyphs[glyph['ENCODING']] = glyph;
          glyph = null;
        }
      } else if (properties) {
        if (line != 'ENDPROPERTIES') {
          var d = line.split(' ', 2);
          properties[ d[0] ] = (d[1][0] == '"') ? d[1].substring(1, d[1].length - 2): +d[1];
        } else {
          self.properties = properties;
          properties = null;
        }
      } else {
        var d = line.split(' ');
        switch (d[0]) {
          case 'COMMENT': break;
          case 'FONT':
            self['FONT'] = d[1];
            break;
          case 'SIZE':
            self['SIZE'] = {
              size : +d[1],
              xres : +d[2],
              yres : +d[3]
            };
            break;
          case 'FONTBOUNDINGBOX':
            self['FONTBOUNDINGBOX'] = {
              w : +d[1],
              h : +d[2],
              x : +d[3],
              y : +d[4]
            };
            break;
          case 'STARTPROPERTIES':
            properties = {};
            break;
          case 'CHARS':
            self['CHARS'] = +d[1];
            break;
          case 'STARTCHAR':
            glyph = {};
          case 'ENDCHAR':
            break;
        }
      }
    }
  },

  drawChar : function (ctx, c, bx, by, t) {
    var self = this;
    var g = self.glyphs[ c ] || self.glyphs[ self.properties['DEFAULT_CHAR'] ];
    if (t) {
      var f = function () {};
      f.prototype = g;
      g = new f();
      g = t(g);
    };
    var n = g['BBw'];
    var b = g['BITMAP'];
    var ox = bx + g['BBox'] - 1;
    var oy = by - g['BBoy'] - g['BBh'] + 1;
    for (var y = 0, len = b.length; y < len; y++) {
      var l = b[y];
      for (var i = b.bits, x = 0; i >= 0; i--, x++) {
        if (l >> i & 0x01 == 1) {
          ctx.fillRect(ox + x, oy + y, 1, 1);
        }
      }
    }
    return { x: bx + g['DWIDTH'].x, y : by + g['DWIDTH'].y };
  },

  drawText : function (ctx, text, x, y, t) {
    var self = this;
    for (var i = 0, len = text.length; i < len; i++) {
      var c = text[i].charCodeAt(0);
      var r = self.drawChar(ctx, c, x, y, t);
      x = r.x; y = r.y;
    }
    return { x: x, y: y };
  },

  drawEdgeText : function (ctx, text, x, y, t) {
    var self = this;
    self.drawText(ctx, text, x, y, function (g) {
      var bitmap =  new Array(g['BITMAP'].length + 2);
      bitmap.bits = g['BITMAP'].bits + 2;
      for (var i = -1, len = bitmap.length; i < len; i++) {
        bitmap[i+1] = g['BITMAP'][i]   | g['BITMAP'][i]   >> 1 | g['BITMAP'][i]   >> 2 |
                      g['BITMAP'][i+1] | g['BITMAP'][i+1] >> 1 | g['BITMAP'][i+1] >> 2 |
                      g['BITMAP'][i-1] | g['BITMAP'][i-1] >> 1 | g['BITMAP'][i-1] >> 2 ;
      }
      g['BITMAP'] = bitmap;
      g['BBox']  += -3;
      g['BBoy']  +=  1;
      return g;
    });
  }
};function WeatherOverlay() {
  this._overlays = [];
  this._weatherMarks = [];
  this._weatherGrid = [];
  this._contourGrid = [];
  this._weatherLoading = false;
}

WeatherOverlay.prototype.refresh = function(r) {
  var weatherOverlay = this;
  this.fetch(r, function(data) {
    weatherOverlay._overlays.push(data);
  });
};

WeatherOverlay.prototype.fetch = function(r, callback) {
  var baseURL = 'http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi';
  var requestData = {
    'service': 'WMS',
    'request': 'GetMap',
    'version': '1.1.1',
    'format': 'PNG',
    'width': r.scope().width,
    'height': r.scope().height,
    'SRS': 'EPSG:4326',
    'bbox': (r.minLon() + ',' + r.minLat() + ',' + r.maxLon() + ',' + r.maxLat()),
    'layers': 'nexrad-n0q-conus'
  };
  $.get(baseURL, requestData, function(data) {
    callback(data);
  }, 'jsonp');
};

WeatherOverlay.prototype.render = function(r) {
  if (this._overlays.length > 0) {
    r.context().save();
    r.context().globalAlpha = .5;
    for (var row in this._contourGrid) {
      for (var col in this._contourGrid[row]) {
        var wx = this._contourGrid[row][col];
        if (wx.precip > 0) {
          var pos = r.gtoc(wx.lat, wx.lon);
          r.context().beginPath();
          r.context().moveTo(pos.x - 10, pos.y - 10);
          r.context().lineTo(pos.x + 10, pos.y - 10);
          r.context().lineTo(pos.x + 10, pos.y + 10);
          r.context().lineTo(pos.x - 10, pos.y + 10);
          if (wx.precip < 4)
            r.context().fillStyle = 'rgb(25, 50, 50)';
            //r.context().strokeStyle = 'rgb(' + wx.red + ', ' + wx.green + ', ' + wx.blue + ')';
          else
            r.context().fillStyle = 'rgb(70, 70, 35)';
          r.context().fill();
          r.context().fillStyle = '#fff';
          r.context().font = 'bold 14 px Arial';
          r.context().textAlign = 'center';
          r.context().textBaseline = 'middle';


          
          // Dots
          r.context().lineWidth = 1;
          r.context().strokeStyle = 'rgb(100, 100, 100)';
          var theta = wx.lat * wx.lon;
          if (wx.precip % 3 == 2) {
            r.context().beginPath();
            r.context().moveTo(pos.x, pos.y);
            r.context().lineTo(pos.x + 2 * Math.cos(theta), pos.y + 2 * Math.sin(theta));
            r.context().stroke();
          } else if (wx.precip % 3 == 0) {
            r.context().beginPath();
            r.context().moveTo(pos.x - 20 / 3, pos.y - 20 / 3);
            r.context().lineTo(pos.x - 20 / 3 + 2 * Math.cos(theta), pos.y - 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x + 20 / 3, pos.y - 20 / 3);
            r.context().lineTo(pos.x + 20 / 3 + 2 * Math.cos(theta), pos.y - 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x + 20 / 3, pos.y + 20 / 3);
            r.context().lineTo(pos.x + 20 / 3 + 2 * Math.cos(theta), pos.y + 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();

            r.context().beginPath();
            r.context().moveTo(pos.x - 20 / 3, pos.y + 20 / 3);
            r.context().lineTo(pos.x - 20 / 3 + 2 * Math.cos(theta), pos.y + 20 / 3 + 2 * Math.sin(theta));
            r.context().stroke();
          }

          
          //r.context().fillText(wx.precip, pos.x, pos.y);
        }
      }
    }
    r.context().restore();
  } else if (!this._weatherLoading) {
    this._weatherLoading = true;
    var weatherOverlay = this;
    $.get('wx/wx.php', {
      'bbox': ((r.minLon() - r.lonRange() * .1) + ',' + (r.minLat() - r.latRange() * .1) + ',' + (r.maxLon() + r.lonRange() * .1) + ',' + (r.maxLat() + r.latRange() * .1))
    }, function() {
      var img = new Image;
      img.src = 'wx/wx.gif';
      img.onload = function() {
        var imgData = {
          data: weatherOverlay.imageToData(img)
        };
        var analyzed = 0, marked = 0, loop = 0;

        var bottomLeft = new LatLon(r.minLat() - r.latRange() * .1, r.minLon() - r.lonRange() * .1);
        var topRight = new LatLon(r.maxLat() + r.latRange() * .1, r.maxLon() + r.lonRange() * .1);

        var geoHeight = bottomLeft.distanceTo(new LatLon(topRight._lat, bottomLeft._lon)) * 0.539957;
        var latIncrement = (topRight._lat - bottomLeft._lat) / geoHeight / 1;
        for (var latStep = 0; latStep < topRight._lat - bottomLeft._lat; latStep += latIncrement) {
          var precipGridRow = [];
          var contourGridRow = [];
          var geoWidth = new LatLon(bottomLeft._lat + latStep, bottomLeft._lon).distanceTo(new LatLon(bottomLeft._lat + latStep, topRight._lon)) * 0.539957;
          var lonIncrement = (topRight._lon - bottomLeft._lon) / geoWidth / 1;
          for (var lonStep = 0; lonStep < topRight._lon - bottomLeft._lon; lonStep += lonIncrement) {
            var x = Math.floor(lonStep / (topRight._lon - bottomLeft._lon) * 2048);
            var y = img.height - Math.floor(latStep / (topRight._lat - bottomLeft._lat) * 2048);
            var xRow = 2048 * 4 * y;
            var base = xRow + x * 4;
            var alpha = imgData.data[base + 3];
            //if (alpha == '255') {
              // RGB Color Data
              var red = imgData.data[base];
              var green = imgData.data[base + 1];
              var blue = imgData.data[base + 2];
              var precipLevel = 0;
              if (red < blue && green < blue && Math.abs(red - green) < 50)
                precipLevel = 1;
              else if (red < green && red < blue && Math.abs(green - blue) < 100)
                precipLevel = 2;
              else if (red < green && green > blue && Math.abs(red - blue) < 50)
                precipLevel = 3;
              else if (green > blue && Math.abs(red - green) < 50)
                precipLevel = 4;
              else if (red > blue && green > 50 && Math.abs(green - blue) > 50)
                precipLevel = 5;
              else if (red > blue && red > green && Math.abs(green - blue) < 50)
                precipLevel = 6;

              weatherOverlay._weatherMarks.push(bottomLeft._lat + latStep);
              weatherOverlay._weatherMarks.push(bottomLeft._lon + lonStep);
              weatherOverlay._weatherMarks.push(precipLevel);
              weatherOverlay._weatherMarks.push(red);
              weatherOverlay._weatherMarks.push(green);
              weatherOverlay._weatherMarks.push(blue);

              precipGridRow.push({
                precip: precipLevel,
                lat: bottomLeft._lat + latStep,
                lon: bottomLeft._lon + lonStep,
                red: red,
                green: green,
                blue: blue
              });

              contourGridRow.push({
                precip: precipLevel,
                lat: bottomLeft._lat + latStep,
                lon: bottomLeft._lon + lonStep,
                red: red,
                green: green,
                blue: blue
              });
            //}
          }
          weatherOverlay._weatherGrid.push(precipGridRow);
          weatherOverlay._contourGrid.push(contourGridRow);
        }


        // for (var row = 0; row < weatherOverlay._weatherGrid.length; row++) {
        //   for (var col = 0; col < weatherOverlay._weatherGrid[row].length; col++) {
        //     var anchor = weatherOverlay._weatherGrid[row][col];
        //     var delta = 0;
        //     for (var nrow = row - 1; nrow <= row + 1; nrow++) {
        //       for (var ncol = col - 1; ncol <= col + 1; ncol++) {
        //         var neighbor;
        //         if (nrow >= 0 && nrow < weatherOverlay._weatherGrid.length
        //           && ncol >= 0 && ncol < weatherOverlay._weatherGrid[nrow].length)
        //           neighbor = weatherOverlay._weatherGrid[nrow][ncol];
        //         else
        //           neighbor = {precip: 0};
        //         delta += Math.abs(neighbor.precip - anchor.precip);
        //       }
        //     }
        //     weatherOverlay._contourGrid[row][col].precip = delta;
        //   }
        // }

        // for (var row = 0; row < weatherOverlay._weatherGrid.length; row++) {
        //   for (var col = 0; col < weatherOverlay._weatherGrid[row].length; col++) {
        //     var anchor = weatherOverlay._weatherGrid[row][col];
        //     var delta = 0;
        //     for (var nrow = row - 1; nrow <= row + 1; nrow++) {
        //       for (var ncol = col - 1; ncol <= col + 1; ncol++) {
        //         if (nrow == row || ncol == col) {
        //           var neighbor;
        //           if (nrow >= 0 && nrow < weatherOverlay._weatherGrid.length
        //             && ncol >= 0 && ncol < weatherOverlay._weatherGrid[nrow].length) {
        //             neighbor = weatherOverlay._weatherGrid[nrow][ncol];
        //             if (nrow == row) {

        //             } else {

        //             }
        //           }
        //           else
        //             neighbor = {precip: 0};
        //           delta += Math.abs(neighbor.precip - anchor.precip);
        //         }
        //       }
        //     }
        //     weatherOverlay._contourGrid[row][col].precip = delta;
        //   }
        // }

        weatherOverlay._overlays.push(img);
      };
    });
  }
};

WeatherOverlay.prototype.weatherDataToSystems = function(data, r) {
  var imgData = weatherOverlay.imageToData(img);
  var analyzed = 0, marked = 0, loop = 0;

  var bottomLeft = new LatLon(r.minLat() - r.latRange() * .1, r.minLon() - r.lonRange() * .1);
  var topRight = new LatLon(r.maxLat() + r.latRange() * .1, r.maxLon() + r.lonRange() * .1);

  var geoHeight = bottomLeft.distanceTo(new LatLon(topRight._lat, bottomLeft._lon)) * 0.539957;
  var latIncrement = (topRight._lat - bottomLeft._lat) / geoHeight;
  for (var latStep = 0; latStep < topRight._lat - bottomLeft._lat; latStep += latIncrement) {
    var geoWidth = new LatLon(bottomLeft._lat + latStep, bottomLeft._lon).distanceTo(new LatLon(bottomLeft._lat + latStep, topRight._lon)) * 0.539957;
    var lonIncrement = (topRight._lon - bottomLeft._lon) / geoWidth;
    for (var lonStep = 0; lonStep < topRight._lon - bottomLeft._lon; lonStep += lonIncrement) {
      var x = Math.floor(lonStep / (topRight._lon - bottomLeft._lon) * 2048);
      var y = img.height - Math.floor(latStep / (topRight._lat - bottomLeft._lat) * 2048);
      var xRow = 2048 * 4 * y;
      var base = xRow + x * 4;
      var alpha = imgData.data[base + 3];
      if (alpha == '255') {
        weatherOverlay._weatherMarks.push(bottomLeft._lat + latStep);
        weatherOverlay._weatherMarks.push(bottomLeft._lon + lonStep);
        // RGB Color Data
        weatherOverlay._weatherMarks.push(imgData.data[base]);
        weatherOverlay._weatherMarks.push(imgData.data[base + 1]);
        weatherOverlay._weatherMarks.push(imgData.data[base + 2]);
      }
    }
  }
  weatherOverlay._overlays.push(img);
};

WeatherOverlay.prototype.imageToData = function(img) {
  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var context = canvas.getContext('2d');
  context.drawImage(img, 0, 0, img.width, img.height);
  var imgData = context.getImageData(0, 0, img.width, img.height);
  return imgData.data;
};var LatLon;
if (typeof module !== 'undefined' && module.exports) {
  LatLon = require('../latlon.js');
}

function Airport(icao, iata, lat, lon, elevation, magVar) {
  this._icao = icao;
  this._iata = iata;
	this._lat = lat;
	this._lon = lon;
	this._elevation = elevation;
  this._magVar = magVar;
	this._runways = {};
  this._metar = null;
  this._syncing = false;
}

Airport.SYNC_INTERVAL = 5 * 60 * 1000;

Airport.prototype.enterSync = function() {
  if (!this._syncing) {
    this._syncing = true;
    this.sync();
    setInterval(function() {
      this.sync();
    }.bind(this), Airport.SYNC_INTERVAL);
  }
};

Airport.prototype.sync = function() {
  $.get('/api/metars/' + this.icao(), function(metar) {
    if (metar)
      this._metar = metar;
  }.bind(this));
};

Airport.prototype.numRunways = function() {
  return this._runways.length / 2;
};

Airport.prototype.addRunway = function(runway) {
	this._runways[runway.id()] = runway;
};

Airport.prototype.runway = function(id) {
	return this._runways[id];
};

Airport.prototype.runways = function() {
  return this._runways;
};

Airport.prototype.runwayPairs = function() {
  var runwayIDs = {},
      runwayPairs = [];
  for (var id in this._runways) {
    if (!runwayIDs[id] && /^(\d{1,2})(L|C|R){0,1}$/.test(id)) {
      var pair = this.runwayPair(id);
      runwayIDs[pair[0].id()] = true;
      runwayIDs[pair[1].id()] = true;
      runwayPairs.push(pair);
    }
  }
  return runwayPairs;
};

Airport.prototype.runwayPair = function(id) {
  var runwayParts = id.match(/^(\d{1,2})(L|C|R){0,1}$/),
      letter = runwayParts[2],
      number = parseInt(runwayParts[1], 10),
      opposingLetter = '',
      opposingNumber = (number + 18) % 36;
  if (opposingNumber === 0)
    opposingNumber = 36;
  if (opposingNumber < 10)
    opposingNumber = '0' + opposingNumber;
  switch (letter) {
    case 'L':
      opposingLetter = 'R';
      break;
    case 'R':
      opposingLetter = 'L';
      break;
    case 'C':
      opposingLetter = 'C';
      break;
    default:
      opposingLetter = '';
  }
  var opposingID = opposingNumber + opposingLetter;
  return [this.runway(id), this.runway(opposingID)];
};

Airport.prototype.position = function() {
  return new LatLon(this._lat, this._lon);
};

Airport.prototype.icao = function() {
  return this._icao;
};

Airport.prototype.iata = function() {
  return this._iata;
};

Airport.prototype.lat = function() {
  return this._lat;
};

Airport.prototype.lon = function() {
  return this._lon;
};

Airport.prototype.elevation = function() {
  return this._elevation;
};

Airport.prototype.magVar = function() {
  return this._magVar;
};

Airport.prototype.metar = function() {
  this.enterSync();
  return this._metar;
};

Airport.prototype.altimeter = function() {
  return this.metar() ? this.metar().altimeter : '--.--';
};

Airport.prototype.windText = function(r) {
  return this.metar() ? r.pad(this.metar().wind.direction, 3) + '' + r.pad(this.metar().wind.speed, 2) : '';
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Airport;
}var LatLon;
if (typeof module !== 'undefined' && module.exports) {
	LatLon = require('../latlon.js');
}

function Runway(id, lat, lon, elevation, length, width, course, ILSCapable) {
	this._id = id;
	this._lat = lat;
	this._lon = lon;
	this._elevation = elevation;
	this._length = length;
	this._width = width;
	this._course = course;
	this._ILSCapable = ILSCapable || false;
}

Runway.prototype.enableILS = function() {
	this._ILSCapable = true;
};

Runway.prototype.disableILS = function() {
	this._ILSCapable = false;
};

Runway.prototype.hasILS = function() {
	return this._ILSCapable;
};

Runway.prototype.id = function() {
	return this._id;
};

Runway.prototype.position = function() {
  return new LatLon(this._lat, this._lon);
};

Runway.prototype.lat = function() {
	return this._lat;
};

Runway.prototype.lon = function() {
	return this._lon;
};

Runway.prototype.elevation = function() {
	return this._elevation;
};

Runway.prototype.length = function() {
	return this._length;
};

Runway.prototype.width = function() {
	return this._width;
};

Runway.prototype.course = function() {
	return this._course;
};

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Runway;
}var FacilitiesAPI,
    Airport,
    Runway,
    NODE = false;

if (typeof module !== 'undefined' && module.exports) {
  FacilitiesAPI = require('./server/FacilitiesAPI.js');
  Airport = require('./facilities/airport.js');
  Runway = require('./facilities/runway.js');
  NODE = true;
}

function FacilityManager() {
  this._airports = {};
  this._primaryAirport = '';
}

FacilityManager.prototype.setPrimaryAirport = function(icao) {
  this._primaryAirport = icao;
};

FacilityManager.prototype.primaryAirport = function(cb, cbOnlyIfAvailable) {
  if (this._primaryAirport)
    return this.airport(this._primaryAirport, cb, cbOnlyIfAvailable);
  cb(null);
};

FacilityManager.prototype.airports = function() {
  return this._airports;
};

FacilityManager.prototype.airport = function(icao, cb, cbOnlyIfAvailable) {
  var airport = this._airports[icao];
  if (airport)
    return cb(airport);
  var airportCallback = function(airport) {
    if (airport) {
      this._airports[airport.icao] = new Airport(
        airport.icao,
        airport.iata,
        airport.lat,
        airport.lon,
        airport.elevation,
        airport.magVar
      );
      for (var r in airport.runways) {
        var runway = airport.runways[r];
        this._airports[airport.icao].addRunway(new Runway(
          runway.id,
          runway.lat,
          runway.lon,
          runway.elevation,
          runway.length,
          runway.width,
          runway.course,
          runway.ILSCapable
        ));
      }
      return cbOnlyIfAvailable || cb(this._airports[airport.icao]);
    }
    cb(null);
  }.bind(this);
  if (NODE)
    FacilitiesAPI.airport(icao, airportCallback);
  else
    $.get('/api/airports/' + icao, airportCallback);
};

if (NODE) {
  module.exports = FacilityManager;
}function Compass() {
	this._display = true;
	this._brite = 5;
	this._notchLength = 12;
}

Compass.prototype.setBrite = function(brite) {
	this._brite = brite;
};

Compass.prototype.render = function(r) {
	if (this._display) {
		r.context().strokeStyle = r.brite(this._brite);
		r.context().lineWidth = 1;
		var radius = Math.sqrt(Math.pow(r.scope().width / 2, 2) + Math.pow(r.scope().height / 2, 2));
		// Draw each notch on the scope
		for (var i = 0; i < 360; i += 5) {
			var from = (i - 95) / 180 * Math.PI;
			var to = (i - 90) / 180 * Math.PI;
			r.context().beginPath();
			r.context().arc(r.scope().width / 2, r.scope().height / 2, radius, from, to);
			r.context().lineTo(r.scope().width / 2, r.scope().height / 2);
			r.context().stroke();
		}
		// Erase the middle of the scope to show only the notches
		r.context().beginPath();
		r.context().rect(this._notchLength, this._notchLength, r.scope().width - this._notchLength * 2, r.scope().height - this._notchLength * 2);
		r.context().fillStyle = r.background();
		r.context().fill();
		// Draw each heading label on the scope
		for (var i = 0; i < 360; i += 10) {
			var radiusX = 1 / Math.abs(Math.cos(i / 180 * Math.PI)) * (r.scope().height / 2 - (this._notchLength + 15));
			var radiusY = 1 / Math.abs(Math.sin(i / 180 * Math.PI)) * (r.scope().width / 2 - (this._notchLength + 15));
			var radius = radiusX < radiusY ? radiusX : radiusY;
			var angle = (i - 90) / 180 * Math.PI;
			var x = r.scope().width / 2 + Math.cos(angle) * radius;
			var y = r.scope().height / 2 + Math.sin(angle) * radius;
			r.context().beginPath();
			r.context().font = '10px Oxygen Mono';
			r.context().textAlign = 'center';
			r.context().textBaseline = 'middle';
			r.context().fillStyle = r.brite(this._brite);
			r.context().fillText(r.pad(i, 3, true), x, y);
		}
	}
};function Controller(position, beaconCode, identifier, name, frequency, socket) {
  this._position = position;
  this._targetCode = beaconCode;
  this._identifier = identifier;
  this._name = name;
  this._frequency = frequency;
  this._socket = socket;
}

Controller.fromJSON = function(data) {
  return new Controller(data.position, data.targetCode, data.identifier, data.name, data.frequency, null);
};

Controller.prototype.toJSON = function() {
  return {
    position: this.getPosition(),
    targetCode: this.getTargetCode(),
    identifier: this.getIdentifier(),
    name: this.getName(),
    frequency: this.getFrequency()
  };
};

Controller.prototype.getSocket = function() {
  return this._socket;
};

Controller.prototype.getPosition = function() {
  return this._position;
};

Controller.prototype.getTargetCode = function() {
  return this._targetCode;
};

Controller.prototype.getIdentifier = function() {
  return this._identifier;
};

Controller.prototype.getName = function() {
  return this._name;
};

Controller.prototype.getFrequency = function() {
  return this._frequency;
};

Controller.prototype.setTargetCode = function(targetCode) {
  this._targetCode = targetCode;
};

Controller.prototype.setIdentifier = function(identifier) {
  this._identifier = identifier;
};

Controller.prototype.setName = function(name) {
  this._name = name;
};

Controller.prototype.setFrequency = function(frequency) {
  this._frequency = frequency;
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Controller;
}function ConflictDetectionEngine() {
  this._conflictStates = {};
  this._conflicts = {};
  this._audibleConflicts = 0;
  this._alarmSounding = false;
  this._alarm = new Audio('../atc2/conflictalert.wav');
  this._separationMinima = [
    {
      anchor: null,
      radius: null,
      minAltitude: null,
      maxAltitude: 17999,
      lateral: 3,
      vertical: 1000
    },
    {
      anchor: null,
      radius: null,
      minAltitude: 18000,
      maxAltitude: null,
      lateral: 5,
      vertical: 1000
    }
  ];
  this._conflictState = {
    NONE: 1,
    ACTIVE: 2,
    MUTED: 3
  }
}

ConflictDetectionEngine.prototype.conflicts = function() {
  var identifiers = [];
  for (var id in this._conflictStates)
    if (this._conflictStates[id] != this._conflictState.NONE)
      identifiers.push(id);
  return identifiers;
};

ConflictDetectionEngine.prototype.manageAlarm = function() {
  if (this._audibleConflicts > 0) {
    if (!this._alarmSounding) {
      this._alarmSounding = true;
      this._alarm.loop = true;
      this._alarm.play();
    }
  } else if (this._alarmSounding) {
    this._alarmSounding = false;
    this._alarm.pause();
  }
};

ConflictDetectionEngine.prototype.singleTargetInConflict = function(target) {
  if (this._conflicts[target.callsign()])
    return true;
  else return false;
};

ConflictDetectionEngine.prototype.detect = function(targets) {
  var callsigns = Object.keys(targets);
  var numTarget = callsigns.length;
  for (var i = 0; i < numTarget; i++) {
    for (var j = i + 1; j < numTarget; j++) {
      var localTarget = targets[callsigns[i]];
      var foreignTarget = targets[callsigns[j]];
      if (this.inConflict(localTarget, foreignTarget))
        this.addConflict(localTarget, foreignTarget);
      else
        this.removeConflict(localTarget, foreignTarget);
    }
  }
};

ConflictDetectionEngine.prototype.addConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (!this._conflictStates[identifier] || this._conflictStates[identifier] == this._conflictState.NONE) {
    this._conflictStates[identifier] = this._conflictState.ACTIVE;
    if (!this._conflicts[localTarget.callsign()])
      this._conflicts[localTarget.callsign()] = 0;
    this._conflicts[localTarget.callsign()]++;
    if (!this._conflicts[foreignTarget.callsign()])
      this._conflicts[foreignTarget.callsign()] = 0;
    this._conflicts[foreignTarget.callsign()]++;
    this._audibleConflicts++;
  }
};

ConflictDetectionEngine.prototype.removeConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.ACTIVE) {
    this._conflictStates[identifier] = this._conflictState.NONE;
    this._conflicts[localTarget.callsign()]--;
    this._conflicts[foreignTarget.callsign()]--;
    this._audibleConflicts--;
  } else if (this._conflictStates[identifier] == this._conflictState.MUTED) {
    this._conflictStates[identifier] = this._conflictState.NONE;
    this._conflicts[localTarget.callsign()]--;
    this._conflicts[foreignTarget.callsign()]--;
  }
};

ConflictDetectionEngine.prototype.muteTarget = function(localTarget, targets) {
  if (this._audibleConflicts > 0)
    for (var i in targets)
      this.muteConflict(localTarget, targets[i]);
};

ConflictDetectionEngine.prototype.muteConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.ACTIVE) {
    this._conflictStates[identifier] = this._conflictState.MUTED;
    this._audibleConflicts--;
    this.manageAlarm();
  }
};

ConflictDetectionEngine.prototype.unmuteConflict = function(localTarget, foreignTarget) {
  var identifier = this.targetsToIdentifier(localTarget, foreignTarget);
  if (this._conflictStates[identifier] == this._conflictState.MUTED) {
    this._conflictStates[identifier] = this._conflictState.ACTIVE;
    this._audibleConflicts++;
    this.manageAlarm();
  }
};

ConflictDetectionEngine.prototype.targetsToIdentifier = function(localTarget, foreignTarget) {
  var targets = [localTarget.callsign(), foreignTarget.callsign()];
  targets.sort();
  return targets.join('*');
};

ConflictDetectionEngine.prototype.classifyMinima = function(localTarget, foreignTarget) {
  var minima = {
    lateral: 0,
    vertical: 0
  };
  for (var i in this._separationMinima) {
    var m = this._separationMinima[i];
    if (
      (m.lateral > minima.lateral ||
        m.vertical > m.vertical) &&
      (!m.anchor ||
        m.anchor) &&
      (!m.minAltitude ||
        (localTarget.altitude() >= m.minAltitude ||
          foreignTarget.altitude() >= m.minAltitude)) &&
      (!m.maxAltitude ||
        (localTarget.altitude() <= m.maxAltitude ||
          foreignTarget.altitude() <= m.maxAltitude))
    ) {
      minima.lateral = Math.max(m.lateral, minima.lateral);
      minima.vertical = Math.max(m.vertical, minima.vertical);
    }
  }
  return minima;
};

ConflictDetectionEngine.prototype.inConflict = function(localTarget, foreignTarget) {
  var minima = this.classifyMinima(localTarget, foreignTarget);
    if (Math.abs(localTarget.altitude() - foreignTarget.altitude()) >= minima.vertical)
    return false;
  var localPosition = new LatLon(localTarget.lat(), localTarget.lon());
  var foreignTarget = new LatLon(foreignTarget.lat(), foreignTarget.lon());
   if (localPosition.distanceTo(foreignTarget) * 0.539957 >= minima.lateral)
    return false;
  return true;
};function CRDA(airport, masterRunwayID, slaveRunwayID) {
  this._airport = airport;
  this._master = airport.runway(masterRunwayID);
  this._slave = airport.runway(slaveRunwayID);

  if (!this._master || !this._slave)
    throw CRDA.ERROR.INVALID_RUNWAYS;

  this._enabled = true;
}

CRDA.ERROR = {
  INVALID_RUNWAYS: 1
};

CRDA.prototype.enable = function() {
  this._enabled = true;
};

CRDA.prototype.disable = function() {
  this._enabled = false;
};

CRDA.prototype.isEnabled = function() {
  return this._enabled;
};

CRDA.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

CRDA.prototype.ghostTargets = function(targetManager, r) {
  var targets = targetManager.getAllTargets();
  targets.forEach(function(target) {
    if (target.ghostState() !== Target.GHOST_STATES.INHIBITED)
      this.ghostTarget(target, r);
  }.bind(this));
};

CRDA.prototype.select = function(x, y, r) {
  var targets = scope.targetManager().getAllTargets();
  for (var i in targets) {
    var target = targets[i];
    if (this.shouldGhostTarget(target, r)) {
      var pos = this.ghostPosition(target, r);
      var coordinates = r.gtoc(pos._lat, pos._lon);
      var dx = coordinates.x - x;
      var dy = coordinates.y - y;
      var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
      if (distance < 15) {
        return target;
      }
    }
  }
  return null;
};

CRDA.prototype.ghostTarget = function(target, r) {
  if (this.shouldGhostTarget(target, r))
    this.renderGhost(target, this.ghostPosition(target, r), r);
};

CRDA.prototype.shouldGhostTarget = function(target, r) {
  return this._master && (target.ghostState() === Target.GHOST_STATES.FORCED || this.inMasterZone(target, r));
};

CRDA.prototype.ghostPosition = function(target, r) {
  var bearingOffset = 360 - this._master.course() + this._master.position().bearingTo(target.position());
  var distance = this._master.position().distanceTo(target.position());
  return this._slave.position().destinationPoint(this._slave.course() + bearingOffset, distance);
};

CRDA.prototype.renderGhost = function(target, position, r) {
  var acPos = r.gtoc(position._lat, position._lon);
  r.context().fillStyle = '#ff0';
  r.context().strokeStyle = '#ff0';
  // Render position
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'center';
  r.context().textBaseline = 'middle';
  r.context().fillText('0', acPos.x, acPos.y);
  // Draw the leader line
  r.context().beginPath();
  r.context().moveTo(acPos.x - 10, acPos.y);
  r.context().lineTo(acPos.x - 40, acPos.y);
  r.context().lineWidth = 1;
  r.context().stroke();
  // Draw the target altitude and speed data block
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'right';
  r.context().textBaseline = 'middle';
  var scopeSpeed = Math.floor(target.speed() / 10);
  var scopeAltitude = Math.floor(target.altitude() / 100);
  r.context().fillText(r.pad(scopeSpeed, 2), acPos.x - 45, acPos.y);
};

CRDA.prototype.setMaster = function(runway) {
  this._master = runway;
};

CRDA.prototype.setSlave = function(runway) {
  this._slave = runway;
};

CRDA.prototype.master = function() {
  return this._master;
};

CRDA.prototype.slave = function() {
  return this._slave;
};

CRDA.prototype.airport = function() {
  return this._airport;
};

CRDA.prototype.inMasterZone = function(target, r) {
  if (target.course() == -1)
    return false;
  var distanceInFeet = target.position().distanceTo(this._master.position()) * 3280.84;
  var radioAltitude = target.altitude() - this._master.elevation();
  var gsAltitude = Math.tan(3 * Math.PI / 180) * distanceInFeet;
  if (target.altitude() < gsAltitude + 1000 &&
      this.angleBetween(target.course(), this._master.course()) < 90 &&
      this.inMasterFunnel(target, r))
    return true;
  return false;
};

CRDA.prototype.angleBetween = function(primaryHeading, secondaryHeading) {
  var gap = Math.abs(primaryHeading - secondaryHeading);
  return Math.min(gap, 360 - gap);
};

CRDA.prototype.inMasterFunnel = function(target, r) {
  var bearingOffset = (360 - this._master.course() + this._master.position().bearingTo(target.position())) % 360;
  var distance = this._master.position().distanceTo(target.position()) * 0.539957;
  return 150 <= bearingOffset && bearingOffset <= 210 && distance <= 30;
};function CRDAManager() {
  this._CRDAs = [];
  this._CRDAIdentifiers = {};
  this._enabled = true;
}

CRDAManager.prototype.enable = function() {
  this._enabled = true;
};

CRDAManager.prototype.disable = function() {
  this._enabled = false;
};

CRDAManager.prototype.isEnabled = function() {
  return this._enabled;
};

CRDAManager.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

CRDAManager.prototype.toggleCRDA = function(num) {
  var crda = this._CRDAs[num - 1];
  if (crda)
    crda.toggle();
};

CRDAManager.prototype.select = function(e) {
  var offset = $(e.target).offset(),
      x = e.clientX - offset.left,
      y = e.clientY - offset.top,
      r = scope.renderer();
  if (this.isEnabled())
    for (var i in this._CRDAs) {
      var crda = this._CRDAs[i];
      if (crda.isEnabled()) {
        var target = crda.select(x, y, r);
        if (target)
          return target;
      }
    }
  return null;
};

CRDAManager.prototype.ghostTargets = function(targetManager, r) {
  for (var i in this._CRDAs) {
    var crda = this._CRDAs[i];
    if (crda.isEnabled())
      crda.ghostTargets(targetManager, r);
  }
};

CRDAManager.prototype.addRemoveCRDA = function(airport, masterRunwayID, slaveRunwayID) {
  var id = airport.icao() + masterRunwayID + slaveRunwayID;
  if (!this._CRDAIdentifiers[id]) {
    this._CRDAIdentifiers[id] = true;
    this._CRDAs.push(new CRDA(airport, masterRunwayID, slaveRunwayID));
  } else {
    for (var i in this._CRDAs) {
      var crda = this._CRDAs[i];
      if (crda.airport().icao() === airport.icao() &&
          crda.master().id() === masterRunwayID &&
          crda.slave().id() === slaveRunwayID) {
        delete this._CRDAIdentifiers[id];
        return this._CRDAs.splice(i, 1);
      }
    }
  }
};

CRDAManager.prototype.CRDAs = function() {
  return this._CRDAs;
};function Map(id, name, filename, r, callback) {
	this._id = id;
	this._name = name;
	this._path = [];
	this._brite = 5;
	this._enabled = true;

	if (typeof filename == 'string')
		this.loadFromFile(filename, r, callback);
}

Map.prototype.id = function() {
	return this._id;
};

Map.prototype.name = function() {
	return this._name;
};

Map.prototype.enabled = function() {
	return this._enabled;
};

Map.prototype.toggle = function() {
	this._enabled = !this._enabled;
};

Map.prototype.setBrite = function(brite) {
	this._brite = brite;
};

Map.prototype.loadFromFile = function(filename, r, callback) {
	var map = this;
	$.get(filename, function(data) {
		map.addMapPath(data.split('\n'), r);
		callback();
	});
};

Map.prototype.addMapPath = function(pathList, r) {
	// Loop through map file
	for (var line in pathList) {
		var lineData = pathList[line].trim().split(' ');
		if (lineData.length >= 4) {
			var subpath = [];
			// Loop through each coordinate in line
			subpath[0] = parseFloat(lineData[0]);
			if (!isNaN(subpath[0])) {
				for (var n = 1; n < 4; n++)
					subpath[n] = parseFloat(lineData[n]);
			} else {
				for (var i in lineData) {
					if (i < 4) {
						var lineDataParts = lineData[i].split('.');
						var p1 = parseInt(lineDataParts[0].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p2 = parseInt(lineDataParts[1].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p3 = parseInt(lineDataParts[2].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						var p4 = parseInt(lineDataParts[3].replace('N', '+').replace('E', '+').replace('S', '-').replace('W', '-'));
						if (p1 < 0) {
							subpath[i] = -1 * (-1 * p1 + p2 / 60 + (parseFloat(p3 + '.' + p4)) / 3600);
						} else {
							subpath[i] = p1 + p2 / 60 + (parseFloat(p3 + '.' + p4)) / 3600;
						}
					}
				}
			}
			// Update the minimum and maximum coordinates
			r.setMinLat(Math.min(r.minLat(), subpath[0], subpath[2]));
			r.setMinLon(Math.min(r.minLon(), subpath[1], subpath[3]));
			r.setMaxLat(Math.max(r.maxLat(), subpath[0], subpath[2]));
			r.setMaxLon(Math.max(r.maxLon(), subpath[1], subpath[3]));
			// Add the line to the list of lines
			this._path[line] = subpath;
		}
	}
	// Calculate the midpoint of the rendered scope map	
	var scopeCorner = new LatLon(r.minLat(), r.minLon());
	var scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
	r.setMidLat(scopeMidpoint._lat);
	r.setMidLon(scopeMidpoint._lon);
};

Map.prototype.render = function(r) {
	if (this._enabled) {
		r.context().lineWidth = 1.5;
		r.context().strokeStyle = r.brite(this._brite);
		// Render each line
		for (var line in this._path) {
			var from = r.gtoc(this._path[line][0], this._path[line][1]);
			var to = r.gtoc(this._path[line][2], this._path[line][3]);
			// Draw a scaled line
			r.context().beginPath();
			r.context().moveTo(from.x, from.y);
			r.context().lineTo(to.x, to.y);
			r.context().stroke();
		}
	}
};function TextOverlay(scope) {
  this._scope = scope;
  this._previewMessage = '';
  this._preview = [''];
  this._formatError = false;
  this._previewLine = 6;
	this._clock = new Date();
  this._brite = 3;
	var textOverlay = this;
	setInterval(function() {
		textOverlay._clock = new Date();
	}, 1000);
}



TextOverlay.prototype.setPreviewAreaMessage = function(message) {
  this._previewMessage = message;
};

TextOverlay.prototype.clearPreviewAreaMessage = function() {
  this._previewMessage = '';
};

TextOverlay.prototype.lines = function() {
  return this._preview.length;
};

TextOverlay.prototype.formatError = function() {
  this._formatError = true;
};

TextOverlay.prototype.previewSegments = function() {
  return this._preview;
};

TextOverlay.prototype.targetSelect = function() {
  if (this._preview.length == 1) {
    var targets = this._scope._targetManager.getAllTargets(),
        target;
    for (var i in targets) {
      if (targets[i].callsign().lastIndexOf(this._preview[0]) + this._preview[0].length == targets[i].callsign().length) {
        if (target)
          return;
        else
          target = targets[i];
      }
    }
    if (target) {
      this._preview[0] = target.callsign();
      this.addPreviewChar(' ');
    }
  }
};

TextOverlay.prototype.processPreviewArea = function(aircraft, controller) {
  // if (this._preview.length == 3) {
  //   var aircraft = this._scope._trafficSimulator.getAircraftByCallsign(this._preview[0]);
  //   var command = this._preview[1];
  //   var parameter = this._preview[2];
  //   if (aircraft && !isNaN(parameter)) {
  //     switch (command) {
  //       case 'TL':
  //       case 'TR':
  //       case 'FH':
  //         if (0 <= parameter && parameter <= 360) {
  //           aircraft.assignHeading(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //       case 'CM':
  //       case 'DM':
  //         if (0 <= parameter && parameter <= 99999) {
  //           aircraft.assignAltitude(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //       case 'SPD':
  //       case 'SLOW':
  //         if (0 <= parameter && parameter <= 9999) {
  //           aircraft.assignSpeed(parameter, this._scope._trafficSimulator.elapsed(), 0);
  //           this.clearPreview();
  //           return true;
  //         }
  //         break;
  //     }
  //   }
  // } else if (this._preview.length == 1) {
  //   var command = this._preview[0],
  //       coneCommand = /^\*P\d+$/,
  //       jRingCommand = /^\*J\d+$/;
  //   if (aircraft) {
  //     if (command == 'IC') {
  //       aircraft.setController(controller);
  //       this.clearPreview();
  //       return true;
  //     } else if (command == 'TC') {
  //       aircraft.setController(null);
  //       this.clearPreview();
  //       return true;
  //     } else if (coneCommand.test(command.substr(1))) {
  //       aircraft.enableCone(parseInt(command.substr(3)));
  //       this.clearPreview();
  //       return true;
  //     } else if (jRingCommand.test(command.substr(1))) {
  //       aircraft.enableJRing(parseInt(command.substr(3)));
  //       this.clearPreview();
  //       return true;
  //     }
  //   }
  // }
  // if (this._preview[0] == '')
  //   return false;
  // else {
  //   this._formatError = true;
  //   return true;
  // }
};

TextOverlay.prototype.clearPreview = function() {
  this._preview = [''];
  this._formatError = false;
  Keyboard.MODE = Keyboard.MODES.NONE;
};

TextOverlay.prototype.keepFirstLine = function() {
  this._preview = this._preview.slice(0, 1);
  this.addPreviewChar(' ');
};

TextOverlay.prototype.addPreviewChar = function(character) {
  if (character == ' ') {
    if (this._preview[this._preview.length - 1] != '')
      this._preview.push('');
  }
  else
    this._preview[this._preview.length - 1] += character;
  this._formatError = false;
};

TextOverlay.prototype.removePreviewChar = function() {
  if (this._preview[this._preview.length - 1].length == 0) {
    this._preview.splice(this._preview.length - 1);
    if (this._preview.length == 0)
      this.clearPreview();
  }
  else
    this._preview[this._preview.length - 1] =
      this._preview[this._preview.length - 1]
        .substr(0, this._preview[this._preview.length - 1].length - 1);
  this._formatError = false;
};

TextOverlay.prototype.brite = function(color) {
  if (color === 'red')
    return 'rgb(' + Math.round(255 * this._brite / 10) + ', 0, 0)';
  return 'rgb(0, ' + Math.round(255 * this._brite / 10) + ', 0)';
};

TextOverlay.prototype.line = function(r, top, line) {
  return r.scope().height * top + line * 20;
};

TextOverlay.prototype.renderPreviewArea = function(r) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = '#0c0';
  r.context().fillText(this._formatError ? 'FORMAT' : this._previewMessage, 75, this.line(r, .14, this._previewLine - 1));
  for (var i = 0; i < this._preview.length; i++)
    r.context().fillText(this._preview[i], 75, this.line(r, .14, this._previewLine + i));
};

TextOverlay.prototype.renderTime = function(r) {
	r.context().beginPath();
	r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
	r.context().textAlign = 'left';
	r.context().textBaseline = 'top';
	r.context().fillStyle = this.brite();
	var date = this._clock;
	var hours = '' + date.getUTCHours();
	var minutes = '' + date.getUTCMinutes();
	var seconds = '' + date.getUTCSeconds();
	var timeString = (hours.length == 1 ? '0' + hours : hours) +
    (minutes.length == 1 ? '0' + minutes : minutes) + '/' +
    (seconds.length == 1 ? '0' + seconds : seconds);
	r.context().fillText(timeString, 75, this.line(r, 0.14, 0));
  // scope.facilityManager().primaryAirport(function(airport) {
  //   if (airport)
  //     r.context().fillText(airport.altimeter(), 75 + r.context().measureText(timeString + ' ').width, this.line(r, 0.14, 0));
  // }.bind(this), true);
  r.context().fillStyle = this.brite('green');
	r.context().fillText('OK/OK/NA ', 75, this.line(r, 0.14, 1));
  r.context().fillStyle = this.brite();
  // scope.facilityManager().primaryAirport(function(airport) {
  //   if (airport)
  //     r.context().fillText(airport.iata(), 75 + r.context().measureText('OK/OK/NA ').width, this.line(r, 0.14, 1));
  // }.bind(this), true);
	r.context().fillText(r.range() + 'NM PTL: -.-', 75, this.line(r, 0.14, 2));
	r.context().fillText('N99 999 U N99 999 A', 75, this.line(r, 0.14, 3));
  var airports = scope.facilityManager().airports(),
      ICAOs = Object.keys(airports);
  ICAOs.forEach(function(icao, index) {
    var airport = airports[icao];
    r.context().fillText(airport.iata() + ' ' + airport.altimeter() + ' ' + airport.windText(r), 75, this.line(r, 0.14, 4 + index));
  }.bind(this));
  this._previewLine = 6 + ICAOs.length;
};

TextOverlay.prototype.renderControllers = function(r, controllers) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  var textLeft = r.scope().width - 200;
  controllers.forEach(function(controller, line) {
    r.context().fillText(controller.getIdentifier() + ' ' + controller.getName() , textLeft, this.line(r, 0.2, line));
  }.bind(this));
};

TextOverlay.prototype.renderLACAMCI = function(r) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  var textLeft = r.scope().width - 200;
  r.context().fillText('LA/CA/MCI', textLeft, this.line(r, 0.8, 0));
  scope.targetManager().conflicts().forEach(function(conflict, i) {
    r.context().fillText(conflict + ' CA', textLeft, this.line(r, 0.8, 1 + i));
  }.bind(this));
};

TextOverlay.prototype.renderTowerList = function(r, aircraft) {
	this._scope.facilityManager().primaryAirport(function(airport) {
    if (!airport)
      return;
    var aircraftList = aircraft.concat();
    var line = 0;
    aircraftList.sort(function(a, b) {
      return a.position().distanceTo(airport.position()) -
        b.position().distanceTo(airport.position());
    });
    r.context().beginPath();
    r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
    r.context().textAlign = 'left';
    r.context().textBaseline = 'top';
    r.context().fillStyle = this.brite();
    r.context().fillText(airport.iata() + ' TOWER', 75, this.line(r, 0.45, line++));
    if (aircraftList.length > 6)
      r.context().fillText('MORE: 6/' + aircraftList.length, 75, this.line(r, 0.45, line++));
    aircraftList.splice(6);
    for (var i = 0; i < aircraftList.length; i++) {
      var callsignString = aircraftList[i].callsign();
      for (var j = 0; j < 7 - aircraftList[i].callsign().length; j++)
        callsignString += ' ';
      r.context().fillText(callsignString + ' ' +
        aircraftList[i].type(), 75, this.line(r, 0.45, line + i));
    }
  }.bind(this), true);
};

TextOverlay.prototype.renderCRDAStatus = function(r, crdaManager) {
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'top';
  r.context().fillStyle = this.brite();
  r.context().fillText('CRDA ' + (crdaManager.isEnabled() ? 'STATUS' : 'OFF'), 75, this.line(r, 0.8, 0));
  crdaManager.CRDAs().forEach(function(crda, index) {
    var line = index + 1,
        enabled = crdaManager.isEnabled() && crda.isEnabled() ? '*' : ' ';
    r.context().fillText(enabled + line + ' ' + crda.airport().iata() + ' ' +
      crda.master().id() + '/' + crda.slave().id(), 75, this.line(r, 0.8, line));
  }.bind(this));
};function PathManager() {
  this._paths = {};
  this._visiblePaths = [];
}

PathManager.ERROR = {
  PATH_NOT_FOUND: 1
};

PathManager.prototype.setPath = function(path) {
  this._paths[path.name()] = path;
};

PathManager.prototype.showPath = function(pathName) {
  if (pathName === 'ALL') {
    this._visiblePaths = Object.keys(this._paths);
    return;
  }
  for (var i in this._visiblePaths)
    if (this._visiblePaths[i] === pathName)
      return;
  if (this._paths[pathName])
    this._visiblePaths.push(pathName);
  else
    throw PathManager.ERROR.PATH_NOT_FOUND;
};

PathManager.prototype.hidePath = function(pathName) {
  if (pathName === 'ALL') {
    this._visiblePaths = [];
    return;
  }
  for (var i in this._visiblePaths)
    if (this._visiblePaths[i] === pathName) {
      this._visiblePaths.splice(i, 1);
      return;
    }
  throw PathManager.ERROR.PATH_NOT_FOUND;
};

PathManager.prototype.render = function(r) {
  for (var i in this._visiblePaths)
    new PathRenderer(this._paths[this._visiblePaths[i]]).render(r);
};function Path(name) {
  this._name = name;
  this._waypoints = [];
}

Path.prototype.addWaypoint = function(name, position) {
  this._waypoints.push({
    name: name,
    position: position
  });
};

Path.prototype.setName = function(name) {
  this._name = name;
};

Path.prototype.name = function() {
  return this._name;
};

Path.prototype.waypoints = function() {
  return this._waypoints;
};function Radar() {
  this._position;
}

Radar.prototype.setPosition = function(position) {
  this._position = position;
};

Radar.prototype.position = function() {
  return this._position;
};

Radar.prototype.sweep = function(feed, targetManager, renderFn) {
  var blips = [];//feed.blips();
  // socket.emit('radar.sweep', function(blips) {
  //   blips.forEach(function(blip) {
  //     this.sync(blip, targetManager);
  //   }.bind(this));
  //   targetManager.getAllTargets().forEach(function(target) {
  //     //this.revSync(target, feed, targetManager);
  //   }.bind(this));
  //   if (renderFn)
  //     renderFn();
  // }.bind(this));

  

  // var radials = [],
  //     currentRadial = 0;
  // for (var i = 0; i < 36; i++)
  //   radials[i] = [];
  // feed.blips().forEach(function(blip) {
  //   var radial = Math.floor(this.position().bearingTo(blip.position()) / 10);
  //     radials[radial].push(blip);
  // }.bind(this));
  // var syncNextRadial = function() {
  //   radials[currentRadial].forEach(function(blip) {
  //     this.sync(blip, targetManager);
  //     if (renderFn)
  //       renderFn();
  //   }.bind(this));
  //   currentRadial++;
  //   if (currentRadial < 36)
  //     setTimeout(syncNextRadial, 0);
  // }.bind(this);
  // syncNextRadial();
};

Radar.prototype.sync = function(blip, targetManager) {
  var target = targetManager.getTargetByCallsign(blip.callsign);
  if (target)
    target.updateFromBlip(blip);
  else {
    target = new Target();
    target.updateFromBlip(blip);
    targetManager.addTarget(target);
  }
};

Radar.prototype.revSync = function(target, feed, targetManager) {
  var blip = feed.getBlipByCallsign(target.callsign());
  if (!blip)
    targetManager.noRadarReturn(target.callsign());
};function Target(callsign) {
  this._callsign = callsign;

  this._mode;
  this._type;
  this._position;
  this._arrival;
  this._altitude;
  this._speed;
  this._squawk;
  this._controller = null;
  this._history = [];
  this._coneSize;
  this._jRingSize;

  this._isExpanded = false;
  this._isSelected = false;
  this._isInConflict = false;
  this._isDisplayingCone = false;
  this._isDisplayingJRing = false;
  this._isCoasting = false;
  this._isAwaitingPurge = false;
  this._ghostState = Target.GHOST_STATES.ENABLED;

  this._otherController = null;
  this._controlStates = {
    NORMAL: 1,
    OWNED: 2,
    INBOUND_HANDOFF: 3,
    HANDOFF: 4,
    POST_HANDOFF: 5
  };
  this._controlState = this._controlStates.NORMAL;
  this._handoffTimeout;

  this._radarReturnTimeout;

  this._modes = {
    OFF: 1,
    STANDBY: 2,
    ALTITUDE: 3,
    IDENT: 4
  };

  this._conflicts = {};
  this._conflictState = Target.CONFLICT_STATES.NONE;
}

Target.GHOST_STATES = {
  ENABLED: 1,
  FORCED: 2,
  INHIBITED: 3
};

Target.CONFLICT_STATES = {
  NONE: 1,
  CONFLICTING: 2,
  SUPPRESSED: 3,
  INHIBITED: 4
};

Target.prototype.toggleConflictAlerts = function() {
  this._conflictState = this._conflictState === Target.CONFLICT_STATES.INHIBITED ?
    Target.CONFLICT_STATES.NONE : Target.CONFLICT_STATES.INHIBITED;
};

Target.prototype.setTargetsInConflict = function(targets) {
  if (this._conflictState !== Target.CONFLICT_STATES.INHIBITED) {
    var conflicts = {};
    this._conflictState = Target.CONFLICT_STATES.NONE;
    targets.forEach(function(target) {
      var callsign = target.callsign();
      if (this._conflicts[callsign]) {
        conflicts[callsign] = this._conflicts[callsign];
        if (!conflicts[callsign]['isSuppressed'])
          this._conflictState = Target.CONFLICT_STATES.CONFLICTING;
        else if (this._conflictState !== Target.CONFLICT_STATES.CONFLICTING)
          this._conflictState = Target.CONFLICT_STATES.SUPPRESSED;
      } else {
        this._conflictState = Target.CONFLICT_STATES.CONFLICTING;
        conflicts[callsign] = {
          target: target,
          isSuppressed: false
        };
      }
    }.bind(this));
    this._conflicts = conflicts;
  } else
    this._conflicts = {};
  return this._conflictState;
};

Target.prototype.conflicts = function() {
  return this._conflicts;
};

Target.prototype.conflictState = function() {
  return this._conflictState;
};

Target.prototype.clearPostHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this.isOwned() ? this._controlStates.OWNED : this._controlStates.NORMAL;
  this.contract();
};

Target.prototype.handoff = function(toController) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = toController;
  this._controlState = this._controlStates.HANDOFF;
  this._handoffTimeout = setTimeout(function() {
    this._otherController = null;
    this._controlState = this._controlStates.OWNED;
  }.bind(this), 10 * 1000);
};

Target.prototype.acceptHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.OWNED;
  this.setController(scope.controller());
};

Target.prototype.handoffAccepted = function(byControler) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this.expand();
  this._controller = byControler;
  this._otherController = null;
  this._controlState = this._controlStates.POST_HANDOFF;
  if (scope.sounds())
    new Audio('/sounds/HandoffAccepted.wav').play();
  this._handoffTimeout = setTimeout(function() {
    this._controlState = this._controlStates.NORMAL;
    this.contract();
  }.bind(this), 10 * 1000);
};

Target.prototype.refuseHandoff = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.NORMAL;
  this.contract();
};

Target.prototype.handoffRefused = function() {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = null;
  this._controlState = this._controlStates.OWNED;
  if (scope.sounds())
    new Audio('/sounds/Error.wav').play();
};

Target.prototype.inboundHandoff = function(fromController) {
  if (this._handoffTimeout) {
    clearTimeout(this._handoffTimeout);
    delete this._handoffTimeout;
  }
  this._otherController = fromController;
  this._controlState = this._controlStates.INBOUND_HANDOFF;
  this.expand();
  if (scope.sounds())
    new Audio('/sounds/HandoffRequest.wav').play();
  this._handoffTimeout = setTimeout(function() {
    this._otherController = null;
    this._controlState = this._controlStates.NORMAL;
    this.contract();
  }.bind(this), 10 * 1000);
};

Target.prototype.assignHeading = function(heading) {
  if (0 <= heading && heading <= 360) {
    socket.emit('TS.heading', {
      callsign: this.callsign(),
      heading: heading
    });
    return true;
  }
  return false;
};

Target.prototype.assignAltitude = function(altitude) {
  if (0 <= altitude && altitude <= 99999) {
    socket.emit('TS.altitude', {
      callsign: this.callsign(),
      altitude: altitude
    });
    return true;
  }
  return false;
};

Target.prototype.assignSpeed = function(speed) {
  if (0 <= speed && speed <= 9999) {
    socket.emit('TS.speed', {
      callsign: this.callsign(),
      speed: speed
    });
    return true;
  }
  return false;
};

Target.prototype.otherController = function() {
  return this._otherController;
};

Target.prototype.updateFromBlip = function(blip) {
  this.update(blip.callsign, blip.mode, blip.type, blip.arrival, blip.position, blip.altitude, blip.speed, blip.squawk, blip.controller);
  if (this._radarReturnTimeout)
    clearTimeout(this._radarReturnTimeout);
  this._radarReturnTimeout = setTimeout(function() {
    this.noRadarReturn();
  }.bind(this), 6 * 1000);
};

Target.prototype.update = function(callsign, mode, type, arrival, position, altitude, speed, squawk, controller) {
  this.setCallsign(callsign);
  this.setMode(mode);
  this.setType(type);
  this.setArrival(arrival);
  this.setPosition(position);
  this.setAltitude(altitude);
  this.setSpeed(speed);
  this.setSquawk(squawk);

  var currentController = this.controller();
  if (!currentController || currentController.getIdentifier() !== controller)
    this.setController(scope.getControllerByIdentifier(controller));

  this.radarReturn();
};

Target.prototype.setCallsign = function(callsign) {
  this._callsign = callsign;
};

Target.prototype.setMode = function(mode) {
  this._mode = mode;
};

Target.prototype.setType = function(type) {
  this._type = type;
};

Target.prototype.setArrival = function(arrival) {
  this._arrival = arrival;
};

Target.prototype.setPosition = function(position) {
  position = new LatLon(position._lat, position._lon);
  this.addHistory(position);
  this._position = position;
};

Target.prototype.setAltitude = function(altitude) {
  this._altitude = altitude;
};

Target.prototype.setSpeed = function(speed) {
  this._speed = speed;
};

Target.prototype.setSquawk = function(squawk) {
  this._squawk = squawk;
};

Target.prototype.setController = function(controller) {
  this._controller = controller;
  if (this._controlState !== this._controlStates.POST_HANDOFF) {
    if (this.isOwned())
      this.expand();
    else
      this.contract();
  }
};

Target.prototype.addHistory = function(position) {
  this._history.unshift(position);
  if (this._history.length > 6)
    this._history.length = 6;
};

Target.prototype.callsign = function() {
  return this._callsign;
};

Target.prototype.mode = function() {
  return this._mode;
};

Target.prototype.type = function() {
  return this._type;
};

Target.prototype.arrival = function() {
  return this._arrival;
};

Target.prototype.position = function() {
  return this._position;
};

Target.prototype.altitude = function() {
  return this._altitude;
};

Target.prototype.speed = function() {
  return this._speed;
};

Target.prototype.squawk = function() {
  return this._squawk;
};

Target.prototype.controller = function() {
  return this._controller;
};

Target.prototype.history = function() {
  return this._history.slice(1);
};

Target.prototype.course = function() {
  return this.history().length ? this.history()[0].bearingTo(this.position()) : -1;
};

Target.prototype.enableCone = function(size) {
  this.disableJRing();
  this._coneSize = size;
  this._isDisplayingCone = true;
};

Target.prototype.disableCone = function() {
  this._isDisplayingCone = false;
};

Target.prototype.isDisplayingCone = function() {
  return this._isDisplayingCone;
};

Target.prototype.enableJRing = function(size) {
  this.disableCone();
  this._jRingSize = size;
  this._isDisplayingJRing = true;
};

Target.prototype.disableJRing = function() {
  this._isDisplayingJRing = false;
};

Target.prototype.isDisplayingJRing = function() {
  return this._isDisplayingJRing;
};

Target.prototype.expand = function() {
  this._isExpanded = true;
};

Target.prototype.contract = function() {
  this._isExpanded = false;
};

Target.prototype.isExpanded = function() {
  return this._isExpanded;
};

Target.prototype.demoteGhosting = function() {
  switch (this._ghostState) {
    case Target.GHOST_STATES.ENABLED:
      this._ghostState = Target.GHOST_STATES.INHIBITED;
      break;
    case Target.GHOST_STATES.FORCED:
      this._ghostState = Target.GHOST_STATES.ENABLED;
      break;
  }
};

Target.prototype.promoteGhosting = function() {
  switch (this._ghostState) {
    case Target.GHOST_STATES.INHIBITED:
      this._ghostState = Target.GHOST_STATES.ENABLED;
      break;
    case Target.GHOST_STATES.ENABLED:
      this._ghostState = Target.GHOST_STATES.FORCED;
      break;
  }
};

Target.prototype.ghostState = function() {
  return this._ghostState;
};

Target.prototype.select = function() {
  this._isSelected = true;
  if (!this.isExpanded()) {
    this.expand();
    setTimeout(function() {
      if (!this.isOwned())
        this.contract();
    }.bind(this), 3000);
  }
  if (this._controlState === this._controlStates.POST_HANDOFF)
    this.clearPostHandoff();
  if (this._conflictState === Target.CONFLICT_STATES.CONFLICTING) {
    this._conflictState = Target.CONFLICT_STATES.SUPPRESSED;
    for (var i in this._conflicts) {
      this._conflicts[i].isSuppressed = true;
      this._conflicts[i].target.conflicts()[this.callsign()].isSuppressed = true;
    }
  }
};

Target.prototype.deselect = function() {
  this._isSelected = false;
};

Target.prototype.isSelected = function() {
  return this._isSelected;
};

Target.prototype.inConflict = function() {
  this._isInConflict = true;
};

Target.prototype.notInConflict = function() {
  this._isInConflict = false;
};

Target.prototype.isInConflict = function() {
  return this._isInConflict;
};

Target.prototype.coast = function() {
  this._isCoasting = true;
};

Target.prototype.uncoast = function() {
  this._isCoasting = false;
};

Target.prototype.isCoasting = function() {
  return this._isCoasting;
};

Target.prototype.radarReturn = function() {
  this.uncoast();
  this.cancelPurge();
};

Target.prototype.noRadarReturn = function() {
  if (this.controller() && !this.isCoasting()) {
    this.coast();
    var purgeTrack = setTimeout(function() {
      scope.targetManager().purgeTarget(this);
    }.bind(this), 30000);
  }
  if (!this.controller())
    return scope.targetManager().purgeTarget(this);
  if (this.isCoasting())
    this.coastPosition();
  this._radarReturnTimeout = setTimeout(function() {
    this.noRadarReturn();
  }.bind(this), 5 * 1000);
};

Target.prototype.coastPosition = function() {
  var history = this.history();
  if (history.length > 0) {
    var previousDistance = history[0].distanceTo(this.position());
    var newEstimatedPosition = this.position().destinationPoint(this.course(), previousDistance);
    this.setPosition(newEstimatedPosition);
  }
};

Target.prototype.awaitPurge = function() {
  this._isAwaitingPurge = true;
};

Target.prototype.cancelPurge = function() {
  this._isAwaitingPurge = false;
};

Target.prototype.isAwaitingPurge = function() {
  return this._isAwaitingPurge;
};

Target.prototype.isOwned = function() {
  return this.isControlled() && this.controller() === scope.controller();
};

Target.prototype.isControlled = function() {
  return this.controller() !== null;
};

Target.prototype.isUndergoingHandoff = function() {
  return this._controlState === this._controlStates.HANDOFF;
};

Target.prototype.isUndergoingInboundHandoff = function() {
  return this._controlState === this._controlStates.INBOUND_HANDOFF;
};function TargetManager() {
  this._targets = [];
  this._airlines = {};
  this._callsigns = {};

  this._conflicts = [];

  this._alarmSounding = false;
  this._alarm = new Audio('/sounds/ConflictAlert.wav');

  this._targetPurger = setInterval(this.purgeTargets.bind(this), 5 * 1000);
}

TargetManager.SEPARATION_MINIMA = [
  {
    anchor: null,
    radius: null,
    minAltitude: null,
    maxAltitude: 17999,
    lateral: 3,
    vertical: 1000
  },
  {
    anchor: null,
    radius: null,
    minAltitude: 18000,
    maxAltitude: null,
    lateral: 5,
    vertical: 1000
  }
];

TargetManager.prototype.select = function(x, y, r) {
  var targets = this.getAllTargets(),
      selectedTarget = null,
      i = 0;
  for (i; i < targets.length; i++) {
    targets[i].deselect();
    var coordinates = r.gtoc(targets[i].position()._lat, targets[i].position()._lon);
    var dx = coordinates.x - x;
    var dy = coordinates.y - y;
    var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
    if (distance < 15) {
      selectedTarget = targets[i];
      selectedTarget.select();
      //this._cde.muteAircraft(selectedTarget, targets);
      break;
    }
  }
  for (i = i + 1; i < targets.length; i++)
    targets[i].deselect();
  return selectedTarget;
};

TargetManager.prototype.getAllTargets = function() {
  return this._targets;
};

TargetManager.prototype.getAllOwnedTargets = function() {
  return this.getAllTargets().filter(function(target) {
    return target.controller() !== null && target.controller() === scope.controller();
  });
};

TargetManager.prototype.getTargetsByController = function(controller) {
  var targetsByController = [];
  this._targets.forEach(function(target) {
    if (target.controller() === controller)
      targetsByController.push(target);
  });
  return targetsByController;
};

TargetManager.prototype.getTargetsByAirline = function(airline) {
  var targetsByAirline = [];
  this._targets.forEach(function(target) {
    if (target.callsign().substr(0, 3) === airline)
      targetsByAirline.push(target);
  });
  return targetsByAirline;
};

TargetManager.prototype.getOwnedTargetsByAirline = function(airline) {
  return this.getTargetsByAirline(airline).filter(function(target) {
    return target.controller() !== null && target.controller() === scope.controller();
  });
};

TargetManager.prototype.massHandoff = function(fromController, toController) {
  this.getTargetsByController(fromController).forEach(function(target) {
    target.setController(toController);
  });
};

TargetManager.prototype.getTargetByCallsign = function(callsign) {
  for (var i = 0; i < this._targets.length; i++) {
    if (this._targets[i].callsign() === callsign)
      return this._targets[i];
  }
  return null;
};

TargetManager.prototype.manageAlarm = function(alarmShouldSound) {
  if (alarmShouldSound && scope.sounds()) {
    if (!this._alarmSounding) {
      this._alarmSounding = true;
      this._alarm.loop = true;
      this._alarm.play();
    }
  } else if (this._alarmSounding) {
    this._alarmSounding = false;
    this._alarm.pause();
  }
};

TargetManager.prototype.classifyMinima = function(localTarget, foreignTarget) {
  var minima = {
    lateral: 0,
    vertical: 0
  };
  for (var i in TargetManager.SEPARATION_MINIMA) {
    var m = TargetManager.SEPARATION_MINIMA[i];
    if (
      (m.lateral > minima.lateral ||
        m.vertical > m.vertical) &&
      (!m.anchor ||
        m.anchor) &&
      (!m.minAltitude ||
        (localTarget.altitude() >= m.minAltitude ||
          foreignTarget.altitude() >= m.minAltitude)) &&
      (!m.maxAltitude ||
        (localTarget.altitude() <= m.maxAltitude ||
          foreignTarget.altitude() <= m.maxAltitude))
    ) {
      minima.lateral = Math.max(m.lateral, minima.lateral);
      minima.vertical = Math.max(m.vertical, minima.vertical);
    }
  }
  return minima;
};

TargetManager.prototype.isInConflict = function(localTarget, foreignTarget) {
  var minima = this.classifyMinima(localTarget, foreignTarget);
  if (Math.abs(localTarget.altitude() - foreignTarget.altitude()) >= minima.vertical)
    return false;
  if (localTarget.position().distanceTo(foreignTarget.position()) * 0.539957 >= minima.lateral)
    return false;
  return true;
};

TargetManager.prototype.detectConflicts = function() {
  var targets = this.getAllTargets(),
      conflicts = Array(targets.length),
      alarmShouldSound = false;
  this._conflicts = [];
  for (var i = 0; i < targets.length; i++) {
    var localTarget = targets[i];
    if (localTarget.conflictState() !== Target.CONFLICT_STATES.INHIBITED) {
      for (var j = i + 1; j < targets.length; j++) {
        var foreignTarget = targets[j];
        if (foreignTarget.conflictState() !== Target.CONFLICT_STATES.INHIBITED) {
          if (this.isInConflict(localTarget, foreignTarget)) {
            if (localTarget.callsign() < foreignTarget.callsign())
              this._conflicts.push(localTarget.callsign() + '*' + foreignTarget.callsign());
            else
              this._conflicts.push(foreignTarget.callsign() + '*' + localTarget.callsign());
            if (conflicts[i])
              conflicts[i].push(foreignTarget);
            else
              conflicts[i] = [foreignTarget];
            if (conflicts[j])
              conflicts[j].push(localTarget);
            else
              conflicts[j] = [localTarget];
          }
        }
      }
    }
  }
  this._conflicts.sort();
  targets.forEach(function(target, index) {
    if (!conflicts[index])
      conflicts[index] = [];
    if (target.setTargetsInConflict(conflicts[index]) ===
        Target.CONFLICT_STATES.CONFLICTING)
      alarmShouldSound = true;
  });
  this.manageAlarm(alarmShouldSound);
};

TargetManager.prototype.conflicts = function() {
  return this._conflicts;
};

TargetManager.prototype.purgeTarget = function(target) {
  for (var i = 0; i < this._targets.length; i++) {
    var t = this._targets[i];
    if (t === target) {
      this._targets.splice(i, 1);
      return;
    }
  }
};

TargetManager.prototype.purgeTargets = function() {
  var purged = false;
  for (var i = 0; i < this._targets.length; i++) {
    var target = this._targets[i];
    if (target.isAwaitingPurge()) {
      purged = true;
      this._targets.splice(i, 1);
      i--;
    }
  }
  if (purged)
    this.updateCallsigns();
};

TargetManager.prototype.noRadarReturn = function(callsign) {
  for (var i = 0; i < this._targets.length; i++) {
    var target = this._targets[i];
    if (target.callsign() === callsign) {
      target.noRadarReturn();
      if (target.isAwaitingPurge())
        this._targets.splice(i, 1);
      return;
    }
  }
};

TargetManager.prototype.addTarget = function(target) {
  this._targets.push(target);
  this.updateCallsigns();
};

TargetManager.prototype.reset = function() {
  this._targets = [];
  this.updateCallsigns();
};

TargetManager.prototype.updateCallsigns = _.throttle(function() {
  var airlines = {};
  this._targets.forEach(function(target) {
    airlines[target.callsign().substr(0, 3)] = true;
  });
  $.get('https://localhost:8080/api/callsigns', {
    airlines: Object.keys(airlines)
  }, function(callsigns) {
    var airlines = {};
    for (var i in callsigns)
      airlines[callsigns[i].toUpperCase()] = i.toUpperCase();
    this._airlines = airlines;
    this._callsigns = callsigns;
  }.bind(this));
}, 1000, {
  leading: false
});

TargetManager.prototype.callsigns = function() {
  return Object.keys(this._airlines);
};

TargetManager.prototype.getAirlineByCallsign = function(callsign) {
  return this._airlines[callsign];
};

TargetManager.prototype.getCallsignByAirline = function(airline) {
  return this._callsigns[airline];
};

TargetManager.prototype.render = function(r) {
  var elapsedRenderer = r.elapsed(),
      targets = this.getAllTargets(),
      targetsInRange = [];
  this.detectConflicts();
  for (var a in targets)
    if (r.inBounds(targets[a].position()._lat, targets[a].position()._lon))
      targetsInRange.push(new TargetRenderer(targets[a]));
  for (var b in targetsInRange)
    targetsInRange[b].renderHistory(r);
  for (var c in targetsInRange)
    targetsInRange[c].renderExtras(r);
  for (var d in targetsInRange)
    targetsInRange[d].renderTarget(r);
  for (var e in targetsInRange)
    targetsInRange[e].renderPosition(r, elapsedRenderer);
  for (var f in targetsInRange)
    targetsInRange[f].renderDataBlock(r, elapsedRenderer);
};function Scope(socket) {
	this._socket = socket;
	this._maps = {};
	this._airports = {};
	// this._trafficSimulator = new TrafficSimulator;
	this._targetManager = new TargetManager();
	this._facilityManager = new FacilityManager();
	//this._mapManager = new MapManager(this);
	this._controller = null;
  this._controllers = [];
	//this._feed = new Feed;
	this._radar = new Radar();

	//this._situation = new Situation;
	this._renderer = new Renderer();
	this._compass = new Compass();
	this._textOverlay = new TextOverlay(this);
	this._flow = new Flow();
	this._pathManager = new PathManager();

	this._radarManager = null;
	this._isOn = false;

  this._CRDAManager = new CRDAManager();
  this._sounds = true;

	this._measureDistanceStartPosition = null;
	this._renderPoints = [];
	//this._renderPaths = [];
	this._renderPointsBlinker = new Date().getTime();
	//this._weatherOverlay = new WeatherOverlay;

	/*var self = this;
	setTimeout(function() {
		self._weatherOverlay.refresh(self._renderer);
	}, 5000);*/
}

// Situation.prototype.detectAndRenderConflicts = function() {
// 	if (this._conflictsEnabled) {
// 		this._cde.detect(this._aircraft);
// 		for (var i in this._aircraft)
// 			this._aircraft[i].setConflicting(this._cde.singleAircraftInConflict(this._aircraft[i]));
// 		this._cde.manageAlarm();
// 	}
// };

Scope.prototype.radar = function() {
  return this._radar;
};

Scope.prototype.setControllers = function(controllers) {
  controllers.sort(function(a, b) {
    if (a.getIdentifier() < b.getIdentifier())
      return -1;
    else
      return 1;
  }.bind(this));
  if (this._controller) {
    this._controllers = [this._controller];
    controllers.forEach(function(controller) {
      if (controller.getIdentifier() !== this._controller.getIdentifier())
        this._controllers.push(controller);
    }.bind(this));
  } else
    this._controllers = controllers;
};

Scope.prototype.getControllerByIdentifier = function(identifier) {
  for (var i in this._controllers)
    if (this._controllers[i].getIdentifier() === identifier)
      return this._controllers[i];
  return null;
};

Scope.prototype.controllers = function() {
  return this._controllers;
};

Scope.prototype.setControllerPosition = function(position, cb) {
  if (!this._controller) {
    this._socket.emit('ATC.addController', {
      position: position
    }, function(data) {
      this.setController(new Controller(data.position, data.targetCode, data.identifier, data.name, '199.98', null));
      if (cb)
        cb();
    }.bind(this));
  } else {
    this._socket.emit('ATC.deleteController', function() {
      this._targetManager.massHandoff(this._controller, null);
      this.setController(null);
      this.setControllerPosition(position, cb);
    }.bind(this));
  }
};

Scope.prototype.sounds = function() {
  return this._sounds;
};

Scope.prototype.setController = function(controller) {
	this._controller = controller;
};

Scope.prototype.controller = function() {
  return this._controller;
};

Scope.prototype.facilityManager = function() {
	return this._facilityManager;
};

Scope.prototype.CRDAManager = function() {
	return this._CRDAManager;
};

Scope.prototype.turnOn = function() {
	if (!this._isOn) {
		this._isOn = true;

		var batchRender = _.throttle(this.render.bind(this), 200);
		socket.on('blip', function(blip) {
			this._radar.sync(blip, this._targetManager);
			batchRender();
    }.bind(this));

		// this._radarManager = setInterval(function() {
		// 	this._radar.sweep(this._trafficSimulator, this._targetManager, this.render.bind(this));
		// }.bind(this), 5000);
		// this._radar.sweep(this._trafficSimulator, this._targetManager, this.render.bind(this));
	}
};

Scope.prototype.turnOff = function() {
	if (this._isOn) {
		this._isOn = false;
		clearInterval(this._radarManager);
		this._targetManager.reset();
	}
};

Scope.prototype.targetManager = function() {
	return this._targetManager;
};

Scope.prototype.pathManager = function() {
	return this._pathManager;
};

Scope.prototype.select = function(e) {
	var offset = $(e.target).offset(),
			x = e.clientX - offset.left,
			y = e.clientY - offset.top;
	return this._targetManager.select(x, y, this._renderer);
};

Scope.prototype.selectPosition = function(e) {
	var offset = $(e.target).offset(),
			x = e.clientX - offset.left,
			y = e.clientY - offset.top,
			target = this._targetManager.select(x, y, this._renderer);
	if (target)
		return target.position();
	else {
		var position = this._renderer.ctop(x, y);
		return position;
	}
};

Scope.prototype.measureHeadingAndDistance = function(e) {
	if (this._measureDistanceStartPosition) {
		var endPosition = this.selectPosition(e),
				heading = Math.round(this._measureDistanceStartPosition.bearingTo(endPosition) - this._renderer.magVar()) % 360,
				distance = this._measureDistanceStartPosition.distanceTo(endPosition) * 0.539957;
		this._measureDistanceStartPosition = null;
		return {
			heading: this._renderer.pad(heading, 3, true),
			distance: distance.toFixed(2)
		};
	} else {
		this._measureDistanceStartPosition = this.selectPosition(e);
		return null;
	}
};

Scope.prototype.addRenderPoint = function(position) {
	this._renderPoints.push(position);
};

Scope.prototype.clearRenderPoints = function() {
	this._renderPoints = [];
};

Scope.prototype.addRenderPath = function(path) {
	this._renderPaths.push(path);
};

Scope.prototype.clearRenderPaths = function() {
	this._renderPaths = [];
};

Scope.prototype.bind = function(scope) {
	this._renderer.bind(scope);
};

Scope.prototype.addAirport = function(airport) {
  this._airports[airport.icao()] = airport;
};

Scope.prototype.airport = function(icao) {
  return this._airports[icao];
};

Scope.prototype.addMap = function(id, name, map, callback) {
	this._maps[id] = new Map(id, name, map, this._renderer, callback);
};

Scope.prototype.enableSmartMap = function() {
	this._maps['SMART'] = new SmartMap('SMART', '', this);
};

Scope.prototype.setSituation = function(situation) {
	//this._situation = typeof situation == 'string' ? new Situation(situation) : situation;
};

Scope.prototype.maps = function() {
	return this._maps;
};

Scope.prototype.map = function(id) {
	return this._maps[id];
};

Scope.prototype.situation = function() {
	//return this._situation;
};

Scope.prototype.renderer = function() {
	return this._renderer;
};

Scope.prototype.compass = function() {
	return this._compass;
};

Scope.prototype.textOverlay = function() {
	return this._textOverlay;
};

Scope.prototype.fit = function() {
	this._renderer.scope().width = $(window).width() - ($('.situation-controls').is(':visible') ? 250 : 0);
	this._renderer.scope().height = $(window).height() - ($('.scope-settings').is(':visible') ? 54 : 0);
};

Scope.prototype.renderBackground = function() {
	this._renderer.context().fillStyle = this._renderer.background();
	this._renderer.context().strokeStyle = this._renderer.brite(this._compass._brite);
	this._renderer.context().lineWidth = 1;
	this._renderer.context().fillRect(0, 0, this._renderer.scope().width, this._renderer.scope().height);
	this._renderer.context().strokeRect(0, 0, this._renderer.scope().width, this._renderer.scope().height);
};

Scope.prototype.renderRangeRings = function() {
	this._renderer.context().moveTo();
};

Scope.prototype.renderOverlays = function() {
	this._textOverlay.renderTime(this._renderer, this._airports);
	this._textOverlay.renderTowerList(this._renderer, this.targetManager().getAllTargets());
	this._textOverlay.renderLACAMCI(this._renderer);
	this._textOverlay.renderCRDAStatus(this._renderer, this.CRDAManager());
	this._textOverlay.renderPreviewArea(this._renderer);
  this._textOverlay.renderControllers(this._renderer, this._controllers);
};

Scope.prototype.renderRenderPoints = function() {
	if (this._renderPoints.length) {
		var color = (new Date().getTime() - this._renderPointsBlinker) % 1000 < 667 ? '#0c0' : '#060';
		for (var i in this._renderPoints) {
			var pos = this._renderer.gtoc(this._renderPoints[i]._lat, this._renderPoints[i]._lon);
			this._renderer.context().beginPath();
			this._renderer.context().moveTo(pos.x - 3, pos.y - 3);
			this._renderer.context().lineTo(pos.x + 3, pos.y - 3);
			this._renderer.context().lineTo(pos.x + 3, pos.y + 3);
			this._renderer.context().lineTo(pos.x - 3, pos.y + 3);
			this._renderer.context().fillStyle = color;
			this._renderer.context().fill();
		}
	}
};

Scope.prototype.render = function() {
	this.fit();
	this.renderBackground();
	this._compass.render(this._renderer);
	for (var i in this._maps)
		this._maps[i].render(this._renderer);
	this._flow.render(this._renderer);
	this._pathManager.render(this._renderer);
	//this._weatherOverlay.render(this._renderer);
	//this._situation.render(this._renderer);
	//this.detectAndRenderConflicts();
	this.renderRenderPoints();
  this.renderOverlays();
  if (this._CRDAManager.isEnabled())
    this._CRDAManager.ghostTargets(this._targetManager, this._renderer);
	this._targetManager.render(this._renderer);
};
function SmartMap(id, name, scope) {
  this._id = id;
  this._name = name;
  this._scope = scope;
  this._brite = 5;
  this._enabled = false;
  this._primaryAirport = null;
  this._paths = [];
  this._pathsByType = {
    RUNWAY: [],
    LOCALIZER: [],
    COASTLINE: [],
    FIX: [],
    NAVAID: []
  };
  this._yields = {
    RUNWAY: [],
    LOCALIZER: [],
    NAVAID: [],
    FIX: [],
    COASTLINE: [
      'RUNWAY',
      'LOCALIZER'
    ]
  };
  this.configure();
}

SmartMap.prototype.id = function() {
  return this._id;
};

SmartMap.prototype.name = function() {
  return this._name;
};

SmartMap.prototype.enabled = function() {
  return this._enabled;
};

SmartMap.prototype.toggle = function() {
  this._enabled = !this._enabled;
};

SmartMap.prototype.setBrite = function(brite) {
  this._brite = brite;
};

SmartMap.prototype.configure = function() {
  this._scope.facilityManager().primaryAirport(function(airport) {
    this._scope.renderer().setMagVar(airport.magVar());
    this._primaryAirport = airport;
    this.generatePrimaryAirport();
    this.generateCoastline();
    //this.generateFixes();
    this.generateNavaids();
    this._enabled = true;
  }.bind(this));
};

SmartMap.prototype.generatePrimaryAirport = function() {
  this.generateRunwayPairs(this._primaryAirport);
  this.generateLocalizers(this._primaryAirport);
};

SmartMap.prototype.generateRunwayPairs = function(airport) {
  var runwayPairs = airport.runwayPairs();
  for (var i in runwayPairs)
    this.generateRunwayPair(runwayPairs[i]);
};

SmartMap.prototype.generateRunwayPair = function(runwayPair) {
  this.layer([runwayPair[0].position(), runwayPair[1].position()], 'RUNWAY');
};

SmartMap.prototype.generateLocalizers = function(airport) {
  var runways = airport.runways();
  for (var i in runways) {
    var runway = runways[i];
    if (runway.hasILS())
      this.generateLocalizer(runway);
  }
};

SmartMap.prototype.generateLocalizer = function(runway) {
  var position = runway.position(),
      course = (runway.course() + 180) % 360;
  for (var i = 1; i < 25; i +=2) {
    var start = position.destinationPoint(course, i * 1.852),
        end = position.destinationPoint(course, (i + 1) * 1.852);
    this.layer([start, end], 'LOCALIZER');
  }
  for (var d = 5; d <= 15; d += 5) {
    var tickBase = position.destinationPoint(course, d * 1.852),
        tickStart = tickBase.destinationPoint(course - 90, 0.6 * 1.852),
        tickEnd = tickBase.destinationPoint(course + 90, 0.6 * 1.852);
    this.layer([tickStart, tickEnd], 'LOCALIZER');
  }
};

SmartMap.prototype.generateCoastline = function() {
  $.get('/api/coastline', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(paths) {
    for (var i in paths) {
      var path = paths[i];
      this.layer([new LatLon(path[0], path[1]), new LatLon(path[2], path[3])], 'COASTLINE');
    }
  }.bind(this));
};

SmartMap.prototype.generateFixes = function() {
  $.get('/api/fixes', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(fixes) {
    for (var i in fixes) {
      var fix = fixes[i],
          fixPos = new LatLon(fix.lat, fix.lon);
      this.layer([fixPos, fixPos.destinationPoint(Math.random() * 360, 1)], 'FIX');
    }
  }.bind(this));
};

SmartMap.prototype.generateNavaids = function() {
  $.get('/api/navaids', {
    lat: this._primaryAirport.lat(),
    lon: this._primaryAirport.lon(),
    radius: 60
  }, function(navaids) {
    for (var i in navaids) {
      var navaid = navaids[i],
          navaidPos = new LatLon(navaid.lat, navaid.lon);

      var pts = [];
      for (var p = 0; p < 12; p++)
        pts.push(navaidPos.destinationPoint(p * 30, 0.7));
      pts.push(pts[0]);
      this.layer(pts, 'NAVAID');
    }
  }.bind(this));
};

SmartMap.prototype.layer = function(path, type) {
  var r = this._scope.renderer(),
      yields = this._yields[type];
  for (var i in yields) {
    var yieldPaths = this._pathsByType[yields[i]];
    for (var j in yieldPaths) {
      var yieldPath = yieldPaths[j];
      for (var p in yieldPath) {
        var yieldPoint = yieldPath[p];
        for (var n in path) {
          var point = path[n];
          if (point.distanceTo(yieldPoint) * 0.539957 < 0.5)
            return;
        }
      }
    }
  }
  this._pathsByType[type].push(path);
  this._paths.push(path);
  r.setMinLat(Math.min(r.minLat(), path[0]._lat, path[1]._lat));
  r.setMinLon(Math.min(r.minLon(), path[0]._lon, path[1]._lon));
  r.setMaxLat(Math.max(r.maxLat(), path[0]._lat, path[1]._lat));
  r.setMaxLon(Math.max(r.maxLon(), path[0]._lon, path[1]._lon));
  var scopeCorner = new LatLon(r.minLat(), r.minLon()),
      scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
  r.setMidLat(scopeMidpoint._lat);
  r.setMidLon(scopeMidpoint._lon);
};

SmartMap.prototype.render = function(r) {
  if (this._enabled) {
    r.context().lineWidth = 1.5;
    r.context().strokeStyle = r.brite(this._brite);
    for (var i in this._paths) {
      var path = this._paths[i],
          startPoint = r.gtoc(path[0]._lat, path[0]._lon);
      r.context().beginPath();
      r.context().moveTo(startPoint.x, startPoint.y);
      for (var j = 1; j < path.length; j ++) {
        var nextPoint = r.gtoc(path[j]._lat, path[j]._lon);
        r.context().lineTo(nextPoint.x, nextPoint.y);
      }
      r.context().stroke();
    }
  }
};

// SmartMap.prototype.generateRunwayPair = function(runwayPair) {
//   this.addLine(this._scope.renderer(), 'runways', [runwayPair[0].position()._lat, runwayPair[0].position()._lon, runwayPair[1].position()._lat, runwayPair[1].position()._lon]);
//   for (var i = 0; i < 2; i++) {
//     if (runwayPair[i].hasILS()) {
//       var runwayPosition = runwayPair[i].position(),
//         backcourse = runwayPair[1 - i].position().bearingTo(runwayPosition);
//       this.generateLocalizer(runwayPosition, backcourse);
//     }
//   }
// };

// SmartMap.prototype.generateLocalizer = function(position, course) {
//   for (var i = 1; i < 25; i +=2) {
//     var start = position.destinationPoint(course, i * 1.852),
//         end = position.destinationPoint(course, (i + 1) * 1.852);
//     this._path.runways.push([start._lat, start._lon, end._lat, end._lon]);
//   }
//   for (var d = 5; d <= 15; d += 5) {
//     var tickBase = position.destinationPoint(course, d * 1.852),
//         tickStart = tickBase.destinationPoint(course - 90, 0.6 * 1.852),
//         tickEnd = tickBase.destinationPoint(course + 90, 0.6 * 1.852);
//     this.addLine(this._scope.renderer(), 'runways', [tickStart._lat, tickStart._lon, tickEnd._lat, tickEnd._lon]);
//   }
// };

// SmartMap.prototype.addLine = function(r, category, line) {
//   r.setMinLat(Math.min(r.minLat(), line[0], line[2]));
//   r.setMinLon(Math.min(r.minLon(), line[1], line[3]));
//   r.setMaxLat(Math.max(r.maxLat(), line[0], line[2]));
//   r.setMaxLon(Math.max(r.maxLon(), line[1], line[3]));
//   this._path[category].push(line);
// };

// SmartMap.prototype.update = function() {
//   if (!this._loadedPrimaryAirport) {
//     this._loadedPrimaryAirport = true;
//     this._scope.facilityManager().primaryAirport(function(airport) {
//       if (airport) {
//         var r = this._scope.renderer(),
//             runwayPairs = airport.runwayPairs();
//         r.setMagVar(airport.magVar());
//         for (var i in runwayPairs) {
//           var pair = runwayPairs[i];
//           this.generateRunwayPair(pair);
//         }
//         var scopeCorner = new LatLon(r.minLat(), r.minLon()),
//             scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
//         r.setMidLat(scopeMidpoint._lat);
// //         r.setMidLon(scopeMidpoint._lon);

//         $.get('/api/coastline', {
//           lat: airport.lat(),
//           lon: airport.lon(),
//           radius: 30
//         }, function(lines) {
//           if (lines.length) {
//             for (var i in lines) {
//               var line = lines[i];
//               var canDraw = true;
//               for (var p in this._path.runways) {
//                 var avoidLine = this._path.runways[p];
//                 for (var s = 0; s < 2; s++) {
//                   var point = new LatLon(avoidLine[2 * s], avoidLine[2 * s + 1]);
//                   if (point.distanceTo(new LatLon(line[0], line[1])) * 0.539957 < 0.5 || point.distanceTo(new LatLon(line[2], line[3])) * 0.539957 < 0.5) {
//                     canDraw = false;
//                     break;
//                   }
//                 }
//               }
//               if (canDraw) {
//                 this.addLine(r, 'coastline', line);
//               }
//             }
//             var scopeCorner = new LatLon(r.minLat(), r.minLon()),
//                 scopeMidpoint = scopeCorner.midpointTo(new LatLon(r.maxLat(), r.maxLon()));
//             r.setMidLat(scopeMidpoint._lat);
//             r.setMidLon(scopeMidpoint._lon);
//           }
//         }.bind(this));
//       }
//     }.bind(this));
// //   }
// // };

// // SmartMap.prototype.render = function(r) {
// //   if (this._enabled) {
// //     this.update();
// //     r.context().lineWidth = 1.5;

// //     r.context().strokeStyle = 'rgb(100, 100, 100)';
// //     // Render each line
// //     for (var line in this._path.coastline) {
// //       var from = r.gtoc(this._path.coastline[line][0], this._path.coastline[line][1]);
// //       var to = r.gtoc(this._path.coastline[line][2], this._path.coastline[line][3]);
// //       // Draw a scaled line
// //       r.context().beginPath();
// //       r.context().moveTo(from.x, from.y);
// //       r.context().lineTo(to.x, to.y);
// //       r.context().stroke();
// //     }

// //     r.context().strokeStyle = 'rgb(100, 100, 100)';
// //     // Render each line
// //     for (var line in this._path.runways) {
// //       var from = r.gtoc(this._path.runways[line][0], this._path.runways[line][1]);
// //       var to = r.gtoc(this._path.runways[line][2], this._path.runways[line][3]);
// //       // Draw a scaled line
// //       r.context().beginPath();
// //       r.context().moveTo(from.x, from.y);
// //       r.context().lineTo(to.x, to.y);
// //       r.context().stroke();
// //     }
// //   }
// // };
function Renderer() {
	this._created = new Date().getTime();
	this._targetHistory = true;
	this._last = this._created;
	this._scope;
	this._context;
	this._background = '#000';
	this._magVar = 0;
	this._minLat = 90;
	this._minLon = 180;
	this._midLat = 0;
	this._midLon = 0;
	this._maxLat = -90;
	this._maxLon = -180;
	this._globalScale = 1.0;
	this._radarCenter = {};
	this._translation = {
		lastMousePosition: {
			x: 0,
			y: 0,
		},
		offset: {
			x: 0,
			y: 0
		}
	};
	this._presets = [];
	this._mouseDown = false;
}

Renderer.prototype.bind = function(scope) {
	this._scope = $(scope)[0];
	this._context = this._scope.getContext('2d');
};

Renderer.prototype.scope = function() {
	return this._scope;
};

Renderer.prototype.context = function() {
	return this._context;
};

Renderer.prototype.inBounds = function(lat, lon) {
	var pos = this.gtoc(lat, lon);
	return pos.x >= 0 && pos.y >= 0 && pos.x <= this._scope.width && pos.y <= this._scope.height;
};

Renderer.prototype.elapsed = function() {
	return new Date().getTime() - this._created;
};

Renderer.prototype.enableTargetHistory = function() {
	this._targetHistory = true;
};

Renderer.prototype.disableTargetHistory = function() {
	this._targetHistory = false;
};

Renderer.prototype.targetHistory = function() {
	return this._targetHistory;
};

Renderer.prototype.setMinLat = function(minLat) {
	this._minLat = minLat;
};

Renderer.prototype.setMinLon = function(minLon) {
	this._minLon = minLon;
};

Renderer.prototype.setMidLat = function(midLat) {
	this._midLat = midLat;
};

Renderer.prototype.setMidLon = function(midLon) {
	this._midLon = midLon;
};

Renderer.prototype.setMaxLat = function(maxLat) {
	this._maxLat = maxLat;
};

Renderer.prototype.setMaxLon = function(maxLon) {
	this._maxLon = maxLon;
};

Renderer.prototype.minLat = function() {
	return this._minLat;
};

Renderer.prototype.minLon = function() {
	return this._minLon;
};

Renderer.prototype.midLat = function() {
	return this._midLat;
};

Renderer.prototype.midLon = function() {
	return this._midLon;
};

Renderer.prototype.maxLat = function() {
	return this._maxLat;
};

Renderer.prototype.maxLon = function() {
	return this._maxLon;
};

Renderer.prototype.scope = function() {
	return this._scope;
};

Renderer.prototype.context = function() {
	return this._context;
};

Renderer.prototype.background = function() {
	return this._background;
};

Renderer.prototype.radarCenter = function() {
	var lat, lon;
	if (this._radarCenter.lat) {
		lat = this._radarCenter.lat;
		lon = this._radarCenter.lon;
	} else {
		lat = this._midLat;
		lon = this._midLon;
	}
	return this.gtoc(lat, lon);
};

Renderer.prototype.radarCenterPosition = function() {
	var lat, lon;
	if (this._radarCenter.lat) {
		lat = this._radarCenter.lat;
		lon = this._radarCenter.lon;
	} else {
		lat = this._midLat;
		lon = this._midLon;
	}
	return new LatLon(lat, lon);
};

Renderer.prototype.setRadarCenter = function(position) {
	this._radarCenter = {
		lat: position._lat,
		lon: position._lon
	};
};

Renderer.prototype.magVar = function() {
	return this._magVar;
};

Renderer.prototype.setMagVar = function(magVar) {
	this._magVar = magVar;
};

Renderer.prototype.globalScale = function() {
	return this._globalScale;
};

Renderer.prototype.setGlobalScale = function(globalScale) {
	this._globalScale = globalScale;
};

Renderer.prototype.lastMousePosition = function() {
	return this._translation.lastMousePosition;
};

Renderer.prototype.setLastMousePosition = function(lastMousePosition) {
	this._translation.lastMousePosition = lastMousePosition;
};

Renderer.prototype.translationOffset = function() {
	return this._translation.offset;
};

Renderer.prototype.setTranslationOffset = function(translationOffset) {
	this._translation.offset = translationOffset;
};

Renderer.prototype.mouseDown = function() {
	return this._mouseDown;
};

Renderer.prototype.setMouseDown = function(mouseDown) {
	if (mouseDown && !this._mouseDown)
		this._dragging = false;
	this._mouseDown = mouseDown;
};

Renderer.prototype.dragging = function() {
	this._dragging = true;
};

Renderer.prototype.wasDragging = function() {
	return this._dragging;
};

Renderer.prototype.latRange = function() {
	return this._maxLat - this._minLat;
};

Renderer.prototype.lonRange = function() {
	return this._maxLon - this._minLon;
};

Renderer.prototype.scaledLatRange = function(lat) {
	return this.latRange() * (1 / Math.cos(lat / 180 * Math.PI));
};

Renderer.prototype.multiplier = function(lat) {
	return this._scope.height / this.scaledLatRange(lat);
};

Renderer.prototype.scaleX = function(lat, lon) {
	return this.gtoc(lat, lon).x;
};

Renderer.prototype.scaleY = function(lat, lon) {
	return this.gtoc(lat, lon).y;
};

Renderer.prototype.brite = function(brite) {
	return '#' + brite * 111;
};

Renderer.prototype.rotate = function(x, y, cx, cy, theta) {
	var rx = x - cx;
	var ry = y - cy;
	theta *= -1;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry));
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry));

	var mx = fx + cx;
	var my = fy + cy;

	return {
		x: mx,
		y: my
	};
};

Renderer.staticRotate = function(x, y, cx, cy, theta) {
	var rx = x - cx;
	var ry = y - cy;
	theta *= -1;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry));
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry));

	var mx = fx + cx;
	var my = fy + cy;

	return {
		x: mx,
		y: my
	};
};

Renderer.prototype.gtoc = function(lat, lon) {
	var multiplier = this.multiplier(lat);
	var tx = (multiplier * (lon - this._minLon)) + this._scope.width / 2 - (this.lonRange() * multiplier) / 2;
	var ty = this._scope.height - (multiplier * (1 / Math.cos(lat / 180 * Math.PI)) * (lat - this._minLat));

	var rx = tx - this._scope.width / 2;
	var ry = this._scope.height / 2 - ty;
	var theta = this._magVar / 180 * Math.PI;

	var fx = ((Math.cos(theta) * rx - Math.sin(theta) * ry)) * this._globalScale + this._translation.offset.x * this._globalScale;
	var fy = ((Math.sin(theta) * rx + Math.cos(theta) * ry)) * this._globalScale + this._translation.offset.y * this._globalScale;

	var mx = fx + this._scope.width / 2;
	var my = this._scope.height / 2 - fy;

	return {
		x: mx,
		y: my
	};
};

Renderer.prototype.ctop = function(x, y) {
	var fy = this._scope.height / 2 - y;
	var fx = x - this._scope.width / 2;
	
	var bry = (fy - this._translation.offset.y * this._globalScale) / this._globalScale;
	var brx = (fx - this._translation.offset.x * this._globalScale) / this._globalScale;

	var theta = this._magVar / 180 * Math.PI;
	var ry = (Math.cos(theta) * bry - Math.sin(theta) * brx) /
		(Math.pow(Math.sin(theta), 2) + Math.pow(Math.cos(theta), 2));
	var rx = (bry - Math.cos(theta) * ry) / Math.sin(theta);

	var ty = this._scope.height / 2 - ry;
	var tx = rx + this._scope.width / 2;

	var lat = (this.latRange() * (this._scope.height - ty) + this._scope.height * this._minLat) / this._scope.height;
	var multiplier = this._scope.height * Math.cos(lat / 180 * Math.PI) / this.latRange();
	var lon = (2 * tx - this._scope.width + 2 * this._minLon * multiplier + this.lonRange() * multiplier) / (2 * multiplier);
	
	return new LatLon(lat, lon);
};

Renderer.prototype.distanceToPixels = function(position, course, distance) {
	var pos = this.gtoc(position._lat, position._lon),
			dest = position.destinationPoint(course, distance / 0.539957),
			nPos = this.gtoc(dest._lat, dest._lon);
	return Math.sqrt(Math.pow(nPos.x - pos.x, 2) + Math.pow(nPos.y - pos.y, 2));
};

Renderer.prototype.range = function() {
	var scale = this.distanceToPixels(new LatLon(this._midLat, this._midLon), 0, 1);
	return Math.round(this._scope.height / scale);
};

Renderer.prototype.setPreset = function(slot) {
	this._presets[slot] = {
		scale: this._globalScale,
		translation: {
			x: this._translation.offset.x,
			y: this._translation.offset.y
		}
	};
};

Renderer.prototype.selectPreset = function(slot) {
	var preset = this._presets[slot];
	if (preset) {
		this._globalScale = preset.scale;
		this._translation.offset = preset.translation;
	}
};

Renderer.prototype.scale = function(value) {
	return value / this._globalScale;
};

Renderer.prototype.adjustForMagVar = function() {
	this._context.translate(this._scope.width / 2, this._scope.height / 2);
	this._context.rotate(-this._magVar / 180 * Math.PI);
	this._context.translate(-this._scope.width / 2, -this._scope.height / 2);
};

Renderer.prototype.pad = function (string, length, heading) {
	s = string == 0 && heading ? 360 : string;
	var s = "00000" + s;
  	return s.substr(s.length - length);
};

Renderer.prototype.angleBetweenHeadings = function(primaryHeading, secondaryHeading) {
  var gap = Math.abs(primaryHeading - secondaryHeading);
  return Math.min(gap, 360 - gap);
};

Renderer.prototype.angleBetween = function(ax, ay, bx, by) {
	// y's are flipped because the positive direction in HTML canvas is down
	return Math.atan2((ay - by), (bx - ax));
};function TargetRenderer(target) {
  this._target = target;
}


/*****************/
/** CLASS LEVEL **/
/*****************/

TargetRenderer.DIRECTION = {
  N: 0.00 * Math.PI,
  NE: 0.25 * Math.PI,
  E: 0.50 * Math.PI,
  SE: 0.75 * Math.PI,
  S: 1.00 * Math.PI,
  SW: 1.25 * Math.PI,
  W: 1.50 * Math.PI,
  NW: 1.75 * Math.PI
};

TargetRenderer.setLeaderLength = function(length) {
  console.log(length);
  TargetRenderer.LEADER_LENGTH = Math.min(Math.max(parseInt(length, 10), 0), 7);
  console.log(TargetRenderer.LEADER_LENGTH);
};

TargetRenderer.setLeaderDirection = function(directionString) {
  if (directionString in TargetRenderer.DIRECTION)
    TargetRenderer.LEADER_DIRECTION = TargetRenderer.DIRECTION[directionString];
};

TargetRenderer.getLeaderDirectionString = function() {
  for (var key in TargetRenderer.DIRECTION)
    if (TargetRenderer.DIRECTION[key] === TargetRenderer.LEADER_DIRECTION)
      return key;
};

TargetRenderer.LEADER_LENGTH = 3;
TargetRenderer.LEADER_DIRECTION = TargetRenderer.DIRECTION.N;
TargetRenderer.LEADER_TIP_OFFSET = {
  length: TargetRenderer.LEADER_LENGTH,
  direction: TargetRenderer.LEADER_DIRECTION
};

TargetRenderer.getLeaderTipOffset = function() {
  return Renderer.staticRotate(0, TargetRenderer.LEADER_LENGTH * 15, 0, 0, TargetRenderer.LEADER_DIRECTION);
};

/********************/
/** INSTANCE LEVEL **/
/********************/

TargetRenderer.prototype.renderDataBlockColor = function(elapsed) {
  if (this._target._controlState === this._target._controlStates.INBOUND_HANDOFF ||
    this._target._controlState === this._target._controlStates.POST_HANDOFF)
    return elapsed % 1000 < 500 ? '#fff' : '#bbb';
  else if (this._target._controlState === this._target._controlStates.POST_HANDOFF)
    return elapsed % 1000 < 500 ? '#0c0' : '#080';
  else if (this._target.isOwned())
    return '#fff';
  else
    return '#0c0';
};

TargetRenderer.prototype.renderCone = function(r) {
  if (this._target.course() == -1)
    return;
  if (this._target.isDisplayingCone()) {
    var magCourse = this._target.course() - r.magVar(),
        len = r.distanceToPixels(this._target.position(), this._target.course(), this._target._coneSize),
        width = len / 12,
        pos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
        theta = -magCourse * Math.PI / 180,
        maxLeft = r.rotate(-width / 2, -len, 0, 0, theta),
        maxRight = r.rotate(width / 2, -len, 0, 0, theta),
        distanceLabel = r.rotate(0, -len / 2, 0, 0, theta);
    r.context().beginPath();
    r.context().font = 'bold 14px Oxygen Mono';
    r.context().textAlign = 'center';
    r.context().textBaseline = 'middle';
    r.context().fillStyle = '#369';
    r.context().fillText('' + this._target._coneSize, pos.x + distanceLabel.x, pos.y + distanceLabel.y);
    var tWidth = r.context().measureText('' + this._target._coneSize).width / 2,
        tHeight = 6,
        minX = Math.min(pos.x + maxLeft.x, pos.x + maxRight.x, pos.x),
        maxX = Math.max(pos.x + maxLeft.x, pos.x + maxRight.x, pos.x),
        minY = Math.min(pos.y + maxLeft.y, pos.y + maxRight.y, pos.y),
        maxY = Math.max(pos.y + maxLeft.y, pos.y + maxRight.y, pos.y);
    r.context().save();
    r.context().beginPath();
    r.context().moveTo(minX, minY);
    r.context().lineTo(pos.x + distanceLabel.x, minY);
    r.context().lineTo(pos.x + distanceLabel.x, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x - tWidth - 4, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x - tWidth - 4, pos.y + distanceLabel.y + tHeight + 4);
    r.context().lineTo(pos.x + distanceLabel.x + tWidth + 4, pos.y + distanceLabel.y + tHeight + 4);
    r.context().lineTo(pos.x + distanceLabel.x + tWidth + 4, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x, pos.y + distanceLabel.y - tHeight - 4);
    r.context().lineTo(pos.x + distanceLabel.x, minY);
    r.context().lineTo(maxX, minY);
    r.context().lineTo(maxX, maxY);
    r.context().lineTo(minX, maxY);
    r.context().lineTo(minX, minY);
    r.context().clip();
    r.context().strokeStyle = '#369';
    r.context().lineWidth = 1;
    r.context().beginPath();
    r.context().moveTo(pos.x, pos.y);
    r.context().lineTo(pos.x + maxLeft.x, pos.y + maxLeft.y);
    r.context().lineTo(pos.x + maxRight.x, pos.y + maxRight.y);
    r.context().lineTo(pos.x, pos.y);
    r.context().stroke();
    r.context().restore();
  }
};

TargetRenderer.prototype.renderJRing = function(r) {
  if (this._target.isDisplayingJRing()) {
    var pos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
        radius = r.distanceToPixels(this._target.position(), this._target.course(), this._target._jRingSize);
    r.context().strokeStyle = '#369';
    r.context().lineWidth = 1;
    r.context().beginPath();
    r.context().arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    r.context().stroke();
    r.context().beginPath();
    r.context().font = 'bold 14px Oxygen Mono';
    r.context().textAlign = 'center';
    r.context().textBaseline = 'bottom';
    r.context().fillStyle = '#369';
    r.context().fillText('' + this._target._jRingSize, pos.x, pos.y + radius);
  }
};

TargetRenderer.prototype.renderExtras = function(r) {
  this.renderJRing(r);
  this.renderCone(r);

  // if (this._target.callsign() === 'ICE98') {
  //   var ACTIVE_LEGS = [
  //     {
  //       startPosition: new LatLon(42.53728102399617, -69.99036947154653),
  //       endPosition: new LatLon(42.44679377265025, -70.47755508601381)
  //     },
  //     {
  //       startPosition: new LatLon(42.44679377265025, -70.47755508601381),
  //       endPosition: new LatLon(42.52755728169469, -70.61846177278272)
  //     },
  //     {
  //       startPosition: new LatLon(42.52755728169469, -70.61846177278272),
  //       endPosition: new LatLon(42.72859260197211, -70.48297467454829)
  //     }
  //   ];

  //   r.context().strokeStyle = 'orange';
  //   r.context().lineWidth = 2;
  //   for (var i in ACTIVE_LEGS) {
  //     var start = r.gtoc(ACTIVE_LEGS[i].startPosition._lat, ACTIVE_LEGS[i].startPosition._lon);
  //     var end = r.gtoc(ACTIVE_LEGS[i].endPosition._lat, ACTIVE_LEGS[i].endPosition._lon);
  //     r.context().beginPath();
  //     r.context().moveTo(start.x, start.y);
  //     r.context().lineTo(end.x, end.y);
  //     r.context().stroke();
  //   }
  // }
};

TargetRenderer.prototype.renderHistory = function(r) {
  if (r.targetHistory()) {
    r.context().fillStyle = '#26c';
    for (var i in this._target.history()) {
      var historyPos = r.gtoc(this._target.history()[i]._lat, this._target.history()[i]._lon);
      r.context().beginPath();
      r.context().arc(historyPos.x, historyPos.y, 2.5 - Math.floor((i - 1) / 4), 0, 2 * Math.PI);
      r.context().globalAlpha = 0.5 - (i - 1) / 10;
      r.context().fill();
    }
    r.context().globalAlpha = 1;
  }
};

TargetRenderer.prototype.renderTarget = function(r) {
  if (this._target.isCoasting())
    return;
  // Determine size of beacon based on distance from radar site
  var radarDistance = r.radarCenterPosition().distanceTo(this._target.position()) * 0.539957,
      beaconWidth = (Math.min(Math.max(radarDistance, 5), 40) - 5) / 35 * 2.5 + 0.5,
      acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      radarCenter = r.radarCenter(),
      theta = r.angleBetween(acPos.x, acPos.y, radarCenter.x, radarCenter.y) + Math.PI / 2,
      unit = r.distanceToPixels(this._target.position(), 0, 0.01),
      width = r.distanceToPixels(this._target.position(), 0, 0.25),
      bHeight = Math.max(beaconWidth * width, 4.5),
      bWidth = Math.max(width, 3);
  // Draw the beacon line
  var lineL = r.rotate(-bHeight * 2, 0, 0, 0, theta);
  var lineR = r.rotate(bHeight * 2, 0, 0, 0, theta);
  r.context().beginPath();
  r.context().moveTo(acPos.x + lineL.x, acPos.y + lineL.y);
  r.context().lineTo(acPos.x + lineR.x, acPos.y + lineR.y);
  r.context().strokeStyle = '#1e582f';
  r.context().lineWidth = Math.max(1.5, unit);
  r.context().stroke();
  // Draw the beacon target
  var boxBL = r.rotate(-bHeight, 0, 0, 0, theta);
  var boxTL = r.rotate(-bHeight, bWidth, 0, 0, theta);
  var boxTR = r.rotate(bHeight, bWidth, 0, 0, theta);
  var boxBR = r.rotate(bHeight, 0, 0, 0, theta);
  r.context().beginPath();
  r.context().moveTo(acPos.x + boxBL.x, acPos.y + boxBL.y);
  r.context().lineTo(acPos.x + boxTL.x, acPos.y + boxTL.y);
  r.context().lineTo(acPos.x + boxTR.x, acPos.y + boxTR.y);
  r.context().lineTo(acPos.x + boxBR.x, acPos.y + boxBR.y);
  r.context().fillStyle = '#2d82ed';
  r.context().fill();
};

TargetRenderer.prototype.renderPosition = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      targetCode = this._target.isControlled() ? this._target.controller().getTargetCode() : '*';
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'center';
  r.context().textBaseline = 'middle';
  r.context().strokeStyle = '#000';
  r.context().lineWidth = 2;
  r.context().strokeText(targetCode, acPos.x, acPos.y);
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  r.context().fillText(targetCode, acPos.x, acPos.y);
};

TargetRenderer.prototype.renderPartialDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the target altitude and speed
  r.context().beginPath();
  r.context().imageSmoothingEnabled= false;
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var scopeSpeed = Math.floor(this._target.speed() / 10);
  var scopeAltitude = Math.floor(this._target.altitude() / 100);
  r.context().fillText(r.pad(scopeAltitude, 3) + '  ' + r.pad(scopeSpeed, 2), acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - leaderTipOffset.y);
  r.context().imageSmoothingEnabled = true;
};

TargetRenderer.prototype.renderFullDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the target callsign
  r.context().beginPath();
  r.context().imageSmoothingEnabled= false;
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var callsignText = this._target.callsign();
  if (this._target.conflictState() === Target.CONFLICT_STATES.INHIBITED)
    callsignText += ' ' + String.fromCharCode(parseInt('25B3', 16));
  r.context().fillText(callsignText, acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - leaderTipOffset.y);
  r.context().imageSmoothingEnabled = true;
  // Draw the target aircraft, altitude, and speed data block
  r.context().beginPath();
  r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
  r.context().textAlign = 'left';
  r.context().textBaseline = 'middle';
  r.context().fillStyle = this.renderDataBlockColor(elapsed);
  var scopeSpeed = Math.floor(this._target.speed() / 10),
      scopeAltitude = Math.floor(this._target.altitude() / 100),
      scopeText,
      otherController = this._target.otherController(),
      spacing = otherController ? otherController.getIdentifier() : '  ';
  if (this._target.isCoasting())
    scopeText = 'CST' + spacing + (elapsed % 4000 < 2000 ? r.pad(scopeSpeed, 2) : this._target.type());
  else
    scopeText = elapsed % 4000 < 2000 ? r.pad(scopeAltitude, 3) + spacing + r.pad(scopeSpeed, 2) : this._target.arrival() + spacing + this._target.type();
  r.context().fillText(scopeText, acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - (leaderTipOffset.y - 17));
};

TargetRenderer.prototype.renderConflictAlert = function(r) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  if (this._target.conflictState() === Target.CONFLICT_STATES.CONFLICTING ||
      this._target.conflictState() === Target.CONFLICT_STATES.SUPPRESSED) {
    r.context().beginPath();
    r.context().font = 'bold ' + 14 + 'px Oxygen Mono';
    r.context().textAlign = 'left';
    r.context().textBaseline = 'middle';
    r.context().fillStyle = '#f00';
    r.context().fillText('CA', acPos.x + leaderTipOffset.x + 5, acPos.y - 10 - (leaderTipOffset.y + 17));
  }
};

TargetRenderer.prototype.renderDataBlock = function(r, elapsed) {
  var acPos = r.gtoc(this._target.position()._lat, this._target.position()._lon),
      leaderTipOffset = TargetRenderer.getLeaderTipOffset();
  // Draw the leader line
  r.context().beginPath();
  r.context().moveTo(acPos.x, acPos.y + -10);
  r.context().lineTo(acPos.x + leaderTipOffset.x, acPos.y - 10 - leaderTipOffset.y);
  r.context().lineWidth = 1;
  r.context().strokeStyle = this.renderDataBlockColor(elapsed);
  r.context().stroke();
  if (this._target.isExpanded())
    this.renderFullDataBlock(r, elapsed);
  else
    this.renderPartialDataBlock(r, elapsed);
  this.renderConflictAlert(r);
};function PathRenderer(path) {
  this._path = path;
}

PathRenderer.prototype.render = function(r) {
  var waypoints = this._path.waypoints(),
      pos;

  r.context().fillStyle = '#0c0';
  r.context().strokeStyle = '#0c0';
  r.context().lineJoin = 'round';
  r.context().textBaseline = 'center';
  r.context().textAlign = 'center';
  r.context().font = 10 + 'px Oxygen Mono';

  pos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().strokeStyle = '#030';
  r.context().lineWidth = 4;
  r.context().beginPath();
  r.context().moveTo(pos.x, pos.y);
  for (var i = 1; i < waypoints.length; i++) {
    pos = r.gtoc(waypoints[i].position._lat, waypoints[i].position._lon);
    r.context().lineTo(pos.x, pos.y);
  }
  r.context().stroke();

  pos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().strokeStyle = '#0c0';
  r.context().lineWidth = 4;
  r.context().beginPath();
  r.context().setLineDash([25, 1000]);
  r.context().lineDashOffset = -r.elapsed() % 1025;
  r.context().moveTo(pos.x, pos.y);
  for (var j = 1; j < waypoints.length; j++) {
    pos = r.gtoc(waypoints[j].position._lat, waypoints[j].position._lon);
    r.context().lineTo(pos.x, pos.y);
  }
  r.context().stroke();
  r.context().setLineDash([]);

  var startPos = r.gtoc(waypoints[0].position._lat, waypoints[0].position._lon);
  r.context().beginPath();
  r.context().arc(startPos.x, startPos.y, 4, 0, 2 * Math.PI);
  r.context().fill();

  if (waypoints.length > 1) {
    var endPos = r.gtoc(waypoints[waypoints.length - 1].position._lat,
          waypoints[waypoints.length - 1].position._lon),
        afterStartPos = r.gtoc(waypoints[1].position._lat, waypoints[1].position._lon),
        beforeEndPos = r.gtoc(waypoints[waypoints.length - 2].position._lat,
          waypoints[waypoints.length - 2].position._lon),
        startOrientation = startPos.y < afterStartPos.y ? 1 : -1,
        endOrientation = endPos.y < beforeEndPos.y ? 1 : -1;

    r.context().fillText(this._path.name(), startPos.x, startPos.y - 12 * startOrientation);

    r.context().beginPath();
    r.context().arc(endPos.x, endPos.y, 4, 0, 2 * Math.PI);
    r.context().fill();
  } else {
    r.context().fillText(this._path.name(), startPos.x, startPos.y - 12);
  }
};var Keyboard = Keyboard || {};

Keyboard.COMBO_KEYS = {
  NONE: 0,
  ALT: 1 << 0,
  CTRL: 1 << 1,
  SHIFT: 1 << 2,
  CMD: 1 << 3
};

Keyboard.combo = function(e) {
  var combo = Keyboard.COMBO_KEYS.NONE;
  if (e.altKey)
    combo |= Keyboard.COMBO_KEYS.ALT;
  if (e.ctrlKey)
    combo |= Keyboard.COMBO_KEYS.CTRL;
  if (e.shiftKey)
    combo |= Keyboard.COMBO_KEYS.SHIFT;
  if (e.metaKey)
    combo |= Keyboard.COMBO_KEYS.CMD;
  return combo;
};

Keyboard.KEYS = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESCAPE: 27,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT_ARROW: 37,
  UP_ARROW: 38,
  RIGHT_ARROW: 39,
  DOWN_ARROW: 40,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  LEFT_WINDOW_KEY: 91,
  RIGHT_WINDOW_KEY: 92,
  SELECT_KEY: 93,
  NUMPAD_0: 96,
  NUMPAD_1: 97,
  NUMPAD_2: 98,
  NUMPAD_3: 99,
  NUMPAD_4: 100,
  NUMPAD_5: 101,
  NUMPAD_6: 102,
  NUMPAD_7: 103,
  NUMPAD_8: 104,
  NUMPAD_9: 105,
  MULTIPLY: 106,
  ADD: 107,
  SUBTRACT: 109,
  DECIMAL_POINT: 110,
  DIVIDE: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUM_LOCK: 144,
  SCROLL_LOCK: 145,
  SEMICOLON: 186,
  EQUAL_SIGN: 187,
  COMMA: 188,
  DASH: 189,
  PERIOD: 190,
  FORWARD_SLASH: 191,
  GRAVE_ACCENT: 192,
  OPEN_BRACKET: 219,
  BACK_SLASH: 220,
  CLOSE_BRACKET: 221,
  SINGLE_QUOTE: 222
};

Keyboard.KEYS.MULTIFUNC = Keyboard.KEYS.F7;

Keyboard.MODES = {
  NONE: 1,
  MULTIFUNC: 2
};

Keyboard.MODE = Keyboard.MODES.NONE;

Keyboard[Keyboard.KEYS.ESCAPE] = {};
Keyboard[Keyboard.KEYS.ESCAPE][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
};

Keyboard[Keyboard.KEYS.F3] = {};
Keyboard[Keyboard.KEYS.F3][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('IC');
};

Keyboard[Keyboard.KEYS.F4] = {};
Keyboard[Keyboard.KEYS.F4][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('TC');
};

Keyboard[Keyboard.KEYS.MULTIFUNC] = {};
Keyboard[Keyboard.KEYS.MULTIFUNC][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('F');
  Keyboard.MODE = Keyboard.MODES.MULTIFUNC;
};

Keyboard[Keyboard.KEYS.F11] = {};
Keyboard[Keyboard.KEYS.F11][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().clearPreview();
  scope.textOverlay().addPreviewChar('CA');
};

Keyboard[Keyboard.KEYS.S] = {};
Keyboard[Keyboard.KEYS.S][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.scope-settings').toggle();
};

Keyboard[Keyboard.KEYS.M] = {};
Keyboard[Keyboard.KEYS.M][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.situation-controls').toggle();
  if ($('.situation-controls').is(':visible')) {
    $(scope.renderer().scope()).css('margin-left', '250px');
    $('.scope-settings').css('margin-left', '250px');
  } else {
    $(scope.renderer().scope()).css('margin-left', '0');
    $('.scope-settings').css('margin-left', '0');
  }
};

Keyboard[Keyboard.KEYS.R] = {};
Keyboard[Keyboard.KEYS.R][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  //scope.situation().run();
};

Keyboard[Keyboard.KEYS.T] = {};
Keyboard[Keyboard.KEYS.T][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  $('.incoming-messages').toggle();
};


Keyboard[Keyboard.KEYS.P] = {};
Keyboard[Keyboard.KEYS.P][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  //scope.situation().pause();
};

Keyboard[Keyboard.KEYS.ONE] = {};
Keyboard[Keyboard.KEYS.ONE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(1);
};
Keyboard[Keyboard.KEYS.ONE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(1);
};

Keyboard[Keyboard.KEYS.TWO] = {};
Keyboard[Keyboard.KEYS.TWO][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(2);
};
Keyboard[Keyboard.KEYS.TWO][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(2);
};

Keyboard[Keyboard.KEYS.THREE] = {};
Keyboard[Keyboard.KEYS.THREE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(3);
};
Keyboard[Keyboard.KEYS.THREE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(3);
};

Keyboard[Keyboard.KEYS.FOUR] = {};
Keyboard[Keyboard.KEYS.FOUR][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(4);
};
Keyboard[Keyboard.KEYS.FOUR][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(4);
};

Keyboard[Keyboard.KEYS.FIVE] = {};
Keyboard[Keyboard.KEYS.FIVE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(5);
};
Keyboard[Keyboard.KEYS.FIVE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(5);
};

Keyboard[Keyboard.KEYS.SIX] = {};
Keyboard[Keyboard.KEYS.SIX][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(6);
};
Keyboard[Keyboard.KEYS.SIX][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(6);
};

Keyboard[Keyboard.KEYS.SEVEN] = {};
Keyboard[Keyboard.KEYS.SEVEN][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(7);
};
Keyboard[Keyboard.KEYS.SEVEN][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(7);
};

Keyboard[Keyboard.KEYS.EIGHT] = {};
Keyboard[Keyboard.KEYS.EIGHT][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(8);
};
Keyboard[Keyboard.KEYS.EIGHT][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(8);
};

Keyboard[Keyboard.KEYS.NINE] = {};
Keyboard[Keyboard.KEYS.NINE][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(9);
};
Keyboard[Keyboard.KEYS.NINE][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(9);
};

Keyboard[Keyboard.KEYS.ZERO] = {};
Keyboard[Keyboard.KEYS.ZERO][Keyboard.COMBO_KEYS.CTRL | Keyboard.COMBO_KEYS.ALT] = function(e) {
  scope.renderer().setPreset(0);
};
Keyboard[Keyboard.KEYS.ZERO][Keyboard.COMBO_KEYS.CTRL] = function(e) {
  scope.renderer().selectPreset(0);
};

Keyboard[Keyboard.KEYS.BACKSPACE] = {};
Keyboard[Keyboard.KEYS.BACKSPACE][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().removePreviewChar();
};

Keyboard[Keyboard.KEYS.ADD] = {};
Keyboard[Keyboard.KEYS.ADD][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().targetSelect();
};

Keyboard[Keyboard.KEYS.TAB] = {};
Keyboard[Keyboard.KEYS.TAB][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().targetSelect();
};

Keyboard[Keyboard.KEYS.ENTER] = {};
Keyboard[Keyboard.KEYS.ENTER][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().processPreviewArea(null, scope._controller);
};

Keyboard[Keyboard.KEYS.LEFT_ARROW] = {};
Keyboard[Keyboard.KEYS.LEFT_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('TL');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('L');
      break;
  }
};

Keyboard[Keyboard.KEYS.RIGHT_ARROW] = {};
Keyboard[Keyboard.KEYS.RIGHT_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('TR');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('R');
      break;
  }
};

Keyboard[Keyboard.KEYS.UP_ARROW] = {};
Keyboard[Keyboard.KEYS.UP_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('CM');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('C');
      break;
  }
};

Keyboard[Keyboard.KEYS.DOWN_ARROW] = {};
Keyboard[Keyboard.KEYS.DOWN_ARROW][Keyboard.COMBO_KEYS.NONE] = function(e) {
  switch (scope.textOverlay().lines()) {
    case 2:
      scope.textOverlay().addPreviewChar('DM');
      scope.textOverlay().addPreviewChar(' ');
      break;
    case 3:
      scope.textOverlay().addPreviewChar('C');
      break;
  }
};

Keyboard[Keyboard.KEYS.DECIMAL_POINT] = {};
Keyboard[Keyboard.KEYS.DECIMAL_POINT][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('SPD');
  scope.textOverlay().addPreviewChar(' ');
};

Keyboard[Keyboard.KEYS.EQUAL_SIGN] = {};
Keyboard[Keyboard.KEYS.EQUAL_SIGN][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('ILS');
  scope.textOverlay().addPreviewChar(' ');
};

Keyboard[Keyboard.KEYS.EQUAL_SIGN] = {};
Keyboard[Keyboard.KEYS.EQUAL_SIGN][Keyboard.COMBO_KEYS.NONE] = function(e) {
  scope.textOverlay().addPreviewChar('ILS');
  scope.textOverlay().addPreviewChar(' ');
};var Command = Command || {};

Command.ERROR = {
  FORMAT: 0,
  TAKE_NO_ACTION: 1
};

Command.SEGMENT_TYPE = {
  PLACEHOLDER: 0,
  CALLSIGN: 0,
  HEADING: 0,
  ALTITUDE: 0,
  SPEED: 0,
  SECTOR: 0,
  RUNWAY: 0,
  PATH_NAME: 0,
  PATH_FIXES: 0
};

Command.SEGMENT = {
  ILS: 'ILS',
  VISUAL_APPROACH: 'VA',
  INITIATE_CONTROL: 'IC',
  TERMINATE_CONTROL: 'TC',
  FLY_HEADING: 'FH',
  MAINTAIN_ALTITUDE: 'MA',
  SPEED: 'SPD',
  DRAW_PATH: 'DRAWPATH',
  TYPE_PATH: 'TYPEPATH',
  SHOW_PATH: 'SHOWPATH',
  HIDE_PATH: 'HIDEPATH',
  RELOCATE_TARGET: 'RELOCATE',
  MEASURE_DISTANCE: '*',
  SHOW_COORDINATES: 'FD*',
  TOGGLE_CONFLICT_ALERTS: 'CAK',
  MANAGE_CRDA: 'FN',
  CLEAR_JRING: '*J',
  CLEAR_ALL_JRINGS: '**J',
  CLEAR_CONE: '*P',
  CLEAR_ALL_CONES: '**P'
};

Command.SEGMENT_RAW = {
  ILS: true,
  VA: true,
  IC: true,
  TC: true,
  FH: true,
  MA: true,
  SPD: true,
  TYPE_PATH: true,
  FIXPATH: true,
  '*': true,
  'FD*': true,
  CAK: true,
  FN: true,
  '*J': true,
  '**J': true,
  '*P': true,
  '**P': true,
  RELOCATE: 'true'
};

Command.ALIAS = {
  TL: Command.SEGMENT.FLY_HEADING,
  TR: Command.SEGMENT.FLY_HEADING,
  CM: Command.SEGMENT.MAINTAIN_ALTITUDE,
  DM: Command.SEGMENT.MAINTAIN_ALTITUDE,
  SLOW: Command.SEGMENT.SPEED,
  DP: Command.SEGMENT.DRAW_PATH,
  TP: Command.SEGMENT.TYPE_PATH,
  SP: Command.SEGMENT.SHOW_PATH,
  HP: Command.SEGMENT.HIDE_PATH,
  RELOC: Command.SEGMENT.RELOCATE_TARGET
};

Command.currentCommand = [];
Command.lastCommand = [];

Command.cleanupFunction = null;

Command.clickable = function(e) {
  if (e.type !== 'click')
    throw Command.ERROR.FORMAT;
};

Command.enterable = function(e) {
  if (e.type === 'click')
    throw Command.ERROR.FORMAT;
};

Command.registerCleanupFunction = function(fn, skipOnCurrent) {
  Command.cleanup(skipOnCurrent);
  Command.cleanupFunction = fn;
};

Command.cleanup = function(skipOnCurrent) {
  Command.clearCleanupTimeout();
  if (Command.cleanupFunction) {
    if (!skipOnCurrent || JSON.stringify(Command.currentCommand) !== JSON.stringify(Command.lastCommand))
      Command.cleanupFunction();
    Command.cleanupFunction = null;
    scope.render();
  }
};

Command.cleanupTimeout = null;

Command.clearCleanupTimeout = function() {
  if (Command.cleanupTimeout) {
    clearTimeout(Command.cleanupTimeout);
    Command.cleanupTimeout = null;
  }
};

Command.cleanupIn = function(milliseconds) {
  Command.clearCleanupTimeout();
  Command.cleanupTimeout = setTimeout(function() {
    Command.cleanup();
    Command.clearCleanupTimeout();
  }, milliseconds);
};

Command.run = function(e, args) {
  var fn = Command.manualProcess(e, args),
      command = [];
  if (!fn) {
    for (var i in args) {
      arg = args[i];
      if (!Command.SEGMENT_RAW[arg])
        arg = Command.ALIAS[arg] || Command.SEGMENT_TYPE.PLACEHOLDER;
      command.push(arg);
    }
    fn = Command;
    for (var j in command) {
      fn = fn[command[j]] || Command.manualProcess(e, args);
      if (!fn)
        scope.textOverlay().formatError();
    }
  }
  Command.currentCommand = command;
  try {
    fn(e, args);
    scope.textOverlay().clearPreview();
  } catch (err) {
    switch (err) {
      case Command.ERROR.FORMAT:
        scope.textOverlay().formatError();
        break;
    }
  }
  Command.lastCommand = command;
};

Command.manualProcess = function(e, args) {
  var command = args[0],
      emptySelect = /^$/,
      coneCommand = /^\*P(\d{1,2}(\.\d|))$/,
      jRingCommand = /^\*J(\d{1,2}(\.\d|))$/,
      addRemoveCRDACommand = /^FN([A-Z]{3,4})(\d{2}[A-Z]{0,1})\/(\d{2}[A-Z]{0,1})$/,
      toggleCRDACommand = /^FN(\d)$/;
  if (command.length === 2) {
    var controller = scope.getControllerByIdentifier(command);
    if (controller) {
      return function(e, args) {
        if (e.type === 'click') {
          var target = scope.select(e);
          if (target) {
            if (target.isUndergoingHandoff()) {
              scope.textOverlay().setPreviewAreaMessage('ILL TRK');
              Command.registerCleanupFunction(function() {
                scope.textOverlay().clearPreviewAreaMessage();
              });
            } else {
              socket.emit('ATC.requestHandoff', {
                controller: scope.controller().getIdentifier(),
                to: command,
                aircraft: target.callsign()
              }, function(success) {
                if (!success) {
                  scope.textOverlay().setPreviewAreaMessage('ILL TRK');
                  Command.registerCleanupFunction(function() {
                    scope.textOverlay().clearPreviewAreaMessage();
                  });
                } else
                  target.handoff(controller);
              });
            }
            return;
          }
        }
        throw Command.ERROR.FORMAT;
      };
    }
  }
  switch (true) {
    case emptySelect.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var target = scope.select(e);
          if (target && target.isUndergoingInboundHandoff()) {
            socket.emit('ATC.acceptHandoff', {
              controller: target.otherController().getIdentifier(),
              to: scope.controller().getIdentifier(),
              aircraft: target.callsign()
            }, function(success) {
              if (success) {
                target.acceptHandoff();
              } else {
                scope.textOverlay().setPreviewAreaMessage('ILL TRK');
                Command.registerCleanupFunction(function() {
                  scope.textOverlay().clearPreviewAreaMessage();
                });
              }
            });
          }
        }
      };
    case coneCommand.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var result = coneCommand.exec(command),
              dist = parseFloat(result[1]);
          if (dist < 1 || dist > 30)
            throw Command.ERROR.FORMAT;
          var aircraft = scope.select(e);
          if (aircraft) {
            aircraft.enableCone(dist);
          }
        }
      };
    case jRingCommand.test(command):
      return function(e, args) {
        if (e.type === 'click') {
          var result = jRingCommand.exec(command),
              dist = parseFloat(result[1]);
          if (dist < 1 || dist > 30)
            throw Command.ERROR.FORMAT;
          var aircraft = scope.select(e);
          if (aircraft) {
            aircraft.enableJRing(dist);
          }
        }
      };
    case addRemoveCRDACommand.test(command):
      return function(e, args) {
        Command.enterable(e);
        var result = addRemoveCRDACommand.exec(command),
            icao = result[1].length === 3 ? 'K' + result[1] : result[1],
            master = result[2],
            slave = result[3];
        scope.facilityManager().airport(icao, function(airport) {
          if (airport) {
            try {
              scope.CRDAManager().addRemoveCRDA(airport, master, slave);
              scope.textOverlay().clearPreview();
            } catch (err) {
              scope.textOverlay().setPreviewAreaMessage('ILL RWY');
              Command.registerCleanupFunction(function() {
                scope.textOverlay().clearPreviewAreaMessage();
              });
            }
          } else {
            scope.textOverlay().setPreviewAreaMessage('ILL APT');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
        throw Command.ERROR.TAKE_NO_ACTION;
      };
    case toggleCRDACommand.test(command):
      return function(e, args) {
        Command.enterable(e);
        var result = toggleCRDACommand.exec(command),
            num = parseInt(result[1], 10);
        scope.CRDAManager().toggleCRDA(num);
      };
  }
  return null;
};

Command[Command.SEGMENT_TYPE.PLACEHOLDER] = {};

Command[Command.SEGMENT.SHOW_COORDINATES] = function(e, args) {
  if (e.type === 'click') {
    var pos = scope.selectPosition(e);
    scope.addRenderPoint(pos);
    scope.textOverlay().setPreviewAreaMessage(pos._lat.toFixed(4) + ',' + pos._lon.toFixed(4));
    Command.registerCleanupFunction(function() {
      scope.textOverlay().clearPreviewAreaMessage();
      scope.clearRenderPoints();
    });
    Command.cleanupIn(15000);
    return;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_JRING] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.disableJRing();
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_ALL_JRINGS] = function(e, args) {
  Command.enterable(e);
  scope.targetManager().getAllTargets().forEach(function(target) {
    target.disableJRing();
  });
};

Command[Command.SEGMENT.CLEAR_CONE] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.disableCone();
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.CLEAR_ALL_CONES] = function(e, args) {
  Command.enterable(e);
  scope.targetManager().getAllTargets().forEach(function(target) {
    target.disableCone();
  });
};

Command[Command.SEGMENT.MANAGE_CRDA] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      target.promoteGhosting();
      return;
    }
    target = scope.CRDAManager().select(e);
    if (target) {
      target.demoteGhosting();
      return;
    }
    throw Command.ERROR.FORMAT;
  } else {
    scope.CRDAManager().toggle();
  }
};

Command[Command.SEGMENT.RELOCATE_TARGET] = (function() {
  var selectedTarget = null;
  return function(e, args) {
    if (e.type === 'click') {
      var target = scope.select(e);
      if (target) {
        selectedTarget = target;
        throw Command.ERROR.TAKE_NO_ACTION;
      } else if (selectedTarget) {
        var newPos = scope.selectPosition(e);
        console.log('emitting:');
        console.log('TS.relocate');
        console.log({
          callsign: selectedTarget.callsign(),
          lat: newPos._lat,
          lon: newPos._lon
        });
        socket.emit('TS.relocate', {
          callsign: selectedTarget.callsign(),
          lat: newPos._lat,
          lon: newPos._lon
        });
        return;
      }
    }
    throw Command.ERROR.FORMAT;
  };
})();

Command[Command.SEGMENT.MEASURE_DISTANCE] = function(e, args) {
  if (e.type === 'click') {
    var headingAndDistance = scope.measureHeadingAndDistance(e);
    if (headingAndDistance) {
      scope.addRenderPoint(scope.selectPosition(e));
      scope.textOverlay().clearPreview();
      scope.textOverlay().setPreviewAreaMessage(headingAndDistance.heading + '/' + headingAndDistance.distance);
      Command.registerCleanupFunction(function() {
        scope.textOverlay().clearPreviewAreaMessage();
        scope.clearRenderPoints();
      });
      Command.cleanupIn(15000);
    }
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.INITIATE_CONTROL] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      if (target.isUndergoingHandoff()) {
        scope.textOverlay().setPreviewAreaMessage('ILL TRK');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
      } else {
        socket.emit('ATC.initiateControl', {
          aircraft: target.callsign(),
          controller: scope.controller().getIdentifier()
        }, function(success) {
          if (!success) {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      }
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.TERMINATE_CONTROL] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target) {
      if (target.isUndergoingHandoff()) {
        scope.textOverlay().setPreviewAreaMessage('ILL TRK');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
      } else if (target.isUndergoingInboundHandoff()) {
        socket.emit('ATC.refuseHandoff', {
          controller: target.otherController().getIdentifier(),
          to: scope.controller().getIdentifier(),
          aircraft: target.callsign()
        }, function(success) {
          if (success) {
            target.refuseHandoff();
          } else {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      } else {
        socket.emit('ATC.terminateControl', {
          aircraft: target.callsign(),
          controller: scope.controller().getIdentifier()
        }, function(success) {
          if (!success) {
            scope.textOverlay().setPreviewAreaMessage('ILL TRK');
            Command.registerCleanupFunction(function() {
              scope.textOverlay().clearPreviewAreaMessage();
            });
          }
        });
      }
      return;
    }
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.TOGGLE_CONFLICT_ALERTS] = function(e, args) {
  if (e.type === 'click') {
    var target = scope.select(e);
    if (target)
      return target.toggleConflictAlerts();
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.ILS] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.ILS][Command.SEGMENT_TYPE.RUNWAY] = function(e, args) {
  var FORMAT_ERROR = false;
  scope.facilityManager().primaryAirport(function(airport) {
    if (airport) {
      var callsign = args[0],
          runwayID = args[2],
          target = scope.targetManager().getTargetByCallsign(callsign),
          runway = airport.runway(runwayID);
      if (target && runway) {
        socket.emit('TS.ILS', {
          callsign: callsign,
          icao: airport.icao(),
          runway: runwayID
        });
        scope.textOverlay().clearPreview();
        return;
      }
    }
    scope.textOverlay().formatError();
    FORMAT_ERROR = true;
  });
  if (FORMAT_ERROR)
    throw Command.ERROR.FORMAT;
  return;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.VISUAL_APPROACH] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.VISUAL_APPROACH][Command.SEGMENT_TYPE.RUNWAY] = function(e, args) {
  var FORMAT_ERROR = false;
  scope.facilityManager().primaryAirport(function(airport) {
    if (airport) {
      var callsign = args[0],
          runwayID = args[2],
          target = scope.targetManager().getTargetByCallsign(callsign),
          runway = airport.runway(runwayID);
      if (target && runway) {
        socket.emit('TS.visualApproach', {
          callsign: callsign,
          icao: airport.icao(),
          runway: runwayID
        });
        scope.textOverlay().clearPreview();
        return;
      }
    }
    scope.textOverlay().formatError();
    FORMAT_ERROR = true;
  });
  if (FORMAT_ERROR)
    throw Command.ERROR.FORMAT;
  return;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.FLY_HEADING] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.FLY_HEADING][Command.SEGMENT_TYPE.HEADING] = function(e, args) {
  var callsign = args[0],
      heading = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignHeading(heading)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.MAINTAIN_ALTITUDE] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.MAINTAIN_ALTITUDE][Command.SEGMENT_TYPE.SPEED] = function(e, args) {
  var callsign = args[0],
      altitude = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignAltitude(altitude)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.SPEED] = {};
Command[Command.SEGMENT_TYPE.CALLSIGN][Command.SEGMENT.SPEED][Command.SEGMENT_TYPE.SPEED] = function(e, args) {
  var callsign = args[0],
      speed = args[2],
      target = scope.targetManager().getTargetByCallsign(callsign);
  if (target && target.assignSpeed(speed)) {
    scope.textOverlay().keepFirstLine();
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};

Command[Command.SEGMENT.SHOW_PATH] = {};
Command[Command.SEGMENT.SHOW_PATH][Command.SEGMENT_TYPE.PATH_NAME] = function(e, args) {
  try {
    scope.pathManager().showPath(args[1].toUpperCase());
  } catch (err) {
    switch (err) {
      case PathManager.ERROR.PATH_NOT_FOUND:
        scope.textOverlay().setPreviewAreaMessage('ILL PTH');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
        throw Command.ERROR.TAKE_NO_ACTION;
    }
  }
};

Command[Command.SEGMENT.HIDE_PATH] = {};
Command[Command.SEGMENT.HIDE_PATH][Command.SEGMENT_TYPE.PATH_NAME] = function(e, args) {
  try {
    scope.pathManager().hidePath(args[1].toUpperCase());
  } catch (err) {
    switch (err) {
      case PathManager.ERROR.PATH_NOT_FOUND:
        scope.textOverlay().setPreviewAreaMessage('ILL PTH');
        Command.registerCleanupFunction(function() {
          scope.textOverlay().clearPreviewAreaMessage();
        });
        throw Command.ERROR.TAKE_NO_ACTION;
    }
  }
};

Command[Command.SEGMENT.DRAW_PATH] = {};
Command[Command.SEGMENT.DRAW_PATH][Command.SEGMENT_TYPE.PATH_NAME] = (function() {
  var path = null,
      cleanup = function() {
        path = null;
        scope.textOverlay().clearPreviewAreaMessage();
      };
  return function(e, args) {
    scope.textOverlay().clearPreviewAreaMessage();
    var pathName = args[1].toUpperCase();
    if (!pathName)
      throw Command.ERROR.FORMAT;
    if (!path)
      path = new Path(pathName);
    if (e.type === 'click') {
      Command.registerCleanupFunction(cleanup, true);
      var pos = scope.selectPosition(e),
          waypoints = path.waypoints(),
          last = waypoints[waypoints.length - 1],
          secondToLast = waypoints[waypoints.length - 2];
      if (last) {
        if (last.position.distanceTo(pos) * 0.539957 < 1) {
          scope.textOverlay().setPreviewAreaMessage('ILL DIST');
          throw Command.ERROR.TAKE_NO_ACTION;
        }
        if (secondToLast) {
          var lastBearing = secondToLast.position.bearingTo(last.position),
              newBearing = last.position.bearingTo(pos);
          if (scope.renderer().angleBetweenHeadings(lastBearing, newBearing) >= 90) {
            scope.textOverlay().setPreviewAreaMessage('ILL TURN');
            throw Command.ERROR.TAKE_NO_ACTION;
          }
        }
      }
      path.addWaypoint(null, pos);
      scope.pathManager().setPath(path);
      scope.pathManager().showPath(pathName);
      throw Command.ERROR.TAKE_NO_ACTION;
    }
    cleanup();
  };
})();

Command[Command.SEGMENT.TYPE_PATH] = {};
Command[Command.SEGMENT.TYPE_PATH][Command.SEGMENT_TYPE.PATH_NAME] = {};
Command[Command.SEGMENT.TYPE_PATH][Command.SEGMENT_TYPE.PATH_NAME][Command.SEGMENT_TYPE.PATH_FIXES] = function(e, args) {
  scope.textOverlay().clearPreviewAreaMessage();
  var pathName = args[1].toUpperCase(),
      waypoints = args[2].split('.'),
      numRequiredWaypoints = waypoints.length;
  if (pathName && numRequiredWaypoints) {
    scope.textOverlay().setPreviewAreaMessage('LOAD...');
    var numResolvedWaypoints = 0,
        waypointLocations = {},
        path = new Path(pathName),
        formRoute = function() {
          Command.registerCleanupFunction(function() {
            scope.clearRenderPaths();
            scope.textOverlay().clearPreviewAreaMessage();
          }, true);
          for (var i in waypoints) {
            var waypointName = waypoints[i],
                waypointLocation = waypointLocations[waypointName];
            if (waypointLocation)
              path.addWaypoint(waypointName, waypointLocation);
            else {
              scope.textOverlay().setPreviewAreaMessage('ILL RTE');
              return;
            }
          }
          scope.pathManager().setPath(path);
          scope.pathManager().showPath(pathName);
          scope.textOverlay().clearPreviewAreaMessage();
        },
        navaidHandler = function(navaid, data) {
          numResolvedWaypoints++;
          if (data.navaid)
            waypointLocations[navaid] = data.navaid;
          if (numResolvedWaypoints === numRequiredWaypoints)
            formRoute();
        },
        fixHandler = function(fix, data) {
          numResolvedWaypoints++;
          if (data.fix)
            waypointLocations[fix] = data.fix;
          if (numResolvedWaypoints === numRequiredWaypoints)
            formRoute();
        };
    for (var i in waypoints) {
      waypoints[i] = waypoints[i].toUpperCase();
      var waypoint = waypoints[i];
      if (waypoint.length === 3)
        $.get('/api/navaids/' + waypoint, navaidHandler.bind(this, waypoint));
      else if (waypoint.length === 5)
        $.get('/api/fixes/' + waypoint, fixHandler.bind(this, waypoint));
      else {
        numResolvedWaypoints++;
        if (numResolvedWaypoints === numRequiredWaypoints)
          formRoute();
      }
    }
    throw Command.ERROR.TAKE_NO_ACTION;
  }
  throw Command.ERROR.FORMAT;
};function ConnectionDelegate(scope, socket) {
  this._scope = scope;
  this._socket = socket;

  this.bindServerListeners();
}

ConnectionDelegate.prototype.bindServerListeners = function() {

  this._socket.on('textMessage', function(data) {
    var $msg = $('<p>').text(data.from.toUpperCase() + '> ' + data.message);
    $('.incoming-messages').append($msg);
  });

  this._socket.on('controllers', function(controllers) {
    this._scope.setControllers(controllers.map(function(controller) {
      return Controller.fromJSON(controller);
    }));
  }.bind(this));

  this._socket.on('ownershipClaimed', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var controller = scope.getControllerByIdentifier(data.controller);
      target.setController(controller);
    }
  });

  this._socket.on('handoffRequested', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var controller = scope.getControllerByIdentifier(data.controller);
      target.inboundHandoff(controller);
    }
  });

  this._socket.on('handoffAccepted', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      var to = scope.getControllerByIdentifier(data.to);
      target.handoffAccepted(to);
    }
  });

  this._socket.on('handoffRefused', function(data) {
    var target = scope.targetManager().getTargetByCallsign(data.aircraft);
    if (target) {
      target.handoffRefused();
    }
  });

};var scope = new Scope(socket);
var connectionDelegate = new ConnectionDelegate(scope, socket);
//var radio = new SpeechCommands();

// var config = { 'worker_path': '/vendor/worker.min.js' };
// AudioRecorder.init(config);

// AudioRecorder.record();
// setTimeout(function() {
//   AudioRecorder.stopRecording(function(clip) {
//     AudioRecorder.playClip(clip, 0, 0);

//     console.log(clip.speex);
//   });
// }, 5000);


$(document).ready(function() {
	initScope();
	initScopeZoom();
	initScopeResize();
	initScopeDrag();
	initKeyDetection();
	initSlewDetection();
  initSettings();

  $('.control-section h1').click(function() {
    var $parent = $(this).parent();
    if ($parent.hasClass('expanded')) {
      $parent.removeClass('expanded');
    } else {
      $('.control-section').removeClass('expanded');
      $parent.addClass('expanded');
    }
  });
  $('.control-section .button').click(function() {
    var txt = $(this).text().trim();
    if (txt === 'On' || txt === 'Off')
      $(this).text(txt === 'On' ? 'Off' : 'On');
  });
  $('.control-section').keydown(function(e) {
    e.stopPropagation();
  });
  $('.control-section').keypress(function(e) {
    e.stopPropagation();
  });
  $('.control-section input').mouseout(function(e) {
    $(this).blur();
  });
});

function initScope() {
	scope.bind('#scope');
  // scope.addMap('22L27', '', 'maps/a90.map', function() {
  //   scope.render();
  // });
  
	//scope.addMap('BOSMHT', '', 'maps/bosmht.map', function() {
		//scope.render();
		setInterval(function() {
			scope.render();
		}, 1000 / 30);
    //React.renderComponent(<MasterDCB />, document.getElementById('wahoo'));
	//});
  scope.facilityManager().setPrimaryAirport('KBOS');
  scope.facilityManager().primaryAirport(function(airport) {
    if (!airport)
      return;
    scope.enableSmartMap();
    scope.radar().setPosition(airport.position());
    scope.renderer().setRadarCenter(scope.radar().position());
    //scope.CRDAManager().addRemoveCRDA(airport, '27', '22L');
    scope.setControllerPosition('FINAL', function() {
      scope.turnOn();
    });
  });
}

function initScopeZoom() {
	$('#scope').bind('mousewheel wheel', function(e) {
		var scale = 1 + e.originalEvent.wheelDelta / 1000;
		scale = Math.min(Math.max(scale, .5), 2);
		scope.renderer().setGlobalScale(scope.renderer().globalScale() * scale);
		scope.render();
	});
}

function initScopeResize() {
	$(window).resize(function() {
		scope.render();
	});
}

function initScopeDrag() {
	$('#scope').bind('mousedown touchstart', function(e) {
		e = e.type == 'touchstart' ? e.touches[0] : e;
		scope.renderer().setMouseDown(true);
		scope.renderer().setLastMousePosition({
			x: e.clientX,
			y: e.clientY
		});
		return false;
	});
	$('#scope').bind('mouseup mouseover mouseout touchend touchcancel', function(e) {
    scope.renderer().setMouseDown(false);
  });
	$('#scope').bind('mousemove touchmove', function(e) {
    e = e.type === 'touchmove' ? e.touches[0] : e;
		if (scope.renderer().mouseDown()) {
      scope.renderer().dragging();
			scope.renderer().setTranslationOffset({
				x: scope.renderer().translationOffset().x + scope.renderer().scale(e.clientX - scope.renderer().lastMousePosition().x),
				y: scope.renderer().translationOffset().y + scope.renderer().scale(scope.renderer().lastMousePosition().y - e.clientY)
			});
			scope.renderer().setLastMousePosition({
				x: e.clientX,
				y: e.clientY
			});
			scope.render();
		}
		return false;
	});
}

function initSlewDetection() {
	$('#scope').click(function(e) {
    if (!scope.renderer().wasDragging())
      Command.run(e, scope.textOverlay().previewSegments());
	});
}

function initKeyDetection() {
  $(document).keypress(function(e) {
    scope.textOverlay().addPreviewChar(String.fromCharCode(e.which).toUpperCase());
    scope.render();
  });
	$(document).keydown(function(e) {
    if (e.which === Keyboard.KEYS.ENTER) {
      e.preventDefault();
      Command.run(e, scope.textOverlay().previewSegments());
    } else if (e.which === Keyboard.KEYS.SELECT_KEY) {
      e.preventDefault();
      //radio.transmit();
    } else {
      Command.cleanup();
      var keyCommands = Keyboard[e.which];
      if (keyCommands) {
        var command = keyCommands[Keyboard.combo(e)];
        if (command) {
          e.preventDefault();
          command(e);
          scope.render();
        }
      }
    }
	});
  $(document).keyup(function(e) {
    if (e.which === Keyboard.KEYS.SELECT_KEY) {
      e.preventDefault();
      //radio.release();
    }
  });
}

function initSettings() {
  $(document).ready(function() {
    $('#setting-compass-brightness').change(function(e) {
      scope.compass().setBrite($(this).val());
      scope.render();
    });
    $('#setting-map-brightness').change(function(e) {
      for (var i in scope.maps())
        scope.maps()[i].setBrite($(this).val());
      scope.render();
    });
  });
}